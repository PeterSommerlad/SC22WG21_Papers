\documentclass[ebook,11pt,article]{memoir}
\usepackage{geometry}  % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}  % ... or a4paper or a5paper or ... 
%\geometry{landscape}  % Activate for for rotated page geometry
%%% from std.tex
%\usepackage[american]
%           {babel}        % needed for iso dates
%\usepackage[iso,american]
%           {isodate}      % use iso format for dates
\usepackage[final]
           {listings}     % code listings
%\usepackage{longtable}    % auto-breaking tables
%\usepackage{ltcaption}    % fix captions for long tables
\usepackage{relsize}      % provide relative font size changes
%\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{underscore}   % remove special status of '_' in ordinary text
%\usepackage{parskip}      % handle non-indented paragraphs "properly"
%\usepackage{array}        % new column definitions for tables
\usepackage[normalem]{ulem}
\usepackage{enumitem}
\usepackage{color}        % define colors for strikeouts and underlines
%\usepackage{amsmath}      % additional math symbols
%\usepackage{mathrsfs}     % mathscr font
\usepackage[final]{microtype}
%\usepackage{multicol}
\usepackage{xspace}
%\usepackage{lmodern}
\usepackage[T1]{fontenc} % makes tilde work! and is better for umlauts etc.
%\usepackage[pdftex, final]{graphicx}
\usepackage[pdftex,
%            pdftitle={C++ International Standard},
%            pdfsubject={C++ International Standard},
%            pdfcreator={Richard Smith},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}
%\usepackage{memhfixc}     % fix interactions between hyperref and memoir
%\usepackage[active,header=false,handles=false,copydocumentclass=false,generate=std-gram.ext,extract-cmdline={gramSec},extract-env={bnftab,simplebnf,bnf,bnfkeywordtab}]{extract} % Grammar extraction
%
\renewcommand\RSsmallest{5.5pt}  % smallest font size for relsize


%%%% reuse all three from std.tex:
\input{macros}
\input{layout}
\input{styles}
\renewcommand{\iref}[1]{[#1]}


\pagestyle{myheadings}


\newcommand{\papernumber}{p0408r5}
\newcommand{\paperdate}{2018-10-01}

%\definecolor{insertcolor}{rgb}{0,0.5,0.25}
%\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}}
%\newcommand{\ins}[1]{\textcolor{insertcolor}{\underline{#1}}}
%
%\newenvironment{insrt}{\color{insertcolor}}{\color{black}}


\markboth{\papernumber{} \paperdate{}}{\papernumber{} \paperdate{}}

\title{\papernumber{} - Efficient Access to basic\_stringbuf's Buffer\\
Including wording from p0407 Allocator-aware basic\_stringbuf}
\author{Peter Sommerlad}
\date{\paperdate}                        % Activate to display a given date or no date
\setsecnumdepth{subsection}

\begin{document}
\maketitle
\begin{tabular}[t]{|l|l|}\hline 
Document Number: & \papernumber  \\\hline
Date: & \paperdate \\\hline
Project: & Programming Language C++\\\hline 
Audience: & LWG\\\hline
Target: & C++20\\\hline
\end{tabular}

\chapter{Motivation}
Streams have been the oldest part of the C++ standard library and their specification doesn't take into account many things introduced since C++11. One of  the oversights is that there is no non-copying access to the internal buffer of a \tcode{basic_stringbuf} which makes at least the obtaining of the output results from an \tcode{ostringstream} inefficient, because a copy is always made. I personally speculate that this was also the reason why \tcode{basic_strbuf} took so long to get deprecated with its \tcode{char *} access.

With move semantics and \tcode{basic_string_view} there is no longer a reason to keep this pessimissation alive on \tcode{basic_stringbuf}.

\added{I also believe we should remove \tcode{basic_strbuf} from the standard's appendix [depr.str.strstreams]. This is proposed in p0448, that completes the replacement of that deprecated feature.}

\chapter{Introduction}
This paper proposes to adjust the API of \tcode{basic_stringbuf} and the corresponding stream class templates to allow accessing the underlying string more efficiently.

C++17 and library TS have \tcode{basic_string_view} allowing an efficient read-only access to a contiguous sequence of characters which I believe \tcode{basic_stringbuf} has to guarantee about its internal buffer, even if it is not implemented using \tcode{basic_string} obtaining a \tcode{basic_string_view} on the internal buffer should work sidestepping the copy overhead of calling \tcode{str()}. 

On the other hand, there is no means to construct a \tcode{basic_string} and move from it into a \tcode{basic_stringbuf} via a constructor or a move-enabled overload of \tcode{str(basic_string \&\&)}.

\section{History}

\subsection{Changes from r4}
Incorporate suggestions from LWG review in Batavia, August 2018. This was the first time the combined proposal was reviewed.
\begin{itemize}
\item Adjust specification sections to new naming schema introduced at the Rapperswil Meeting 2018 for C++20. (Requires->(Mandates (compile-time), Expects(contract)), Remarks->Constraints)

\item overload constructors with default arguments to only have the single argument version explicit according to p1163.
\item introduce an exposition-only member function \tcode{init_buf_ptrs()} in \tcode{basic_stringbuf} to set the streambuf pointers (in the original version, that was part of the \tcode{str(string)} member function and now is needed in more than one place. Add a note there about internally violating invariants of \tcode{buf}.
\item reduce clutter, since bit operations are possible in enum \tcode{ios_base::openmode} parameters.
\item Provide a note that allocator properties are propagated along the properties of the basic_string member buf.
\item It should be discussed if the following definition of swap for basic_stringbuf should be adopted. Note, the base class swap does not give a noexcept guarantee. I provided that:
\begin{codeblock}
void swap(basic_stringbuf& s)
  noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
           allocator_traits<Allocator>::is_always_equal::value);
\end{codeblock}
\item \tcode{basic_stringbuf} move constructor now guarantees that \tcode{rhs} is empty, as if \tcode{std::move(rhs).str()} was called. This seems the easiest way to guarantee its get and put area are re-initialized accordingly. While technically not required, it makes handling moved-from streambufs (which are rare) consistent with calling the rvalue-ref-qualified \tcode{str()} member function. Please note, we do not give such a guarantee to the moved-from state of the stream objects, since they get their buffer pointer stolen (I hope) and thus are completely unrelated to a streambuf afterwards.
\end{itemize}


\subsection{Changes from r3}
To make the job of reviewing and integrating my stringstream adjustments easier, I incorporate the changes proposed in p0407r2 (allocator-aware basic\_stringbuf), since both papers have been forwarded by LEWG to LWG.
\begin{itemize}
\item Added full set of reasonable overloads to the constructors with and without allocator (\tcode{basic_string\&\&} does not get an allocator constructor template argument to allow efficient construction from \tcode{charT*} literals).
\end{itemize}


\subsection{Changes from r2}
Discussed in Albuquerque, where LEWG was in favor to forward it to LWG for IS with the following change.
\begin{itemize}
\item reestablish rvalue-ref qualified \tcode{str()} instead of the previously suggested \tcode{pilfer()}.
\item address LWG only in document header.
\end{itemize}


\subsection{Changes from r1}
Discussed in LEWG Issaquah. Answering some questions and raising more. Reflected in this paper.
\begin{itemize}
\item reflected new section numbers from the std. now relative to the current working draft.
\item implementation is now working with gcc 7. (not relevant for this paper)
\end{itemize}

\subsection{Changes from r0}
\begin{itemize}
\item Added more context to synopsis sections to see all overloads (Thanks Alisdair).
\item rename \tcode{str_view()} to just \tcode{view()}. There was discussion on including an explicit conversion operator as well, but I didn't add it yet (my implementation has it).
\item renamed r-value-ref qualified \tcode{str()} to \tcode{pilfer()} and removed the reference qualification from it and remaining \tcode{str()} member.
\item Added allocator parameter for the \tcode{basic_string} parameter/result to member functions (see p0407 for allocator support for stringstreams in general)
\end{itemize}


\chapter{Acknowledgements}
\begin{itemize}
\item Daniel Kr\"ugler encouraged me to pursue this track.
\item Alisdair Meredith for telling me to include context in the synopsis showing all overloads. That is the only change in this version, no semantic changes!
\item Jonathan Wakely to show me the \tcode{\#undef _GLIBCXX_EXTERN_TEMPLATE}
\end{itemize}


%\chapter{example code}


\chapter{Impact on the Standard}
This is an extension to the API of \tcode{basic_stringbuf}, \tcode{basic_stringstream}, \tcode{basic_istringstream}, and \tcode{basic_ostringstream} class templates.

\removed{This paper addresses both Library Fundamentals TS 3 and C++Next (2020?).} 
When added to the standard draft with p0448 (spanstream), section [depr.str.strstreams] should be removed.


\chapter{Design Decisions}
After experimentation I decided that substituting the \tcode{(basic_string<charT,traits,Allocator const \&)} constructors in favor of passing a \tcode{basic_string_view} would lead to ambiguities with the new move-from-string constructors.

\section{Hint to implementers}
In both libc++ and libstdc++ I needed to make basic_stringbuf a friend of basic_string to allow efficient growth of the buffer beyond the current string length (breaking an invariant) until it is retrieved using one of the str() member functions. Other implementations might use a different strategy of caring for the buffer space that should be efficiently be adopted by the returned string object, thus requiring either special constructors or access to internals as well.

\section{Open Issues to be discussed by LWG}
Note: this list includes the discussion of p0407 features.
\begin{itemize}
\item \em{Does it make sense to add \tcode{noexcept} specifications for \tcode{move()} and \tcode{swap()} members, since the base classes and other streams do not. At least it does not make sense so for stream objects, since the base classes do not specify that.}
\item \em{The \tcode{basic_string} constructors that move from the string get a default template argument for \tcode{SAlloc} in the hope that allows initialization from a character string literal. Need confirmation that this trick works and selects the better constructor for temporary conversion without ambiguity, because for the copying (const-ref) overload the allocator of the string needs to be deduced. This should lead to the effect of optimizing existing usages.}
\end{itemize}

\section{Open Issues discussed by LEWG in Albuquerque}
\begin{itemize}
\item Should pilfer() be rvalue-ref qualified to denote the "destruction" of the underlying buffer? LEWG in Issaquah didn't think so, but I'd like to ask again. LEWG small group in Albuquerque in favor of rvalue-ref qualification.\added{ Re-establish \tcode{str()\&\&}, drop \tcode{pilfer}}
\end{itemize}

\section{Open Issues discussed by LEWG in Issaquah and Albuquerque}
\begin{itemize}
\item Is the name of the \tcode{str_view()} member function ok? No. Renamed to \tcode{view()}
\item Should the \tcode{str()\&\&} overload be provided for move-out? \removed{No. give it another name (\tcode{pilfer}) and remove rvalue-ref-qualification (Issaquah).}\added{ Re-establish \tcode{str()\&\&}, drop \tcode{pilfer}}
\item Should \tcode{str()\&\&} empty the character sequence or leave it in an unspecified but valid state? Empty it, and specify.
\item Provide guidance on validity lifetime of of the obtained \tcode{string_view} object.
\end{itemize}

\chapter{Technical Specifications}
The following is relative to n4604.

Remove section on \tcode{char*} streams [depr.str.strstreams] and all its subsections from appendix D.

\section{30.8.2 Adjust synopsis of basic\_stringbuf [stringbuf]}
Add a new constructor overload.

\textit{Note that p0407 provides allocator support for \tcode{basic_stringbuf}, since now both papers have been forwarded to LWG, the changes proposed in p0407 are integrated here for ease of review and integration. The explanations of those changes are added in italics here.}

\begin{em}
Change each of the non-moving, non-deleted constructors to add a const-ref \tcode{Allocator} parameter as last parameter with a default constructed \tcode{Allocator} as default argument. Add an overload for the move constructor adding an \tcode{Allocator} parameter. Add an exposition-only member variable \tcode{buf} to allow referring to it for specifying allocator behaviour. May be: Add noexcept specification, depending on allocator behavior, like with \tcode{basic_string}?\
\\
This section also adopts the changes of p1163 by only marking the single argument constructors explicit and provide non-explicit overloads for zero, two or more argument versions. That paper p1163 was tentatively accepted in Batavia, August 2018.
\end{em}

\begin{codeblock}
    // \iref{stringbuf.cons}, constructors:
    @\added{basic_stringbuf():basic_stringbuf(ios_base::in | ios_base::out)\{\}}@  
    @\added{basic_stringbuf(ios_base::openmode which, const Allocator\& a);}@
    explicit basic_stringbuf(
      ios_base::openmode which@\removed{ = ios_base::in | ios_base::out}@)
      @\added{: basic_stringbuf(ios_base::in | ios_base::out, Allocator())\{\}}\removed{;}@
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    basic_stringbuf(
      const basic_string<charT, traits, SAlloc>& str,
      ios_base::openmode which,
      const Allocator& a = Allocator());
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    @\added{template<class SAlloc>}@
    explicit basic_stringbuf(
      const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& str@\removed{,}@
      @\removed{ios_base::openmode which = ios_base::in | ios_base::out})\removed{;}@
      @\added{: basic_stringbuf(str, ios_base::in | ios_base::out)\{\}}@
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_stringbuf(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which,
      const Allocator& a = Allocator());
      
    explicit basic_stringbuf(
      basic_string<charT, traits, Allocator>&& s)
      : basic_stringbuf(std::move(s), ios_base::in | ios_base::out){}

    explicit basic_stringbuf(const Allocator& a)
      : basic_stringbuf(ios_base::in | ios_base::out, a) { }
      
    template<class SAlloc>
    basic_stringbuf(
      const basic_string<charT, traits, SAlloc>& s,
      const Allocator& a)
      : basic_stringbuf(s, ios_base::in | ios_base::out, a) { }

    basic_stringbuf(
      basic_string<charT, traits, Allocator>&& s,
      const Allocator& a)
      : basic_stringbuf(std::move(s), ios_base::in | ios_base::out, a) { }

\end{codeblock}\end{addedblock}%% no allocator for move, because it must be the same to steal from!
\begin{codeblock}
    basic_stringbuf(const basic_stringbuf& rhs) = delete;
    basic_stringbuf(basic_stringbuf&& rhs);
    @\added{basic_stringbuf(basic_stringbuf\&\& rhs, const Allocator\& a);}@        

\end{codeblock}

Change the getting \tcode{str()} overload to take an Allocator for the returned string and add a reference qualification. Add an rvalue-ref overload of \tcode{str()}.
Change the \tcode{str()} overload copying into the string buffer to take an allocator template parameter that could differ from the buffer's own \tcode{Allocator}. 
Add a \tcode{str()} overload that moves from its string rvalue-reference argument into the internal buffer.
Add the \tcode{view()} member function obtaining a \tcode{string_view} to the underlying internal buffer.
Provide an exposition-only member function \tcode{init_buf_ptrs()} to ensure streambuf pointers are initialized correctly by all \tcode{buf} setting operations.

\begin{codeblock}
    // \iref{stringbuf.members}, get and set:
    @\added{template<class SAlloc = Allocator>}@
    basic_string<charT,traits,@\added{S}@Alloc@\removed{ator}@> str(@\added{const SAlloc\& sa = SAlloc()}@) const @\added{\&}@;
    @\added{template<class SAlloc = Allocator>}@
    void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    void str(basic_string<charT, traits, Allocator>&& s);
    basic_string<charT, traits, Allocator> str() &&;
    basic_string_view<charT, traits> view() const;
\end{codeblock}
\end{addedblock}

\textit{Add the following declaration to the public section of synopsis of the class template \tcode{basic_stringbuf}:}
\begin{addedblock}
\begin{codeblock}
    allocator_type get_allocator() const noexcept;
\end{codeblock}
\end{addedblock}

\textit{Add the following exposition only member to the private section of synopsis of the class template \tcode{basic_stringbuf}. This allows to delegate all details of allocator-related behaviour on what \tcode{basic_string} is doing, simplifying this specification a lot.}
\begin{codeblock}
  private:
    ios_base::openmode mode;  // \expos
    @\added{basic_string<charT, traits, Allocator> buf; // \expos }@
    @\added{void init_buf_ptrs(); // \expos }@
\end{codeblock}

%\textit{May be: Add a conditional noexcept specification to swap based on Allocator's behaviour?:}
%\begin{codeblock}
%  template <class charT, class traits, class Allocator>
%    void swap(basic_stringbuf<charT, traits, Allocator>& x,
%              basic_stringbuf<charT, traits, Allocator>& y);
%\end{codeblock}

\emph{Adjust p2 of the section to include the additionbal exposition only members and add a note on the allocator properties of \tcode{basic_stringbuf}.}

\pnum
The class
\tcode{basic_stringbuf}
is derived from
\tcode{basic_streambuf}
to associate possibly the input sequence and possibly
the output sequence with a sequence of arbitrary
\term{characters}.
The sequence can be initialized from, or made available as, an object of class
\tcode{basic_string}.


\pnum
For the sake of exposition, the maintained data and internal pointer initialization is presented here as:
\begin{itemize}
\item
\tcode{ios_base::openmode mode},
has
\tcode{in}
set if the input sequence can be read, and
\tcode{out}
set if the output sequence can be written.
\begin{addedblock}
\item
\tcode{basic_string<charT, traits, Allocator> buf}
contains the underlying character sequence.
\item
\tcode{init_buf_ptrs()} 
sets the base class' 
get area (\iref{streambuf.get.area}) and 
put area (\iref{streambuf.put.area}) pointers 
after initializing, moving from, or assigning to 
\tcode{buf} 
accordingly.
\end{addedblock}
\end{itemize}

\begin{addedblock}
\pnum
\begin{note}
The allocator used by \tcode{basic_stringbuf} is only relevant for \tcode{buf} or the member functions initializing, assigning or returning \tcode{buf}. All allocator (propagation) properties are thus given by \tcode{basic_stringbuf}'s allocator properties.
\end{note}
\end{addedblock}



\subsection{30.8.2.1 basic\_stringbuf constructors [stringbuf.cons]}
\begin{em}
Adjust the constructor specifications taking the additional Allocator parameter and an overload for the move-constructor taking an Allocator:
\end{em}

\begin{itemdecl}
explicit basic_stringbuf(
  ios_base::openmode which = ios_base::in | ios_base::out@\added{,}@
  @\added{const Allocator \&a = Allocator()}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_stringbuf},
initializing the base class with
\tcode{basic_streambuf()}\iref{streambuf.cons}, \removed{and} initializing
\tcode{mode}
with \tcode{which}\added{, and \tcode{buf} with \tcode{a}. Calls \tcode{init_buf_ptrs()}}.

\pnum
\ensures
\tcode{str() == ""}.
\end{itemdescr}

Modify the following constructor specification:
\begin{itemdecl}
@\added{template<class SAlloc>}@
explicit basic_stringbuf(
  const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s,
  ios_base::openmode which = ios_base::in | ios_base::out@\added{,}@
  @\added{const Allocator\& a = Allocator()}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_stringbuf},
initializing the base class with
\tcode{basic_streambuf()}\iref{streambuf.cons}, \removed{and} initializing
\tcode{mode}
with \tcode{which}\added{, and initializing \tcode{buf} with \tcode{\{s,a\}}. Calls \tcode{init_buf_ptrs()}}.
\removed{Then calls \tcode{str(s)}.}
\end{itemdescr}

Add the following constructor specifications:

\begin{insrt}
\begin{itemdecl}
explicit basic_stringbuf(
  basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which = ios_base::in | ios_base::out,
  const Allocator\& a = Allocator());
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{basic_stringbuf}, initializing the base class with \tcode{basic_streambuf()} (30.6.3.1), and initializing \tcode{mode} with \tcode{which}. 
%old:
\removed{Then calls \tcode{str(std::move(s))}.}
%% p0407: 
\added{, and initializing \tcode{buf} with \tcode{\{std::move(s), a\}}. Calls \tcode{init\_buf\_ptrs()}}.
\end{itemdescr}
\end{insrt}

Note to reviewers: \textit{For p0407, different allocators for \tcode{s} and the \tcode{basic_stringbuf} will result in a copy instead of a move.}

\textit{Add the additional move constructor taking an allocator and adjust the description accordingly:}

\begin{itemdecl}
basic_stringbuf(basic_stringbuf&& rhs);
@\added{basic_stringbuf(basic_stringbuf\&\& rhs, const Allocator\& a);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Move constructs from the rvalue \tcode{rhs}. 
\added{In the first form \tcode{buf} is initialized from \tcode{\{std::move(rhs.buf)\}}. In the second form \tcode{buf} is initialized from \tcode{\{std::move(rhs.buf), a\}}.}
It
is
\impldef{whether sequence pointers are copied by \tcode{basic_stringbuf} move
constructor} whether the sequence pointers in \tcode{*this}
(\tcode{eback()}, \tcode{gptr()}, \tcode{egptr()},
\tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}) obtain
the values which \tcode{rhs} had. Whether they do or not, \tcode{*this}
and \tcode{rhs} reference separate buffers (if any at all) after the
construction. The openmode, locale and any other state of \tcode{rhs} is
also copied.

\pnum
\ensures Let \tcode{rhs_p} refer to the state of
\tcode{rhs} just prior to this construction and let \tcode{rhs_a}
refer to the state of \tcode{rhs} just after this construction.

\begin{itemize}
\item \tcode{str() == rhs_p.str()}
\item \tcode{gptr() - eback() == rhs_p.gptr() - rhs_p.eback()}
\item \tcode{egptr() - eback() == rhs_p.egptr() - rhs_p.eback()}
\item \tcode{pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()}
\item \tcode{epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()}
\item \tcode{if (eback()) eback() != rhs_a.eback()}
\item \tcode{if (gptr()) gptr() != rhs_a.gptr()}
\item \tcode{if (egptr()) egptr() != rhs_a.egptr()}
\item \tcode{if (pbase()) pbase() != rhs_a.pbase()}
\item \tcode{if (pptr()) pptr() != rhs_a.pptr()}
\item \tcode{if (epptr()) epptr() != rhs_a.epptr()}
\begin{addedblock}
\item \tcode{rhs} is empty but usable, as if \tcode{std::move(rhs).str()} was called.
\end{addedblock}
\end{itemize}
\end{itemdescr}

%\rSec3[stringbuf.assign]{Assign and swap}
\section{30.8.2.2 Assign and swap [stringbuf.assign]}
\textit{Most of this section is included to allow for simpler adding of conditional noexcept.}

\indexlibrarymember{operator=}{basic_stringbuf}%
\begin{itemdecl}
basic_stringbuf& operator=(basic_stringbuf&& rhs);
\end{itemdecl}
%\added{noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||}\\
%      \added{allocator_traits<Allocator>::is_always_equal::value)}@;

\begin{itemdescr}
\pnum
\effects \added{Move assigns \tcode{buf} from \tcode{rhs.str())}}. After the move assignment \tcode{*this} has the observable state it would
have had if it had been move constructed from \tcode{rhs} (see~\iref{stringbuf.cons}).

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{swap}{basic_stringbuf}%
\begin{itemdecl}
void swap(basic_stringbuf& rhs);
@\added{noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||}\\
       \added{allocator_traits<Allocator>::is_always_equal::value)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Exchanges the state of \tcode{*this}
and \tcode{rhs}. \added{Specifically, \tcode{buf.swap(rhs.buf)}.}
\end{itemdescr}

\indexlibrarymember{swap}{basic_stringbuf}%
\begin{itemdecl}
template <class charT, class traits, class Allocator>
  void swap(basic_stringbuf<charT, traits, Allocator>& x,
            basic_stringbuf<charT, traits, Allocator>& y);
@\added{noexcept(noexcept(x.swap(y)))}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}




\subsection{30.8.2.3 Member functions [stringbuf.members]}
\textit{Add the definition of the \tcode{get_allocator} function:}
\begin{addedblock}
%\indexlibrarymember{get_allocator}{basic_stringbuf}%
\begin{itemdecl}
allocator_type get_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{buf.get_allocator()}.

\end{itemdescr}
\end{addedblock}




Add an allocator parameter for the copied from string to allow having a different allocator than the underlying stream and a ref-qualifier to avoid ambiguities with the rvalue-ref qualified overload.
\begin{codeblock}
@\added{template<class SAlloc = Allocator>}@
basic_string<charT, traits,@\added{S}@Alloc@\removed{ator}@> str(@\added{const SAlloc\& sa = SAlloc()}@) const @\added{\&};
\end{codeblock}

Change p1 to use plural for "\tcode{str(basic_string)} member functions" and refer to the allocator:

\begin{itemdescr}
\pnum
\returns
A
\tcode{basic_string}
object \added{with allocator \tcode{sa} }whose content is equal to the
\tcode{basic_stringbuf}
underlying character sequence.
If the \tcode{basic_stringbuf} was created only in input mode, the resultant
\tcode{basic_string} contains the character sequence in the range
\range{eback()}{egptr()}. If the \tcode{basic_stringbuf} was created with
\tcode{which \& ios_base::out} being true then the resultant \tcode{basic_string}
contains the character sequence in the range \range{pbase()}{high_mark}, where
\tcode{high_mark} represents the position one past the highest initialized character
in the buffer. Characters can be initialized by writing to the stream, by constructing
the \tcode{basic_stringbuf} with a \tcode{basic_string}, or by calling 
\added{one of }
the
\tcode{str(basic_string)} member function\added{s}. In the case of calling 
\added{one of }
the
\tcode{str(basic_string)} member function\added{s}, all characters initialized prior to
the call are now considered uninitialized (except for those characters re-initialized
by the new \tcode{basic_string}). Otherwise the \tcode{basic_stringbuf} has been created
in neither input nor output mode and a zero length \tcode{basic_string} is returned. 

\begin{addedblock}
\pnum % taken from container.requirements.general p.17
\constraints 
This function does not participate in overload resolution, unless \tcode{SAlloc} satisfies both of the following conditions: 

\begin{itemize}
\item The \grammarterm{qualified-id} \tcode{SAlloc::value_type}
is valid and denotes a type\iref{temp.deduct}.

\item The expression \tcode{declval<SAlloc\&>().allocate(size_t\{\})}
is well-formed when treated as an unevaluated operand.
\end{itemize}
\end{addedblock}
\end{itemdescr}

Add the following specifications and adjust the wording of \tcode{str() const} according to the wording given for \tcode{view() const} member function. Introduce the exposition only private member functions \tcode{init_buf_ptrs()} to provide the correct intialization of streambuf pointer members and adjust the \tcode{str(s)} member functions with parameters accordingly.:

\begin{insrt}
\begin{itemdecl}
basic_string<charT, traits, Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}

\pnum
\returns A \tcode{basic_string} object moved from 
%\tcode{buf}.
the \tcode{basic_stringbuf} underlying character sequence
in \tcode{buf}. 
If the \tcode{basic_stringbuf} was created only in input mode, 
\tcode{basic_string(eback(), egptr()-eback())}. 
If the \tcode{basic_stringbuf} was created with \tcode{which \& ios_base::out} being true 
then \tcode{basic_string(pbase(), high_mark-pbase())}, 
where \tcode{high_mark} represents the position one past the highest initialized character in the buffer. 
Characters can be initialized by writing to the stream, 
by constructing the \tcode{basic_stringbuf} with a \tcode{basic_string}, 
or by calling one of the \tcode{str(basic_string)} member functions. 
In the case of calling one of the \tcode{str(basic_string)} member functions, 
all characters initialized prior to the call are now considered uninitialized 
(except for those characters re-initialized by the new \tcode{basic_string}). 
Otherwise the \tcode{basic_stringbuf} has been created in neither input nor output mode 
and an empty \tcode{basic_string} is returned. 

\pnum
\ensures The underlying character sequence \tcode{buf} is empty and \tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}, \tcode{eback()}, \tcode{gptr()}, \tcode{egptr()} are initialized as of calling \tcode{init_buf_ptrs()} with an empty \tcode{buf}.
%% needed here? YES!!

\pnum
\begin{note}
After calling this member function the \tcode{basic_stringbuf} object remains usable.
\end{note}
\end{itemdescr}

\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns A \tcode{basic_string_view} object referring to the \tcode{basic_stringbuf} underlying character sequence
in \tcode{buf}. 
If the \tcode{basic_stringbuf} was created only in input mode,  
\tcode{basic_string_view(eback(), egptr()-eback())}. 
If the \tcode{basic_stringbuf} was created with \tcode{which \& ios_base::out} being true 
then \tcode{basic_string_view(pbase(), high_mark-pbase())}, 
where \tcode{high_mark} represents the position one past the highest initialized character in the buffer. 
Characters can be initialized by writing to the stream, 
by constructing the \tcode{basic_stringbuf} with a \tcode{basic_string}, 
or by calling one of the \tcode{str(basic_string)} member functions. 
In the case of calling one of the \tcode{str(basic_string)} member functions, 
all characters initialized prior to the call are now considered uninitialized 
(except for those characters re-initialized by the new \tcode{basic_string}). 
Otherwise the \tcode{basic_stringbuf} has been created in neither input nor output mode 
and a \tcode{basic_string_view} referring to an empty range is returned. 

\pnum
\begin{note}
Using the returned \tcode{basic_string_view} object after destruction or any modification of the character sequence underlying \tcode{*this}, such as output on the holding stream, will cause undefined behavior, because the internal string referred by the return value might have changed or re-allocated. 
\end{note}
\end{itemdescr}


\begin{itemdecl}
void init_buf_ptrs();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Initializes the input and output sequences according to \tcode{mode}.
%% mode is an exposition-only member of basic_strinbuf

\pnum
\ensures
If \tcode{mode \& ios_base::out} is true, 
\tcode{pbase()} points to \tcode{buf.front()} and \\\tcode{epptr() >= pbase() + buf.size()} holds; 
in addition, if \tcode{mode \& ios_base::ate} is true, \\
\tcode{pptr() == pbase() + buf.size()} holds, 
otherwise \tcode{pptr() == pbase()} is true. \\
If \tcode{mode \& ios_base::in} is true, 
\tcode{eback()} points to \tcode{buf.front()}, 
and both \\\tcode{gptr() == eback()} and \tcode{egptr() == eback() + buf.size()} hold.

\pnum
\begin{note}
For efficiency reasons stream buffer operations might violate invariants of \tcode{buf} while it is held encapsulated in the \tcode{basic_strinbuf}, i.e., by writing to characters in the range (\tcode{buf.data()+buf.size(), buf.data()+buf.capacity()}). All operations retrieving a \tcode{basic_string} from \tcode{buf} ensure that the \tcode{basic_string} invariants hold on the returned value. Implementations might make \tcode{basic_stringbuf} a friend class to \tcode{basic_string} to achieve that.
\end{note}
\end{itemdescr}

\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Move-assigns \tcode{buf} from \tcode{s}. Calls \tcode{init_buf_ptrs()}.
\end{itemdescr}
\end{insrt}

\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{buf = s}. Calls \tcode{init_buf_ptrs()}.
\removed{
Copies the content of \tcode{s} into the \tcode{basic_stringbuf} underlying character
sequence and initializes the input and output sequences according to \tcode{mode}}.

\begin{removedblock}
\pnum
\emph{Postconditions:} %% should be postconditions can no longer user \postconditions
If \tcode{mode \& ios_base::out} is nonzero, \tcode{pbase()} points to the
first underlying character and \tcode{epptr()} \tcode{>= pbase() + s.size()} holds; in
addition, if \tcode{mode \& ios_base::ate} is nonzero,
\tcode{pptr() == pbase() + s.size()}
holds, otherwise \tcode{pptr() == pbase()} is \tcode{true}. If \tcode{mode \& ios_base::in} is
nonzero, \tcode{eback()} points to the first underlying character, and both \tcode{gptr()
== eback()} and \tcode{egptr() == eback() + s.size()} hold.
\end{removedblock}
\end{itemdescr}



%% istream
\section{30.8.3 Adjust synopsis of basic\_istringstream [istringstream]}

\begin{em}
Change each of the non-move, non-deleted constructors to add a const-ref \tcode{Allocator} parameter as last parameter with a default constructed \tcode{Allocator} as default argument. Allow a string with a different allocator type here as well. Use delegating constructors to only make the single parameter versions explicit.
\end{em}

Add new constructor overloads and change the one taking the string by copy to allow a different allocator for the copied from string. provide delegating constructors according to p1163 suggestion:
\begin{codeblock}
    // \iref{istringstream.cons}, constructors:
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_istringstream() : basic_istringstream(ios_base::in){}
\end{codeblock}\end{addedblock}
\begin{codeblock}
    explicit basic_istringstream(
      ios_base::openmode which @\removed{= ios_base::in}@)
      @\added{ : basic_istringstream(which, Allocator()) \{\}}\removed{;}@
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_istringstream(
      ios_base::openmode which ,
      const Allocator& a);
\end{codeblock}\end{addedblock}
\begin{addedblock}\begin{codeblock}
\end{codeblock}\end{addedblock}
\begin{codeblock}      
    @\added{template <class SAlloc>}@
    explicit basic_istringstream(
      const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s@\removed{,}@
      @\removed{ios_base::openmode which = ios_base::in}@)
      @\added{: basic_istringstream(s, ios_base::in)\{\}}\removed{;}@
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    template <class SAlloc>
    basic_istringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which ,
      const Allocator& a = Allocator());

    explicit basic_istringstream(
      basic_string<charT, traits, Allocator>&& s)
      : basic_istringstream(std::move(s), ios_base::in) {}
    basic_istringstream(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which,
      const Allocator& a = Allocator());

    explicit basic_istringstream(const Allocator& a)
      : basic_istringstream(ios_base::in, a) {}

    template <class SAlloc>
    basic_istringstream(
      const basic_string<charT, traits, SAlloc>& s,
      const Allocator& a)
      : basic_istringstream(s, ios_base::in, a) {}

    basic_istringstream(
      basic_string<charT, traits, Allocator>&& s,
      const Allocator& a)
      : basic_istringstream(std::move(s), ios_base::in, a) {}
\end{codeblock}\end{addedblock}

\begin{codeblock}
    basic_istringstream(const basic_istringstream& rhs) = delete;
    basic_istringstream(basic_istringstream&& rhs);
\end{codeblock}

Change the getting \tcode{str()} overload to take an Allocator for the returned string and add a reference qualification. Add an rvalue-ref overload of \tcode{str()}.
Change the \tcode{str(s)} overload to take an allocator template parameter that could differ from the buffer's own \tcode{Allocator}. 
Add a \tcode{str(s)} overload that moves from its string and a \tcode{view()} member function:

\begin{codeblock}
    // \iref{istringstream.members}, members:
    basic_stringbuf<charT, traits, Allocator>* rdbuf() const;

    @\added{template<class SAlloc = Allocator>}@
    basic_string<charT,traits,@\removed{Allocator}\added{SAlloc}@> str(@\added{const SAlloc\& sa=SAlloc()}@) const @\added{\&}@;
    @\added{template<class SAlloc = Allocator>}@
    void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    void str(basic_string<charT, traits, Allocator>&& s);
    basic_string<charT,traits,Allocator> str() &&;
    basic_string_view<charT, traits> view() const;
\end{codeblock}
\end{addedblock}

\subsection{30.8.3.1 basic\_istringstream constructors [istringstream.cons]}
\begin{em}
Adjust the constructor specifications taking the additional Allocator parameter and adjust the delegation to basic_stringbuf constructors in the Effects clauses in p1 and p2 to pass on the given allocator object.
Take into account that explicit is only put in single-parameter constructors.
\end{em}

\begin{itemdecl}
@\removed{explicit }@basic_istringstream(
  ios_base::openmode which@\removed{ = ios_base::in}\added{,}@
  @\added{const Allocator\& a}@);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_istringstream<charT, traits\added{, Allocator}>},
initializing the base class with
\tcode{basic_istream(\&sb)}
and initializing \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Alloca\-tor>(which | ios_base::in\added{, a}))}~(\iref{stringbuf.cons}).
\end{itemdescr}

Change the constructor specification to allow a string copy with a different allocator and take into account the delegating constructors.
\begin{itemdecl}
@\added{template<class SAlloc>}@
@\removed{explicit }@basic_istringstream(
  const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s,
  ios_base::openmode which@\removed{ = ios_base::in}\added{,}@
  @\added{const Allocator\& a = Allocator()}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_istringstream<charT, traits\added{, Allocator}>},
initializing the base class with
\tcode{basic_istream(\&sb)}
and initializing \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Alloca\-tor>(s, which | ios_base::in)\added{, a})}~(\iref{stringbuf.cons}).
\end{itemdescr}


Add the following constructor specification:

\begin{addedblock}
\begin{itemdecl}
basic_istringstream(
  basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which,
  const Allocator& a = Allocator());
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{basic_istringstream<charT, traits, Allocator>}, initializing the base class with \tcode{basic_istream(\&sb)} and initializing \tcode{sb} with \tcode{basic_stringbuf<charT, traits, Allocator>(std::move(s), which | ios_base::in), a)}~(\iref{stringbuf.cons}).
\end{itemdescr}
\end{addedblock}

\subsection{30.8.3.3 Member functions [istringstream.members]}
Add the allocator parameter to the following \tcode{str()} overloads:
\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
basic_string<charT,traits,@\added{S}@Alloc@\removed{ator}@> str(@\added{const SAlloc\& sa = SAlloc()}@) const @\added{\&}@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str(\added{sa})}.

\begin{addedblock}
\pnum % taken from container.requirements.general p.17
\constraints 
This function does not participate in overload resolution, unless \tcode{SAlloc} satisfies both of the following conditions: 

\begin{itemize}
\item The \grammarterm{qualified-id} \tcode{SAlloc::value_type}
is valid and denotes a type\iref{temp.deduct}.

\item The expression \tcode{declval<SAlloc\&>().allocate(size_t\{\})}
is well-formed when treated as an unevaluated operand.
\end{itemize}
\end{addedblock}

\end{itemdescr}

\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->str(s)}.
\end{itemdescr}


Add the following specifications:

\begin{addedblock}
\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects \tcode{rdbuf()->str(std::move(s))}.
\end{itemdescr}
\begin{itemdecl}
basic_string<charT,traits,Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns \tcode{std::move(*rdbuf()).str()}.

\pnum
\begin{note}
Calling this member function leaves the stream object in a usable state with an emptied underlying \tcode{basic_stringbuf}.
\end{note}
\end{itemdescr}
\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns \tcode{rdbuf()->view()}.
\end{itemdescr}
\end{addedblock}

%%ostream

\section{30.8.4 Adjust synopsis of basic\_ostringstream [ostringstream]}
\begin{em}
Change each of the non-move, non-deleted constructors to add a const-ref \tcode{Allocator} parameter as last parameter with a default constructed \tcode{Allocator} as default argument. Allow a string with a different allocator type here as well. Use delegating constructors to only make the single parameter versions explicit.
\end{em}

Add a new constructor overload and change the one taking the string by copy to allow a different allocator for the copied from string:
\begin{codeblock}
    // \iref{ostringstream.cons}, constructors:
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_ostringstream() : basic_ostringstream(ios_base::out){}
\end{codeblock}\end{addedblock}
\begin{codeblock}
    explicit basic_ostringstream(
      ios_base::openmode which @\removed{= ios_base::out}@)
      @\added{ : basic_ostringstream(which, Allocator()) \{\}}\removed{;}@
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_ostringstream(
      ios_base::openmode which ,
      const Allocator& a);
\end{codeblock}\end{addedblock}
\begin{addedblock}\begin{codeblock}
\end{codeblock}\end{addedblock}
\begin{codeblock}      
    @\added{template <class SAlloc>}@
    explicit basic_ostringstream(
      const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s@\removed{,}@
      @\removed{ios_base::openmode which = ios_base::out}@)
      @\added{: basic_ostringstream(s, ios_base::out)\{\}}\removed{;}@
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    template <class SAlloc>
    basic_ostringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which ,
      const Allocator& a = Allocator());

    explicit basic_ostringstream(
      basic_string<charT, traits, Allocator>&& s)
      : basic_ostringstream(std::move(s), ios_base::out) {}
    basic_ostringstream(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which,
      const Allocator& a = Allocator());

    explicit basic_ostringstream(const Allocator& a)
      : basic_ostringstream(ios_base::out, a) {}

    template <class SAlloc>
    basic_ostringstream(
      const basic_string<charT, traits, SAlloc>& s,
      const Allocator& a)
      : basic_ostringstream(s, ios_base::out, a) {}

    basic_ostringstream(
      basic_string<charT, traits, Allocator>&& s,
      const Allocator& a)
      : basic_ostringstream(std::move(s), ios_base::out, a) {}
\end{codeblock}\end{addedblock}

%% p0407 need overloads
%    explicit basic_ostringstream(
%      basic_string<charT, traits, Allocator>&& s,
%      ios_base::openmode which = ios_base::out,
%      const Allocator& a = Allocator());
%    explicit basic_ostringstream(
%      basic_string<charT, traits, Allocator>&& s,
%      const Allocator& a)
%      :basic_ostringstream(std::move(s), ios_base::out, a) {}
\begin{codeblock}
    basic_ostringstream(const basic_ostringstream& rhs) = delete;
    basic_ostringstream(basic_ostringstream&& rhs);
\end{codeblock}

Change the getting \tcode{str()} overload to take an Allocator for the returned string and add a reference qualification. Add an rvalue-ref overload of \tcode{str()}.
Change the \tcode{str(s)} overload to take an allocator template parameter that could differ from the buffer's own \tcode{Allocator}. 
Add a \tcode{str(s)} overload that moves from its string and a \tcode{view()} member function:

\begin{codeblock}
    // \iref{ostringstream.members}, members:
    basic_stringbuf<charT, traits, Allocator>* rdbuf() const;

    @\added{template<class SAlloc = Allocator>}@
    basic_string<charT,traits,@\removed{Allocator}\added{SAlloc}@> str(@\added{const SAlloc\& sa = SAlloc()}@) const @\added{\&}@;
    @\added{template<class SAlloc = Allocator>}@
    void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    void str(basic_string<charT, traits, Allocator>&& s);
    basic_string<charT, traits, Allocator> str() &&;
    basic_string_view<charT, traits> view() const;
\end{codeblock}
\end{addedblock}

\subsection{30.8.4.1 basic\_ostringstream constructors [ostringstream.cons]}
\begin{em}
Adjust the constructor specifications taking the additional Allocator parameter and adjust the delegation to basic_stringbuf constructors in the Effects clauses in p1 and p2 to pass on the given allocator object.
Take into account that explicit is only put in single-parameter constructors.
\end{em}

\begin{itemdecl}
@\removed{explicit }@basic_ostringstream(
  ios_base::openmode which@\removed{ = ios_base::out | ios_base::in}\added{,}@
  @\added{const Allocator\& a}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_ostringstream<charT, traits\added{, Allocator}>},
initializing the base class with
\tcode{basic_iostream(\&sb)}
and initializing
\tcode{sb}
with
\tcode{basic_stringbuf<charT, traits, Alloca\-tor>(which | ios_base::out\added{, a})} ~(\iref{stringbuf.cons}).
\end{itemdescr}


Change the constructor specification to allow a string copy with a different allocator.
\begin{itemdecl}
@\added{template<class SAlloc>}@
@\removed{explicit }@basic_ostringstream(
  const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s,
  ios_base::openmode which@\removed{ = ios_base::out}\added{,}@
  @\added{const Allocator\& a = Allocator()}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_ostringstream<charT, traits\added{, Allocator}>},
initializing the base class with
\tcode{basic_ostream(\&sb)}
and initializing \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Alloca\-tor>(s, which | ios_base::out\added{, a})}~(\iref{stringbuf.cons}).
\end{itemdescr}

Add the following constructor specification:
\begin{insrt}
\begin{itemdecl}
basic_ostringstream(
  const basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which,
  const Allocator& a = Allocator());
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{basic_ostringstream<charT, traits, Allocator>}, initializing the base class with \tcode{basic_ostream(\&sb)} and initializing \tcode{sb} with \tcode{basic_stringbuf<charT, traits, Allocator>(std::move(s), which | ios_base::out, a)}~(\iref{stringbuf.cons}).
\end{itemdescr}
\end{insrt}

\subsection{30.8.4.3 Member functions [ostringstream.members]}
Add the allocator parameter to the following str() overloads:
\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
basic_string<charT,traits,@\added{S}@Alloc@\removed{ator}@> str(@\added{const SAlloc\& sa = SAlloc()}@) const @\added{\&}@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str(\added{sa})}.

\begin{addedblock}
\pnum % taken from container.requirements.general p.17
\constraints 
This function does not participate in overload resolution, unless \tcode{SAlloc} satisfies both of the following conditions: 

\begin{itemize}
\item The \grammarterm{qualified-id} \tcode{SAlloc::value_type}
is valid and denotes a type\iref{temp.deduct}.

\item The expression \tcode{declval<SAlloc\&>().allocate(size_t\{\})}
is well-formed when treated as an unevaluated operand.
\end{itemize}
\end{addedblock}


\end{itemdescr}

\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->str(s)}.
\end{itemdescr}


Add the following specifications:

\begin{addedblock}
\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects \tcode{rdbuf()->str(std::move(s))}.
\end{itemdescr}
\begin{itemdecl}
basic_string<charT,traits,Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns \tcode{std::move(*rdbuf()).str()}.

\pnum
\begin{note}
Calling this member function leaves the stream object in a usable state with an emptied underlying \tcode{basic_stringbuf}.
\end{note}
\end{itemdescr}
\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns \tcode{rdbuf()->view()}.
\end{itemdescr}
\end{addedblock}


%%stringstream
\section{30.8.5 Adjust synopsis of basic\_stringstream [stringstream]}
\begin{em}
Change each of the non-move, non-deleted constructors to add a const-ref \tcode{Allocator} parameter as last parameter with a default constructed \tcode{Allocator} as default argument. Allow a string with a different allocator type here as well. Use delegating constructors to only make the single parameter versions explicit.
\end{em}

Add a new constructor overload and change the one taking the string by copy to allow a different allocator for the copied from string:
\begin{codeblock}
    // \iref{stringstream.cons}, constructors:
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_stringstream() : basic_stringstream(ios_base::out | ios_base::in){}
\end{codeblock}\end{addedblock}
\begin{codeblock}
    explicit basic_stringstream(
      ios_base::openmode which @\removed{= ios_base::out | ios_base::in}@)
      @\added{ : basic_stringstream(which, Allocator()) \{\}}\removed{;}@
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_stringstream(
      ios_base::openmode which ,
      const Allocator& a);
\end{codeblock}\end{addedblock}
\begin{addedblock}\begin{codeblock}
\end{codeblock}\end{addedblock}
\begin{codeblock}      
    @\added{template <class SAlloc>}@
    explicit basic_stringstream(
      const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s@\removed{,}@
      @\removed{ios_base::openmode which = ios_base::out | ios_base::in}@)
      @\added{: basic_stringstream(s, ios_base::out | ios_base::in)\{\}}\removed{;}@
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    template <class SAlloc>
    basic_stringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which ,
      const Allocator& a = Allocator());

    explicit basic_stringstream(
      basic_string<charT, traits, Allocator>&& s)
      : basic_stringstream(std::move(s), ios_base::out | ios_base::in) {}
    basic_stringstream(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which,
      const Allocator& a = Allocator());

    explicit basic_stringstream(const Allocator& a)
      : basic_stringstream(ios_base::out | ios_base::in, a) {}

    template <class SAlloc>
    basic_stringstream(
      const basic_string<charT, traits, SAlloc>& s,
      const Allocator& a)
      : basic_stringstream(s, ios_base::out | ios_base::in, a) {}

    basic_stringstream(
      basic_string<charT, traits, Allocator>&& s,
      const Allocator& a)
      : basic_stringstream(std::move(s), ios_base::out | ios_base::in, a) {}
\end{codeblock}\end{addedblock}

\begin{codeblock}
    basic_stringstream(const basic_stringstream& rhs) = delete;
    basic_stringstream(basic_stringstream&& rhs);
\end{codeblock}

Change the getting \tcode{str()} overload to take an Allocator for the returned string and add a reference qualification. Add an rvalue-ref overload of \tcode{str()}.
Change the \tcode{str(s)} overload to take an allocator template parameter that could differ from the buffer's own \tcode{Allocator}. 
Add a \tcode{str(s)} overload that moves from its string and a \tcode{view()} member function:

\begin{codeblock}
    // \iref{stringstream.members}, members:
    basic_stringbuf<charT, traits, Allocator>* rdbuf() const;

    @\added{template<class SAlloc=Allocator>}@
    basic_string<charT,traits,@\removed{Allocator}\added{SAlloc}@> s(@\added{const SAlloc\& sa = SAlloc()}@) const @\added{\&}@;
    @\added{template<class SAlloc = Allocator>}@
    void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    void str(basic_string<charT, traits, Allocator>&& s);
    basic_string<charT, traits, Allocator> str() &&;
    basic_string_view<charT, traits> view() const;
\end{codeblock}
\end{addedblock}

\subsection{30.8.4.1 basic\_stringstream constructors [stringstream.cons]}
\begin{em}
Adjust the constructor specifications taking the additional Allocator parameter and adjust the delegation to basic_stringbuf constructors in the Effects clauses in p1 and p2 to pass on the given allocator object.
Take into account that explicit is only put in single-parameter constructors.
\end{em}

\begin{itemdecl}
@\removed{explicit }@basic_stringstream(
  ios_base::openmode which@\removed{ = ios_base::out | ios_base::in}\added{,}@
  @\added{const Allocator\& a = Allocator()}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_stringstream<charT, traits\added{, Allocator}>},
initializing the base class with
\tcode{basic_iostream(\&sb)}
and initializing
\tcode{sb}
with
\tcode{basic_stringbuf<charT, traits, Alloca\-tor>(which\added{, a})}.
\end{itemdescr}

Change the constructor specification to allow a string copy with a different allocator.
\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
@\removed{explicit }@basic_stringstream(
  const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s,
  ios_base::openmode which@\removed{ = ios_base::out | ios_base::in}\added{,}@
  @\added{const Allocator\& a = Allocator()}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_stringstream<charT, traits\added{, Allocator}>},
initializing the base class with
\tcode{basic_iostream(\&sb)}
and initializing
\tcode{sb}
with
\tcode{basic_stringbuf<charT, traits, Alloca\-tor>(s, which\added{, a})}~(\iref{stringbuf.cons}).
\end{itemdescr}

Add the following constructor specification:
\begin{insrt}
\begin{itemdecl}
basic_stringstream(
  const basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which, 
  const Allocator& a = Allocator());
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{basic_stringstream<charT, traits, Allocator>}, initializing the base class with \tcode{basic_stream(\&sb)} and initializing \tcode{sb} with \tcode{basic_stringbuf<charT, traits, Allocator>(std::move(s), which, a))}~(\iref{stringbuf.cons}).
\end{itemdescr}
\end{insrt}

\subsection{30.8.4.3 Member functions [stringstream.members]}
Add the allocator parameter to the following str() overloads:
\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
basic_string<charT,traits,@\added{S}@Alloc@\removed{ator}@> str(@\added{const SAlloc\& sa = SAlloc()}@) const @\added{\&}@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->str(\added{sa})}.

\begin{addedblock}
\pnum % taken from container.requirements.general p.17
\constraints 
This function does not participate in overload resolution, unless \tcode{SAlloc} satisfies both of the following conditions: 

\begin{itemize}
\item The \grammarterm{qualified-id} \tcode{SAlloc::value_type}
is valid and denotes a type\iref{temp.deduct}.

\item The expression \tcode{declval<SAlloc\&>().allocate(size_t\{\})}
is well-formed when treated as an unevaluated operand.
\end{itemize}
\end{addedblock}
\end{itemdescr}

\begin{itemdecl}
@\added{template<class SAlloc = Allocator>}@
void str(const basic_string<charT, traits, @\added{S}@Alloc@\removed{ator}@>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->str(s)}.
\end{itemdescr}


Add the following specifications:

\begin{addedblock}
\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects \tcode{rdbuf()->str(std::move(s))}.
\end{itemdescr}
\begin{itemdecl}
basic_string<charT,traits,Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns \tcode{std::move(*rdbuf()).str()}.

\pnum
\begin{note}
Calling this member function leaves the stream object in a usable state with an emptied underlying \tcode{basic_stringbuf}.
\end{note}
\end{itemdescr}
\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns \tcode{rdbuf()->view()}.
\end{itemdescr}
\end{addedblock}

\chapter{Appendix: Example Implementations}

The given specification has been implemented within a recent version of the sstream header of gcc8. Modified version of the headers and some tests are available at
\url{https://github.com/PeterSommerlad/SC22WG21_Papers/tree/master/workspace/Test_basic_stringbuf_efficient/src}.

A corresponding implementation for clang 7 is available in the vicinity of the one above at:
\url{https://github.com/PeterSommerlad/SC22WG21_Papers/tree/master/workspace/Test_clang_p0407_p0408}
\end{document}

