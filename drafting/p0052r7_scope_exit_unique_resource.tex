\documentclass[ebook,11pt,article]{memoir}
\usepackage{geometry}  % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}  % ... or a4paper or a5paper or ... 
%\geometry{landscape}  % Activate for for rotated page geometry

\pagestyle{myheadings}
%%% from std.tex
%\usepackage[american]
%           {babel}        % needed for iso dates
%\usepackage[iso,american]
%           {isodate}      % use iso format for dates
\usepackage[final]
           {listings}     % code listings
%\usepackage{longtable}    % auto-breaking tables
%\usepackage{ltcaption}    % fix captions for long tables
\usepackage{relsize}      % provide relative font size changes
%\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{underscore}   % remove special status of '_' in ordinary text
%\usepackage{parskip}      % handle non-indented paragraphs "properly"
%\usepackage{array}        % new column definitions for tables
\usepackage[normalem]{ulem}
\usepackage{enumitem}
\usepackage{color}        % define colors for strikeouts and underlines
%\usepackage{amsmath}      % additional math symbols
%\usepackage{mathrsfs}     % mathscr font
\usepackage[final]{microtype}
%\usepackage{multicol}
\usepackage{xspace}
%\usepackage{lmodern}
\usepackage[T1]{fontenc} % makes tilde work! and is better for umlauts etc.
%\usepackage[pdftex, final]{graphicx}
\usepackage[pdftex,
%            pdftitle={C++ International Standard},
%            pdfsubject={C++ International Standard},
%            pdfcreator={Richard Smith},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}
%\usepackage{memhfixc}     % fix interactions between hyperref and memoir
%\usepackage[active,header=false,handles=false,copydocumentclass=false,generate=std-gram.ext,extract-cmdline={gramSec},extract-env={bnftab,simplebnf,bnf,bnfkeywordtab}]{extract} % Grammar extraction
%
\renewcommand\RSsmallest{5.5pt}  % smallest font size for relsize


%%%% reuse all three from std.tex:
\input{macros}
\input{layout}
\input{styles}

%%%%

\newcommand{\papernumber}{p0052r7}
\newcommand{\paperdate}{2018-03-16}

\markboth{\papernumber{} \paperdate{}}{\papernumber{} \paperdate{}}

\title{\papernumber{} - Generic Scope Guard and RAII Wrapper for the Standard Library}
\author{Peter Sommerlad and Andrew L. Sandoval\\with contributions by Eric Niebler and Daniel Kr\"ugler}
\date{\paperdate}                        % Activate to display a given date or no date
\setsecnumdepth{subsection}

\begin{document}
\maketitle
\begin{tabular}[t]{|l|l|}\hline 
Document Number: \papernumber &   (update of N4189, N3949, N3830, N3677)\\\hline
Date: & \paperdate \\\hline
Project: & Programming Language C++\\\hline 
Audience: & LWG\\\hline
\end{tabular}

\chapter{History}
\section{Changes from P0052R6}
While no semantic changes, review by LWG and several other people, most notably Tim Song, suggested many improvements to the wording.
\begin{itemize}
\item remove the phrasing for potentially targeting a TS and minor editorial fixes, i.e., moving the Remarks sections towards the end of a description.
\item rephrased general requirement to the constructor parameter f for the scope guard classes' constructors according to Tim Song's suggestions. [scope.scope_guard] p4. Do not require \tcode{f()} be valid for \tcode{scope_success}, because it will never be called directly.
\item added \tcode{|| is_nothrow_constructible_v<EF,EFP\&>} to the noexcept constructor condition for scope guards to match the actual behavior (Tim Song).
\item require \tcode{is_constructible_v<X,XX>} for \tcode{<EF, EFP>}, and \tcode{<R1,RR>} and \tcode{<D,DD>} in the constructors of the classes to avoid initializing a reference from a then dangling rvalue-reference, even if the actual initialization is done differently (Tim Song). 
\item spell out in detail what \tcode{scope_guard(scope_guard\&\&)} is doing. (Tim Song)
\item added a requirement on type \tcode{EF} to be \lstinline{MoveConstructible} or \tcode{CopyConstructible} for \tcode{\textit{scope_guard}}'s move constructors if \tcode{EF} is an object type.(Tim Song's suggestion)
\item Fixed the missing \tcode{remove_reference_t<>} around \tcode{R} when defining \tcode{R1} to be a \tcode{reference_wrapper} (Tim Song).
\item rephrased p3 in [scope.unique_resource.class] according to Alisdair Meredith's suggestion.
\item corrected code in specification of \tcode{unique_resource} move assignment operator to use \tcode{R1} instead of R, since R1 is the type of the member \tcode{resource}, and replace \tcode{std::forward()} with \tcode{std::move()} and to rely only on \tcode{std::is_nothrow_move_assignable_v} in noexcept specification explanation and \tcode{if constexpr} condition.
\item simplified and corrected overload restriction in constructor of unique_resource by getting rid of the exposition only variable template,  according to Tim Song's feedback.
\item add "calls" to deleter() in reset()
\item added requirement to \tcode{unique_resource} constructor to clarify that calling \tcode{d()} is always possible and fixed effects to unwrap \tcode{resource}, if it is stored in a \tcode{reference_wrapper} (thanks Tim Song).
\item change the requirements of \tcode{unique_resource::operator=} to use \tcode{MoveAssignable}/\tcode{CopyAssignable} instead of the traits.
\item changed \tcode{std::forward<D>(rhs.deleter)} to \tcode{std::move(rhs.deleter)} in the effects of the move-constructor of \tcode{unique_resource}, because \tcode{D} can not be a reference type. (thanks Tim Song). Can not do that for \tcode{resource}, because the member variable might be a \tcode{reference_wrapper}.
\item simplify \tcode{get()} because \tcode{reference_wrapper} auto-converts to const reference.
\item adjust title of [scope.make_unique_resource]
\item added requires clause to \tcode{unique_resource::reset(RR)} to allow for running the deleter on the function argument in case of an exception (thanks Tim Song).
\item default argument for template parameter \tcode{S} in \tcode{make_unique_resource_checked} is now \tcode{decay_t<R>} (thanks Tim Song).
\item comparison in \tcode{make_unique_resource_checked} is now required to not throw an exception.
\item In Jacksonville LWG was discussion the need for \tcode{decay_t<R>} in \tcode{make_unique_resource_checked} and asked for an lvalue version of a call in the example. That is not what it should be used for anyway. I made some experiments and made the decision that was already previously made (if I remember correctly) to only support copying of the resource in that factory function. Therefore, \tcode{decay_t} is IMHO the right thing to do. and therefore I also did not add an example using an lvalue for its first argument.
\item Tim Song recognized that the remarks and requires clauses of the scope guard constructors are written like they would be always perfect forwarding, which they are not (when move construction could fail they copy). I do not know if and what to do about it. 
\end{itemize}

\section{Changes from P0052R5}
Wording reviewed and recommended on by LWG
\begin{itemize}
\item added noexcept specification for move assignment.
\item feature test macro added \tcode{__cpp_lib_scope}
\item drop \tcode{unique_resource} deduction guide that unwraps reference_wrapper
\item add a non-normative note to explain potential scope guard misuse if capturing local by reference that is returned. BSI raised this issue, but does not intend to ask this paper to solve that corner case.
\item the code in the special factory function's effects was broken, but can be fixed in an implementation. Changed the specification into words, so that implementers can do the right thing. Note, previous versions of the paper had a specification with an extra bool constructor parameter to unique_resource achieving that mechanism.
\item fixed some minor editorial things and forgotten changes
\item separated definitions of \tcode{unique_resource} member functions returning the resource.
\item simplified specification of \tcode{reset} using \tcode{if constexpr} according to Jonathan Wakely without inventing an exposition only function. (this must be re-checked)
\item more fancy attempt to specify the need for implementations to internally use \tcode{reference_wrapper} in \tcode{unique_resource} if the resource type is a reference (to support assignment) by specifying a separate type in the \tcode{unique_resource} synopsis for resource and clarifying the note saying to use reference_wrapper.
\item removed remains of \tcode{swap()} that got not deleted.
\item simplified \tcode{unique_resource} specification as suggested by Stephan T. Lavavej
\end{itemize}

\section{Changes from P0052R4}
Wording reviewed and recommended on by LWG
\begin{itemize}
\item Add missing deduction guides
\item Call expressions are OK.
\item No consensus to re-add the implicit conversion operator to unique_resource
\item clarification of wording in many places
\end{itemize}

\section{Changes from P0052R3}
\begin{itemize}
\item Take new section numbering of the standard working paper into account.
\item require noexcept of \tcode{f()} for \tcode{scope_exit} and \tcode{scope_fail} explicitly
\item implementation could be tested with C++17 compiler and class template constructor argument deduction thus the paper no longer claims help or not being sure.
\end{itemize}


\section{Changes from P0052R2}
\begin{itemize}
\item Take into account class template ctor argument deduction. However, I recommend keeping the factories for LFTS 3 to allow for C++14 implementations. At the time of this writing, I do not have a working C++17 compliant compiler handy to run corresponding test cases without the factories. However, there is one factory function make_unique_checked that needs to stay, because it addresses a specific but seemingly common use-case.
\item Since \tcode{scope_success} is a standard library class that has a possible throwing destructor section [res.on.exception.handling] must be adjusted accordingly.
\item The lack of factories for the classes might require explicit deduction guides, but I need help to specify those accordingly since I do not have a working C++17 compiler right at hand to test it.
\end{itemize}


\section{Changes from P0052R1}
The Jacksonville LEWG, especially Eric Niebler gave splendid input in how to improve the classes in this paper. I (Peter) follow Eric's design in specifying scope_exit as well as unique_resource in a more general way.
\begin{itemize}
\item Provide \tcode{scope_fail} and \tcode{scope_success} as classes. However, we may even hide all of the scope guard types and just provide the factories.
\item safe guard all classes against construction errors, i.e., failing to copy the deleter/exit-function, by calling the passed argument in the case of an exception, except for scope_success.
\item relax the requirements for the template arguments.
\end{itemize}
Special thanks go to Eric Niebler for providing several incarnations of an implementation that removed previous restrictions on template arguments in an exception-safe way (Eric: \textit{"This is HARD."}). To cite Eric again: \textit{"Great care must be taken when move-constructing or
move-assigning unique_resource objects to ensure that there is always
exactly one object that owns the resource and is in a valid,
Destructible state."}
Also thanks to Axel Naumann for presenting in Jacksonville and to Axel, Eric, and Daniel Kr\"ugler for their terrific work on wording improvements.

\section{Changes from P0052R0}
In Kona LWG gave a lot of feedback and especially expressed the desire to simplify the constructors and specification by only allowing \emph{nothrow-copyable} \tcode{RESOURCE} and \tcode{DELETER} types. If a reference is required, because they aren't, users are encouraged to pass a \tcode{std::ref/std::cref} wrapper to the factory function instead.
\begin{itemize}
\item Simplified constructor specifications by restricting on nothrow copyable types. Facility is intended for simple types anyway. It also avoids the problem of using a type-erased \tcode{std::function} object as the deleter, because it could throw on copy.
\item Add some motivation again, to ease review and provide reason for specific API issues.
\item Make "Alexandrescu's" "declarative" scope exit variation employing \tcode{uncaught_exceptions()} counter optional factories to chose or not.
\item propose to make it available for standalone implementations and add the header \tcode{<scope>} to corresponding tables.
\item editorial adjustments
\item re-established \tcode{operator*} for \tcode{unique_resource}.
\item overload of \tcode{make_unique_resource} to handle \tcode{reference_wrapper} for resources. No overload for reference-wrapped deleter functions is required, because \tcode{reference_wrapper} provides the call forwarding.
\end{itemize}
\section{Changes from N4189}
\begin{itemize}
\item Attempt to address LWG specification issues from Cologne (only learned about those in the week before the deadline from Ville, so not all might be covered).
\begin{itemize}
\item specify that the exit function must be either no-throw copy-constructible, or no-throw move-constructible, or held by reference. Stole the wording and implementation from unique_ptr's deleter ctors.
\item put both classes in single header \tcode{<scope>}
\item specify factory functions for Alexandrescu's 3 scope exit cases for \tcode{scope_exit}. Deliberately did't provide similar things for \tcode{unique_resource}.
\end{itemize}
\item remove lengthy motivation and example code, to make paper easier digestible.
\item Corrections based on committee feedback in Urbana and Cologne.
\end{itemize}

%TODO AM: I want to see a proper synopsis with summary, and separate class definition.
%TODO DK: Have we discussed why make_scoped does remove_reference but not cv?
%TODO: single header or merge with <utility>
%DK: re make_scope_exit function: Wondering why there's remove_reference instead of decay. Means you can't construct scope_exit from a function, and means function object member may be cv-qualified, which can affect overload resolution. Is this designed?
%TODO AM: We rarely put the function definition in the class definition. Rampant use of unqualified noexcept when wrapping unknown type seems totally bogus. For make_scoped_exit, deduced return type doesn't play nicely with SFINAE and other such things. We discussed this in Urbana.
%TODO DK: Agree on the last point, but for unconditional noexcept, there's a documented requirement that move construction shall not throw an exception. So this seems to be by design.
%TODO noexcept - moving - non-throwing
% TODO Alexandrescu: UncaughtExceptionCount... ScopeGuardForNewExeption(slide photo!)
% github.com/facebook/folly
% github.com/panaseleus/stack_unwinding

\section{Changes from N3949}
\begin{itemize}
\item renamed \tcode{scope_guard} to \tcode{scope_exit} and the factory to \tcode{make_scope_exit}. Reason for make_ is to teach users to save the result in a local variable instead of just have a temporary that gets destroyed immediately. Similarly for unique resources, \tcode{unique_resource}, \tcode{make_unique_resource} and \tcode{make_unique_resource_checked}.
\item renamed editorially \tcode{scope_exit::deleter} to \tcode{scope_exit::exit_function}.
\item changed the factories to use forwarding for the \tcode{deleter}/\tcode{exit_function} but not deduce a reference.
\item get rid of \tcode{invoke}'s parameter and rename it to \tcode{reset()} and provide a \tcode{noexcept} specification for it.
\end{itemize}


\section{Changes from N3830}
\begin{itemize}
\item rename to \tcode{unique_resource_t} and factory to \tcode{unique_resource}, resp. \tcode{unique_resource_checked}
\item provide scope guard functionality through type \tcode{scope_guard_t} and \tcode{scope_guard} factory
\item remove multiple-argument case in favor of simpler interface, lambda can deal with complicated release APIs requiring multiple arguments.
\item make function/functor position the last argument of the factories for lambda-friendliness.

\end{itemize}

\section{Changes from N3677}
\begin{itemize}
\item Replace all 4 proposed classes with a single class covering all use cases, using variadic templates, as determined in the Fall 2013 LEWG meeting.
\item The conscious decision was made to name the factory functions without "make", because they actually do not allocate any resources, like \tcode{std::make_unique} or \tcode{std::make_shared} do
\end{itemize}

\chapter{Introduction}
The Standard Template Library provides RAII (resource acquisition is initialization) classes for managing pointer types, such as \tcode{std::unique_ptr} and \tcode{std::shared_ptr}.  This proposal seeks to add a two generic RAII wrappers classes which tie zero or one resource to a clean-up/completion routine which is bound by scope, ensuring execution at scope exit (as the object is destroyed) unless released early or in the case of a single resource: executed early or returned by moving its value.

\chapter{Acknowledgements}
\begin{itemize}
\item This proposal incorporates what Andrej Alexandrescu described as scope_guard long ago and explained again at C++ Now 2012 (%\url{
%https://onedrive.live.com/view.aspx?resid=F1B8FF18A2AEC5C5!1158&app=WordPdf&wdo=2&authkey=!APo6bfP5sJ8EmH4}
).
\item This proposal would not have been possible without the impressive work of Peter Sommerlad who produced the sample implementation during the Fall 2013 committee meetings in Chicago.  Peter took what Andrew Sandoval produced for N3677 and demonstrated the possibility of using C++14 features to make a single, general purpose RAII wrapper capable of fulfilling all of the needs presented by the original 4 classes (from N3677) with none of the compromises.
\item Gratitude is also owed to members of the LEWG participating in the Fall 2015(Kona),Fall 2014(Urbana), February 2014 (Issaquah) and Fall 2013 (Chicago) meeting for their support, encouragement, and suggestions that have led to this proposal.
\item Special thanks and recognition goes to OpenSpan, Inc. (http://www.openspan.com) for supporting the production of this proposal, and for sponsoring Andrew L. Sandoval's first proposal (N3677) and the trip to Chicago for the Fall 2013 LEWG meeting. \emph{Note: this version abandons the over-generic version from N3830 and comes back to two classes with one or no resource to be managed.}
\item Thanks also to members of the mailing lists who gave feedback. Especially Zhihao Yuan, and Ville Voutilainen.
\item Special thanks to Daniel Kr\"ugler for his deliberate review of the draft version of this paper (D3949).
\item Thanks to participants in LWG in Jacksonville, Toronto and Albuquerque, especially STL, Lisa Lippincott, Casey Carter, many others, and Marshall Clow for help with phrasing the wording.
\item Very special thanks to Tim Song for his elaborate feedback on the wording after Jacksonville and his willingness to go over it several times. Hopefully R7 of this paper will be close enough to make it into the standard.
\end{itemize}
\newpage
\chapter{Motivation}
While \tcode{std::unique_ptr} can be (mis-)used to keep track of general handle types with a user-specified deleter it can become tedious and error prone. Further argumentation can be found in previous papers. Here are two examples using  \tcode{<cstdio>}'s \tcode{FILE *} and POSIX\tcode{<fcntl.h>}'s and \tcode{<unistd.h>}'s \tcode{int} file handles. 

\begin{codeblock}
void demonstrate_unique_resource_with_stdio() {
  const std::string filename = "hello.txt";
  { auto file=make_unique_resource(::fopen(filename.c_str(),"w"),&::fclose);
    ::fputs("Hello World!\n", file.get());
    ASSERT(file.get()!= NULL);
  }
  { std::ifstream input { filename };
    std::string line { };
    getline(input, line);
    ASSERT_EQUAL("Hello World!", line);
    getline(input, line);
    ASSERT(input.eof());
  }
  ::unlink(filename.c_str());
  {
    auto file = make_unique_resource_checked(::fopen("nonexistingfile.txt", "r"), 
                (FILE*) NULL, &::fclose);
    ASSERT_EQUAL((FILE*)NULL, file.get());
  }
}
void demontrate_unique_resource_with_POSIX_IO() {
  const std::string filename = "./hello1.txt";
  { auto file=make_unique_resource(::open(filename.c_str(),
                     O_CREAT|O_RDWR|O_TRUNC,0666), &::close);
    ::write(file.get(), "Hello World!\n", 12u);
    ASSERT(file.get() != -1);
  }
  { std::ifstream input { filename };
    std::string line { };
    getline(input, line);
    ASSERT_EQUAL("Hello World!", line);
    getline(input, line);
    ASSERT(input.eof());
  }
  ::unlink(filename.c_str());
  {
    auto file = make_unique_resource_checked(::open("nonexistingfile.txt", 
                       O_RDONLY), -1, &::close);
    ASSERT_EQUAL(-1, file.get());
  }
}\end{codeblock}

We refer to Andrej Alexandrescu's well-known many presentations as a motivation for \tcode{scope_exit}, \tcode{scope_fail}, and \tcode{scope_success}. Here is a brief example on how to use the 3 proposed factories. 
\begin{codeblock}
void demo_scope_exit_fail_success(){
  std::ostringstream out{};
  auto lam=[&]{out << "called ";};
  try{
    auto v=make_scope_exit([&]{out << "always ";});
    auto w=make_scope_success([&]{out << "not ";}); // not called
    auto x=make_scope_fail(lam); // called
    throw 42;
  }catch(...){
    auto y=make_scope_fail([&]{out << "not ";}); // not called
    auto z=make_scope_success([&]{out << "handled";}); // called
  }
  ASSERT_EQUAL("called always handled",out.str());
}
\end{codeblock}


\chapter{Impact on the Standard}
This proposal is a pure library extension. A new header, \tcode{<scope>} is proposed, but it does not require changes to any standard classes or functions. Since it proposes a new header, no feature test macro seems required. It does not require any changes in the core language, and it has been implemented in standard C++ conforming to C++17. Depending on the timing of the acceptance of this proposal, it might go into a library fundamentals TS under the namespace std::experimental or directly in the working paper of the standard. I suggest both shipping vehicles.

\chapter{Design Decisions}
\section{General Principles}
The following general principles are formulated for \tcode{unique_resource}, and are valid for \tcode{scope_exit} correspondingly.
\begin{itemize}
\item Transparency - It should be obvious from a glance what each instance of a \tcode{unique_resource} object does.  By binding the resource to it's clean-up routine, the declaration of \tcode{unique_resource} makes its intention clear.
\item Resource Conservation and Lifetime Management - Using \tcode{unique_resource} makes it possible to "allocate it and forget about it" in the sense that deallocation is always accounted for after the \tcode{unique_resource} has been initialized.
\item Exception Safety - Exception unwinding is one of the primary reasons that \tcode{unique_resource} and \tcode{scope_exit}/\tcode{scope_fail} are needed. Therefore, the specification asks for strong safety guarantee when creating and moving the defined types, making sure to call the deleter/exit function if such attempts fail.
\item Flexibility - \tcode{unique_resource} is designed to be flexible, allowing the use of lambdas or existing functions for clean-up of resources. 
\end{itemize}

\section{Prior Implementations}
Please see N3677 from the May 2013 mailing (or http://www.andrewlsandoval.com/scope_exit/) for the previously proposed solution and implementation.  Discussion of N3677 in the (Chicago) Fall 2013 LEWG meeting led to the creation of \tcode{unique_resource} and \tcode{scope_exit} with the general agreement that such an implementation would be vastly superior to N3677 and would find favor with the LEWG.  Professor Sommerlad produced the implementation backing this proposal during the days following that discussion.

N3677 has a more complete list of other prior implementations.

N3830 provided an alternative approach to allow an arbitrary number of resources which was abandoned due to LEWG feedback 

The following issues have been discussed by LEWG already:
\begin{itemize}
\item \textit{Should there be a companion class for sharing the resource \tcode{shared_resource} ?  (Peter thinks no. Ville thinks it could be provided later anyway.) } LEWG: NO.
\item \textit{Should \tcode{~scope_exit()} and \tcode{unique_resource::invoke()} guard against deleter functions that throw with \tcode{try{ deleter(); }catch(...){}} (as now) or not?} LEWG: NO, but provide noexcept in detail.
\item \textit{Does \tcode{scope_exit} need to be move-assignable? } LEWG: NO.
\item Should we make the regular constructor of the scope guard templates private and friend the factory function only? This could prohibit the use as class members, which might sneakily be used to create "destructor" functionality by not writing a destructor by adding a \tcode{scope_exit} member variable.
\\
\emph{It seems C++17's class template constructor argument deduction makes the need for most of the factory functions obsolete and thus this question is no longer relevant. However, I recommend keeping the factories for the LFTS-3 if accepted to allow backporting to C++14.}
\item Should the scope guard classes be move-assignable? Doing so, would enable/ease using them as class members. I do not think this use is good, but may be someone can come up with a use case for that. 
\\
\emph{LEWG already answered that once with NO, but you never know if people change their mind again.}
\end{itemize}

The following issues have been recommended by LWG already:
\begin{itemize}
\item Make it a facility available for free-standing implementations in a new header \tcode{<scope>} (\tcode{<utility>} doesn't work, because it is not available for free-standing implementations)
\end{itemize}

\newpage
\section{Open Issues (to be) Discussed by LEWG / LWG}
The following issues have been resolved finally by LWG in Toronto. The shipping vehicle should be C++20, however, I would not object to put it into version 3 of the Library Fundamentals TS if there remains a chance to have it put into C++20.
\begin{itemize}
\item \removed{which "callable" definition in the standard should be applied (call expression (as it is now) or via INVOKE (\tcode{is_callable_v<EF\&>}).
IMHO call expression is fine, since everything is about side-effects 
and we never return a useful value from any of the function objects.}
\item \removed{Should we provide a non-explicit conversion operator to \tcode{R} in \tcode{unique_resource<R,D>} ? Last time people seem to have been strongly against, however, it would make the use of unique_resource much easier in contexts envisioned by author Andrew Sandoval. Please re-visit, since it is omitted here.}
\end{itemize}

\newpage
\chapter{Technical Specifications}
The following formulation is based on inclusion to the draft of the C++ standard. 

A draft of the standard already has the requested change below that was suggested by Daniel Kr\"ugler:

\section{Adjust 20.5.4.8 Other functions [res.on.functions]}
Since \tcode{~scope_success()} might throw an exception and we can not specify that in a required behavior clause, we need to allow doing so for the standard library's normative remarks section as well.

In section 20.5.4.8 Other functions [res.on.functions] modify p2 item (2.4) as follows by adding "or \remarks"

\begin{description}
\item[\textit{(2.4)} ---]
if any replacement function or handler function or destructor operation exits via an exception,
unless specifically allowed
in the applicable
\required \added{or \remarks}
paragraph.
\end{description}

However the following adjustment is missing, since the standard library promises that all library classes won't throw on destruction:

\section{Adjust 20.5.5.12 Restrictions on exception handling [res.on.exception.handling]}

Change paragraph 3 as follows:

\pnum
\added{Unless otherwise specified, 
d}\removed{D}estructor operations defined in the \Cpp standard library
shall not throw exceptions.
Every destructor\added{ without an exception specification} in the \Cpp standard library shall behave as if it had a
non-throwing exception specification.




\section{Header}
In section 20.5.1.1 Library contents [contents] add an entry to table 16 (cpp.library.headers) for the new header \tcode{<scope>}.

In section 20.5.1.3 Freestanding implementations [compliance] add an extra row to table 19 (cpp.headers.freestanding) and 
in section [utilities.general] add the same extra row to table 34 (util.lib.summary)
%%TODO clearer specification 
\begin{table}[htb]
\caption{table 19 and table 34}
\begin{center}
\begin{tabular}{|lcl|}
\hline
&Subclause & Header\\
\hline
23.nn &Scope Guard Support & \tcode{<scope>}\\
\hline
\end{tabular}
\end{center}
\label{utilities}
\end{table}%

\section{Additional sections}
Add a a new section to chapter 23 introducing the contents of the header \tcode{<scope>}.

%\rSec1[utilities.scope]{Scope Guard}
\section{Scope guard support [scope]}
This subclause contains infrastructure for a generic scope guard and RAII (resource acquisition is initialization) resource wrapper.\\

\subsection{Header \tcode{<scope>} synopsis [scope.syn]}


\begin{codeblock}
namespace std {
template <class EF>
  class scope_exit;
template <class EF>
  class scope_fail;
template <class EF>
  class scope_success;

template <class R, class D>
  class unique_resource;

// factory function
template <class R, class D, class S=decay_t<R>>
  unique_resource<decay_t<R>, decay_t<D>>
  make_unique_resource_checked(R&& r, const S& invalid, D&& d) noexcept(@\seebelow@);
}
\end{codeblock}

\pnum
The header  \tcode{<scope>} defines the class templates \tcode{scope_exit}, \tcode{scope_fail}, \tcode{scope_success}, \tcode{unique_resource} and
the factory function template \tcode{make_unique_resource_checked()}.

\pnum 
The class templates \tcode{scope_exit}, \tcode{scope_fail}, and \tcode{scope_success} define\emph{ scope guards} that wrap a function object to be called on their destruction.

\pnum
The following sections describe the class templates \tcode{scope_exit}, \tcode{scope_fail}, and \tcode{scope_success}. In each section, the name \tcode{\textit{scope_guard}} denotes any of these class templates. In descriptions of the class members \tcode{\textit{scope_guard}} refers to the enclosing class.

\newpage
%\rSec2[scope.scope_guard]{Scope guard class templates}}
\subsection {Scope guard class templates [scope.scope_guard]}

\begin{codeblock}
template <class EF>
class @\tcode{\textit{scope_guard}}@ {
public:
  template <class EFP>
  explicit @\tcode{\textit{scope_guard}}@(EFP&& f) noexcept(@\seebelow@);
  @\tcode{\textit{scope_guard}}@(@\tcode{\textit{scope_guard}}@&& rhs) noexcept(@\seebelow@);
  ~@\tcode{\textit{scope_guard}}@() noexcept(@\seebelow@);
  void release() noexcept;

  @\tcode{\textit{scope_guard}}@(const @\tcode{\textit{scope_guard}}@&)=delete;
  @\tcode{\textit{scope_guard}}@& operator=(const @\tcode{\textit{scope_guard}}@&)=delete;
  @\tcode{\textit{scope_guard}}@& operator=(@\tcode{\textit{scope_guard}}@&&)=delete;
private:
  EF exit_function;    // exposition only
  bool execute_on_destruction{true}; //exposition only
  int  uncaught_on_creation{uncaught_exceptions()}; // exposition only
};

template <class EF>
@\tcode{\textit{scope_guard}}@(EF) -> @\tcode{\textit{scope_guard}}@<EF>;

\end{codeblock}

\pnum
\tcode{scope_exit} is a general-purpose scope guard that calls its exit function when a scope is exited. The class templates \tcode{scope_fail} and \tcode{scope_success} share the \tcode{scope_exit} interface, only the situation when the exit function is called differs.\\
\begin{example}
\begin{codeblock}
void grow(vector<int>& v){
	scope_success guard([]{ cout << "Good!" << endl; });
	v.resize(1024);
}
\end{codeblock}
\end{example}

\pnum
\begin{note}
If the exit function object of a \tcode{scope_success} or \tcode{scope_exit} object refers to a local variable of the function where it is defined, e.g., as a lambda capturing the variable by reference, and that variable is used as a return operand in that function, that variable might have already been returned when the \tcode{\textit{scope_guard}}'s destructor executes, calling the exit function. This can lead to surprising behavior. 
\end{note}


\pnum
\requires
Template argument \tcode{EF} shall be a function object type ([function.objects]), 
lvalue reference to function, or 
lvalue reference to function object type.
If EF is an object type, it  shall satisfy
the requirements of \tcode{Destructible} (Table~27
%\ref{destructible}
). 
%\tcode{is_callable<EF\&>::value} is \tcode{true}.
Given an lvalue \tcode{g} of type \tcode{remove_reference_t<EF>}, the expression \tcode{g()} shall be well-formed and shall have well-defined behavior.

\pnum
The constructor parameter \tcode{f} in the following constructors shall be a reference to a function or a reference to a function object([function.objects]). 
%lvalue reference to function, or 
%lvalue reference to function object.


\begin{itemdecl}
template <class EFP>
explicit
scope_exit(EFP&& f) noexcept(is_nothrow_constructible_v<EF, EFP>  
                          || is_nothrow_constructible_v<EF, EFP&>);
\end{itemdecl}

\begin{itemdescr}

\pnum
\requires 
%Given an lvalue \tcode{f} of type \tcode{remove_reference_t<EFP>}, t
The expression \tcode{f()} shall be well-formed, have well-defined behavior, and not throw an exception.


\pnum
\effects If \tcode{EFP} is not an lvalue reference type and \tcode{is_nothrow_constructible_v<EF,EFP>} is \tcode{true}, initialize  \tcode{exit_function} with \tcode{std::forward<EFP>(f)} otherwise initialize \tcode{exit_function} with \tcode{f}. 
If the initialization of \tcode{exit_function} throws an exception, calls \tcode{f()}.

\pnum
\throws Nothing, unless the initialization of \tcode{exit_function} throws.

\pnum
\remarks
This constructor shall not participate in overload resolution unless
\tcode{is_same_v<remove_cvref_t<EFP>, scope_exit<EF>>} is \tcode{false}
and \tcode{is_constructible_v<EF, EFP>} is \tcode{true}.
\end{itemdescr}


\begin{itemdecl}
template <class EFP>
explicit
scope_fail(EFP&& f) noexcept(is_nothrow_constructible_v<EF, EFP>
                          || is_nothrow_constructible_v<EF, EFP&>);

\end{itemdecl}

\begin{itemdescr}
\pnum
\requires 
%Given an lvalue \tcode{f} of type \tcode{remove_reference_t<EFP>}, t
The expression \tcode{f()} shall be well-formed, have well-defined behavior, and not throw an exception.

\pnum
\effects If \tcode{EFP} is not an lvalue reference type and \tcode{is_nothrow_constructible_v<EF,EFP>} is \tcode{true}, initialize  \tcode{exit_function} with \tcode{std::forward<EFP>(f)} otherwise initialize \tcode{exit_function} with \tcode{f}. If the initialization of \tcode{exit_function} throws an exception, calls \tcode{f()}.

\pnum
\throws Nothing, unless the initialization of \tcode{exit_function} throws.

\pnum
\remarks This constructor shall not participate in overload resolution unless 
\tcode{is_same_v<remove_cvref_t<EFP>, scope_fail<EF>>} is \tcode{false}
and \tcode{is_constructible_v<EF,EFP>} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template <class EFP>
explicit
scope_success(EFP&& f) noexcept(is_nothrow_constructible_v<EF, EFP>
                             || is_nothrow_constructible_v<EF, EFP&>);
\end{itemdecl}

\begin{itemdescr}
%\pnum
%\requires Given an lvalue \tcode{f} of type \tcode{remove_reference_t<EFP>}, the expression \tcode{f()} shall be well-formed and shall have well-defined behavior.
%Tim Song: f never called by scope_success

\pnum
\effects If \tcode{EFP} is not an lvalue reference type and \tcode{is_nothrow_constructible_v<EF,EFP>} is \tcode{true}, initialize  \tcode{exit_function} with \tcode{std::forward<EFP>(f)} otherwise initialize \tcode{exit_function} with \tcode{f}. 
\begin{note}
If initialization of \tcode{exit_function} fails, \tcode{f()} won't be called.
\end{note}

\pnum
\throws Nothing, unless the initialization of \tcode{exit_function} throws.

\pnum
\remarks This constructor shall not participate in overload resolution unless 
\tcode{is_same_v<remove_cvref_t<EFP>, scope_success<EF>>} is \tcode{false}, and
\tcode{is_constructible_v<EF,EFP>} is \tcode{true}.
\end{itemdescr}

\newpage
\begin{itemdecl}
@\tcode{\textit{scope_guard}}@(@\tcode{\textit{scope_guard}}@&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
If \tcode{EF} is an object type:
\begin{itemize}
 \item
if \tcode{is_nothrow_move_constructible_v<EF>} is true, \tcode{EF} shall satisfy the requirements of \tcode{MoveConstructible} (Table 23), 
\item
otherwise \tcode{EF} shall satisfy the requirements of \tcode{CopyConstructible} (Table 24).
\end{itemize}

\pnum
\effects %Copies the release state from \tcode{rhs}.
If \tcode{is_nothrow_move_constructible_v<EF>} intializes \tcode{exit_function} with \tcode{std::move(rhs.exitfunction)},
otherwise initialize \tcode{exit_function} with \tcode{rhs.exit_function}. Initializes \tcode{execute_on_destruction} from \tcode{rhs.execute_on_destruction} and \tcode{uncaught_on_creation} from \tcode{rhs.uncaught_on_creation}.
If construction succeeds, call \tcode{rhs.release()}.
\begin{note}
Copying instead of moving provides the strong exception guarantee.
%The \tcode{bool} and \tcode{int} members' initialization is trivial.
\end{note}


\pnum
\postconditions
\tcode{execute_on_destruction} yields the value \tcode{rhs.execute_on_destruction} yielded before the construction. 
\tcode{uncaught_on_creation} yields the value \tcode{rhs.uncaught_on_creation} yielded before the construction.

\pnum
\throws Any exception thrown during the initialization of \tcode{exit_function}.

\pnum
\remarks 
The expression inside \tcode{noexcept} is equivalent to \\
\tcode{is_nothrow_move_constructible_v<EF> || is_nothrow_copy_constructible_v<EF>}.\\
This constructor does not take part in overload resolution unless the expression \\
\tcode{(is_nothrow_move_constructible_v<EF> || is_copy_constructible_v<EF>)}
is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
~scope_exit() noexcept(true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Equivalent to:
\begin{codeblock}
if (execute_on_destruction)
	exit_function();
\end{codeblock}
%Calls \tcode{exit_function()}, unless \tcode{release()} was previously called.
\end{itemdescr}

\begin{itemdecl}
~scope_fail() noexcept(true);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Equivalent to:
\begin{codeblock}
if (execute_on_destruction
   && uncaught_exceptions() > uncaught_on_creation)
	exit_function();
\end{codeblock}
%Calls \tcode{exit_function()} if its scope is left with a new exception, unless \tcode{release()} was previously called.
\end{itemdescr}

\begin{itemdecl}
~scope_success() noexcept(noexcept(exit_function()));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if (execute_on_destruction 
   && uncaught_exceptions() <= uncaught_on_creation)
	exit_function();   
\end{codeblock}
% Calls \tcode{exit_function()} if its scope is left without an exception, unless \tcode{release()} was previously called.

\pnum
\begin{note}
If \tcode{noexcept(exit_function())} is \tcode{false}, \tcode{exit_function()} may throw an exception, notwithstanding the restrictions of [res.on.exception.handling].
%(c)Daniel Kruegler
\end{note}

\pnum
\throws
Any exception thrown by \tcode{exit_function()}.

\end{itemdescr}

\begin{itemdecl}
void release() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to
\tcode{execute_on_destruction = false}.
\end{itemdescr}


\newpage
%%%--------- unique_resource

%\rSec2[scope.unique_resource]{Unique resource wrapper}
\subsection{Unique resource wrapper [scope.unique_resource]}

%\rSec2[scope.unique_resource.class]{Class template \tcode{unique_resource}}
\subsection {Class template \tcode{unique_resource} [scope.unique_resource.class]}

\begin{codeblock}
template <class R,class D>
class unique_resource {
public:
  template <class RR, class DD>
    explicit 
    unique_resource(RR&& r, DD&& d) noexcept(@\seebelow@);
  unique_resource(unique_resource&& rhs) noexcept(@\seebelow@);
  ~unique_resource();
  unique_resource& operator=(unique_resource&& rhs) noexcept(@\seebelow@);
  void reset() noexcept;
  template <class RR>
    void reset(RR&& r);
  void release() noexcept;
  const R& get() const noexcept;
  @\seebelow@ operator*() const noexcept;
  R operator->() const noexcept;  
  const D& get_deleter() const noexcept;
private:
  using R1 = conditional_t< is_reference_v<R>, 
               reference_wrapper<remove_reference_t<R>>, R >; // exposition only
  R1   resource; // exposition only
  D    deleter;  // exposition only
  bool execute_on_destruction{true}; // exposition only
};

template<typename R, typename D>
  unique_resource(R, D) 
    -> unique_resource<R, D>;
\end{codeblock}
%% pass by value provide free decay_t, no parameter names in deduction guides

\pnum
\begin{note}
\tcode{unique_resource} is a universal RAII wrapper for resource handles.
Typically, such resource handles are of trivial type and come with a factory function and a clean-up or deleter function that do not throw exceptions.
The clean-up function together with the result of the factory function is used to create a \tcode{unique_resource} variable, that on destruction will call the clean-up function. Access to the underlying resource handle is achieved through \tcode{get()} and in case of a pointer type resource through a set of convenience pointer operator functions.
\end{note}


\pnum 
The template argument
\tcode{D} shall be a 
%CopyConstructible (Table~21
%\ref{copyconstructible}
%) and 
Destructible 
(Table~27
%\ref{destructible}
) function object type~(23.14~
%\ref{function.objects}
), 
for which, given
a value \tcode{d} of type \tcode{D} and a value
\tcode{r} of type \tcode{R}, the expression
\tcode{d(r)} shall be well-formed, shall have well-defined behavior, and shall not throw an exception.
\tcode{D} shall either be CopyConstructible (Table 24
%\ref{copyconstructible}
), or 
\tcode{D} shall be MoveConstructible (Table 23
%\ref{moveconstructible}
) and
\tcode{is_nothrow_move_constructible_v<D>} shall be \tcode{true}.

\pnum
For the purpose of this sub-clause, 
a \emph{resource type} \tcode{T} is an object type that is
CopyConstructible (Table 24
%\ref{copyconstructible}
),  or 
is an object type that is MoveConstructible (Table 23
%\ref{moveconstructible}
) and
\tcode{is_nothrow_move_constructible_v<T>} is \tcode{true},
or is an lvalue reference to a resource type.
\tcode{R} shall be a resource type.
 
%\tcode{R} shall be a
%Destructible 
%(Table~27
%%\ref{destructible}
%) object type 
%or an lvalue reference type.
%\tcode{R} shall either be CopyConstructible (Table 24
%%\ref{copyconstructible}
%),  or 
%\tcode{R} shall be MoveConstructible (Table 23
%%\ref{moveconstructible}
%) and
%\tcode{is_nothrow_move_constructible_v<R>} shall be \tcode{true}.

\newpage
%\rSec3[scope.unique_resource.ctor]{\tcode{unique_resource} constructors}}
\subsection {\tcode{unique_resource} constructors [scope.unique_resource.ctor]}


\begin{itemdecl}
template <class RR, class DD>
explicit 
unique_resource(RR&& r, DD&& d) noexcept(@\seebelow@)
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expressions
\tcode{d(r)} shall be well-formed, shall have well-defined behavior, and shall not throw an exception.
If \tcode{is_reference_v<R>} is \tcode{true}, \tcode{d(resource.get())} otherwise \tcode{d(resource)} shall be well-formed, shall have well-defined behavior, and shall not throw an exception.

\pnum
\effects 
If \tcode{is_nothrow_constructible_v<R1,RR>} is \tcode{true}, initializes \tcode{resource} with \tcode{std::forward<RR>(r)}, otherwise initializes \tcode{resource} with \tcode{r}.
%If RR is not an lvalue reference and \tcode{is_nothrow_constructible_v<R,RR>} is \tcode{true}, initializes \tcode{resource} with \tcode{std::move(r)}, otherwise initializes \tcode{resource} with \tcode{r}. 
Then, if \tcode{is_nothrow_constructible_v<D,DD>} is \tcode{true}, initializes \tcode{deleter} with \tcode{std::forward<DD>(d)}, otherwise initializes \tcode{deleter} with \tcode{d}.
%Then, if \tcode{DD} is not an lvalue reference and \tcode{is_nothrow_constructible_v<D,DD>} is \tcode{true}, initializes  \tcode{deleter} with \tcode{std::move(d)}, otherwise initializes \tcode{deleter} with \tcode{d}.
If initialization of \tcode{resource} throws an exception, calls \tcode{d(r)}.  If initialization of \tcode{deleter} throws an exception, if \tcode{is_reference_v<R>} is true, calls \tcode{d(resource.get())}, otherwise calls \tcode{d(resource)}. 
\begin{note}
The explained mechanism ensures no leaking of resources.
\end{note}

\pnum
\throws Any exception thrown during initialization.

\pnum
\remarks
The expression inside \tcode{noexcept} is equivalent to \\
\tcode{(is_nothrow_constructible_v<R1, RR> || is_nothrow_constructible_v<R1, RR\&>) \&\&}\\\tcode{(is_nothrow_constructible_v<D , DD> || is_nothrow_constructible_v<D , DD\&>)}.

\pnum
This constructor shall not participate in overload resolution unless\\
\tcode{is_constructible_v<R1,RR> \&\& is_constructible_v<D,DD> \&\&} \\
\tcode{(is_nothrow_constructible_v<R1, RR> || is_constructible_v<R1,RR\&>) \&\&}\\
\tcode{(is_nothrow_constructible_v<D , DD> || is_constructible_v<D ,DD\&>)} is \tcode{true}.\\
\begin{note}
The first two conditions prohibit initialization from a rvalue-reference when \tcode{R1} is \tcode{reference_wrapper<R>} or \tcode{is_reference_v<D>} is true.
\end{note}
\end{itemdescr}



\begin{itemdecl}
unique_resource(unique_resource&& rhs) noexcept(@\seebelow@)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects First, initialize \tcode{resource} as follows: 
\begin{itemize}
\item If \tcode{is_nothrow_move_constructible_v<R1>} is \tcode{true}, from \tcode{std::move(rhs.resource)}, 
\item otherwise, from \tcode{rhs.resource}.  
\end{itemize}
%% forward<R> must stay because R might be a reference and resource is a reference_wrapper

\pnum
\begin{note}
If initialization of \tcode{resource} throws an exception, \tcode{rhs} is left owning the resource and will free it in due time.
\end{note}

\pnum
Then, initialize \tcode{deleter} as follows: 
\begin{itemize}
\item If \tcode{is_nothrow_move_constructible_v<D>} is \tcode{true}, 
from \tcode{std::move(rhs.deleter)};
\item otherwise, 
from \tcode{rhs.deleter}. 
\end{itemize}

\pnum
If initialization of \tcode{deleter} throws an exception and 
if \tcode{is_nothrow_move_constructible_v<R1>} is \tcode{true}:
\begin{codeblock}
    rhs.deleter(resource); rhs.release();
\end{codeblock}

\pnum
Finally, \tcode{execute_on_destruction} is initialized with \tcode{exchange(rhs.execute_on_destruction,false)}.

\pnum
\begin{note}
The explained mechanism ensures no leaking of resources.
\end{note}

\pnum
\remarks
The expression inside \tcode{noexcept} is equivalent to \\
\tcode{is_nothrow_move_constructible_v<R1>} \tcode{\&\&} \tcode{is_nothrow_move_constructible_v<D>}.
\end{itemdescr}

%\rSec3[scope.unique_resource.assign]{\tcode{unique_resource} assignment}}
\subsection {\tcode{unique_resource} assignment [scope.unique_resource.assign]}

\begin{itemdecl}
unique_resource& operator=(unique_resource&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires 
If \tcode{is_nothrow_move_assignable_v<R1>} is \tcode{true}, \tcode{R1} shall be \tcode{MoveAssignable} (Table 25), otherwise \tcode{R1} shall be \tcode{CopyAssignable} (Table 26).
If \tcode{is_nothrow_move_assignable_v<D>} is \tcode{true}, \tcode{D} shall be \tcode{MoveAssignable} (Table 25), otherwise \tcode{D} shall be \tcode{CopyAssignable} (Table 26).
%\\\tcode{(is_nothrow_move_assignable_v<R1> || is_copy_assignable_v<R1>)} is \tcode{true}
%and\\
%\tcode{(is_nothrow_move_assignable_v<D> || is_copy_assignable_v<D>)} is \tcode{true}.

\pnum
% std::move(rhs.resource) vs. std::forward<R>(rhs.resource)
\effects Equivalent to
\begin{codeblock}
    reset();
    if constexpr (is_nothrow_move_assignable_v<R1>) {
        if constexpr (is_nothrow_move_assignable_v<D>) {
            resource = std::move(rhs.resource); 
            deleter  = std::move(rhs.deleter); 
        } else {
            deleter  = rhs.deleter; 
            resource = std::move(rhs.resource); 
        }
    } else {
        if constexpr (is_nothrow_move_assignable_v<D>) {
            resource = rhs.resource; 
            deleter  = std::move(rhs.deleter); 
        } else {
            resource = rhs.resource; 
            deleter  = rhs.deleter; 
        }
    }
    execute_on_destruction = exchange(rhs.execute_on_destruction, false);
\end{codeblock}

%\tcode{reset();} then assign resource and deleter as described below:  
%\begin{itemize}%% does move if noexcept does not consider assignability
%	\item if \tcode{(is_nothrow_move_assignable_v<R> \&\& is_nothrow_move_assignable_v<D>)} is \tcode{true}, \\
%	      then \tcode{resource = std::forward<R>(rhs.resource); deleter = std::forward<D>(rhs.deleter);}
%	\item if \tcode{(!is_nothrow_move_assignable_v<R> \&\& is_nothrow_move_assignable_v<D>)} is \tcode{true}, \\
%		  then \tcode{resource = rhs.resource; deleter = std::forward<D>(rhs.deleter); }
%	\item if \tcode{(is_nothrow_move_assignable_v<R> \&\& !is_nothrow_move_assignable_v<D>)} is \tcode{true}, \\
%	      then \tcode{deleter = rhs.deleter; resource = std::forward<R>(rhs.resource); }
%	\item otherwise \tcode{resource = rhs.resource; deleter = rhs.deleter; }
%\end{itemize}
%
%\pnum
%Then \tcode{execute_on_destruction = exchange(rhs.execute_on_destruction, false)}. 

\pnum
\begin{note}
If a copy of a member throws an exception this mechanism leaves \tcode{rhs} intact and \tcode{*this} in the released state.
\end{note}

\pnum
\throws Any exception thrown during a copy-assignment of a member that can not be moved without an exception.

\pnum
\remarks
The expression inside \tcode{noexcept} is equivalent to \\
\tcode{is_nothrow_move_assignable_v<R1>} \tcode{\&\&} \tcode{is_nothrow_move_assignable_v<D>}.
\end{itemdescr}


%\rSec3[scope.unique_resource.dtor]{\tcode{unique_resource} destructor}}
\subsection {\tcode{unique_resource} destructor [scope.unique_resource.dtor]}

\begin{itemdecl}
~unique_resource();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Equivalent to \tcode{reset()}.
\end{itemdescr}

\newpage
%\rSec3[scope.unique_resource.mfun]{\tcode{unique_resource} member functions}}
\subsection {\tcode{unique_resource} member functions [scope.unique_resource.mfun]}

\begin{itemdecl}
void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if (execute_on_destruction) {
    execute_on_destruction = false;
    if constexpr ( is_reference_v<R> ) 
        deleter(resource.get());
    else 
        deleter(resource);
}
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class RR>
void reset(RR && r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The expression \tcode{deleter(r)} shall be well-formed, shall have well-defined behavior, and shall not throw an exception.

\pnum
\effects 
Equivalent to:
\begin{codeblock}
reset();
if constexpr ( is_nothrow_assignable_v<R1&,RR> )
    resource = std::forward<RR>(r);
else
    resource = as_const(r);
execute_on_destruction = true;
\end{codeblock}

If copy-assignment of \tcode{resource} throws an exception, calls \tcode{deleter(r)}.

\pnum
\remarks This function \tcode{reset} shall not participate in overload resolution if the selected assignment expression statement assigning \tcode{resource} is ill-formed.
\end{itemdescr}



%Invokes the deleter function for resource if it was not previously released, e.g. \tcode{reset(); }  Then moves newresource into the tracked resource member, e.g. \tcode{resource = std::move(newresource);}  Finally sets the object in the non-released state so that the deleter function will be invoked on destruction if \tcode{release()} is not called first.

\begin{itemdecl}
void release() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Equivalent to \tcode{execute_on_destruction = false}.
\end{itemdescr}


\begin{itemdecl}
const R& get() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{resource}. % reference_wrapper automatically converts to reference type
\end{itemdescr}


\begin{itemdecl}
@\seebelow@ operator*() const noexcept;
\end{itemdecl}

\begin{itemdescr}

\pnum
\requires
The return type is equivalent to 
\tcode{add_lvalue_reference_t<remove_pointer_t<R>>}. 

\pnum
\effects 
Equivalent to:\\
\tcode{return *get();} 

\pnum
\remarks 
This operator shall not participate in overload resolution unless \tcode{is_pointer_v<R> \&\& !is_void_v<remove_pointer_t<R>>} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
R operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\pnum
\returns \tcode{get()}.

\remarks 
This operator 
shall not participate in overload resolution unless 
\tcode{is_pointer_v<R>} 
is \tcode{true}. 
\end{itemdescr}



\begin{itemdecl}
const D & get_deleter() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{deleter}.
\end{itemdescr}

%\rSec2[scope.make_unique_resource]{Factory for \tcode{unique_resource}}
\subsection {Factory for \tcode{unique_resource} [scope.make_unique_resource]}

\begin{itemdecl}
template <class R, class D, class S=decay_t<R>>
unique_resource<decay_t<R>, decay_t<D>>
make_unique_resource_checked(R&& resource, const S& invalid, D&& d ) 
noexcept(is_nothrow_constructible_v<decay_t<R>, R> &&
         is_nothrow_constructible_v<decay_t<D>, D>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The expression \tcode{( resource == invalid ? true : false )} shall be well-formed, have well-defined behavior, and shall not throw an exception.
%If \tcode{s} denotes a value of type \tcode{remove_reference_t<S>} and \tcode{r} denotes a
%value of type \tcode{remove_reference_t<R>}, the expressions \tcode{s == r} and \tcode{r == s}
%are both valid, both have the same domain, both have a type that is
%convertible to \tcode{bool}, and \tcode{bool(s == r) == bool(r == s)} for every \tcode{r} and
%\tcode{s}. If \tcode{S} is the same type as \tcode{R}, \tcode{R} shall be EqualityComparable(Table~17
%%\ref{equalitycomparable}
%). 
%% EqualityComparable<R,S> is a concept in ranges TS and would make the paragraph go away.

\pnum
\effects Constructs and returns \\
\tcode{\{std::forward<R>(resource), std::forward<D>(d)\}}. 

\pnum
If \tcode{bool(resource == invalid)} evaluates to \tcode{true} before the construction, the returned \tcode{unique_resource} object's \tcode{execute_on_destruction} is \tcode{false}. 
In that case, any failure during the construction of the return value will not call \tcode{d(resource)}.

\pnum
\begin{note}
This factory function exists to avoid calling a deleter function with an invalid argument. 
\end{note}

\pnum
\begin{example}
The following example shows its use to avoid calling \tcode{fclose} when \tcode{fopen} fails
\begin{codeblock}
auto file = make_unique_resource_checked(
  ::fopen("potentially_nonexistent_file.txt", "r"), 
  nullptr, &::fclose);
\end{codeblock}
\end{example}

\end{itemdescr}


\subsection {Feature test macro}
For the purposes of SG10, we recommend the feature-testing macro name \tcode{__cpp_lib_scope}.

\chapter{Appendix: Example Implementation} 
See 
\url{https://github.com/PeterSommerlad/SC22WG21_Papers/tree/master/workspace/P0052_scope_exit/src}
\end{document}

