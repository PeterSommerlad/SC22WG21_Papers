\documentclass[ebook,11pt,article]{memoir}
\usepackage{geometry}  % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}  % ... or a4paper or a5paper or ... 
%\geometry{landscape}  % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}  % Activate to begin paragraphs with an empty line rather than an indent

%\usepackage{color}        % define colors for strikeouts and underlines
%\usepackage{underscore}   % remove special status of '_' in ordinary text
%\usepackage{xspace}
%\usepackage[normalem]{ulem}
%%%%% from std.tex:
\usepackage[american]
           {babel}        % needed for iso dates
\usepackage[iso,american]
           {isodate}      % use iso format for dates
\usepackage[final]
           {listings}     % code listings
\usepackage{longtable}    % auto-breaking tables
\usepackage{ltcaption}    % fix captions for long tables
\usepackage{relsize}      % provide relative font size changes
\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{underscore}   % remove special status of '_' in ordinary text
\usepackage{parskip}      % handle non-indented paragraphs "properly"
\usepackage{array}        % new column definitions for tables
\usepackage[normalem]{ulem}
\usepackage{enumitem}
\usepackage{color}        % define colors for strikeouts and underlines
\usepackage{amsmath}      % additional math symbols
\usepackage{mathrsfs}     % mathscr font
\usepackage[final]{microtype}
\usepackage{multicol}
\usepackage{xspace}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[pdftex, final]{graphicx}
%\usepackage[pdftex,
%%            pdftitle={C++ International Standard},
%%            pdfsubject={C++ International Standard},
%%            pdfcreator={Richard Smith},
%            bookmarks=true,
%            bookmarksnumbered=true,
%            pdfpagelabels=true,
%            pdfpagemode=UseOutlines,
%            pdfstartview=FitH,
%            linktocpage=true,
%            colorlinks=true,
%            linkcolor=blue,
%            plainpages=false
%           ]{hyperref}
%\usepackage{memhfixc}     % fix interactions between hyperref and memoir
%\usepackage[active,header=false,handles=false,copydocumentclass=false,generate=std-gram.ext,extract-cmdline={gramSec},extract-env={bnftab,simplebnf,bnf,bnfkeywordtab}]{extract} % Grammar extraction
%
%%%%%

\pagestyle{myheadings}

\newcommand{\papernumber}{p0506r2}
\newcommand{\paperdate}{2017-10-06}

%\definecolor{insertcolor}{rgb}{0,0.5,0.25}
%\newcommand{\removed}[1]{\textcolor{red}{\sout{#1}}}
%\newcommand{\added}[1]{\textcolor{insertcolor}{\underline{#1}}}
%
%\newenvironment{insrt}{\color{insertcolor}}{\color{black}}


\markboth{\papernumber{} \paperdate{}}{\papernumber{} \paperdate{}}
\input{macros}
\input{styles}
\input{layout}
\input{tables}

\title{\papernumber{} - use string\_view for library function parameters instead of const string \&/const char *}
\author{Peter Sommerlad}
\date{\paperdate}                        % Activate to display a given date or no date
\setsecnumdepth{subsection}

\begin{document}
\maketitle
\begin{tabular}[t]{|l|l|}\hline 
Document Number:& \papernumber  \\\hline
Date: & \paperdate \\\hline
Project: & Programming Language C++\\\hline 
Audience: & LWG/LEWG\\\hline
\end{tabular} 

\chapter{Motivation}
With \tcode{basic_string_view} there is no longer a reason to keep library APIs that have overloads taking \tcode{std::string const \&} and \tcode{char const *} parameter types. Both should be replaced by a single version taking a std::string_view.

\chapter{Introduction}

A draft of this paper was discussed in LEWG in Issaquah but it was considered to rushed to push this into C++17. However it addresses issue CH 9:

"The standard library should provide string_view parameters instead or in addition for functions defined with \tcode{char const *} or \tcode{string const \&} as parameter types. Most notably in cases where both such overloads exist or where an internal copy is expected anyway.
It might be doubted that the non-null termination of \tcode{string_view} could be an issue with functions that pass the \tcode{char *} down to OS functions, such as \tcode{fstream_buf::open()} etc and those should not provide it and favour generating a \tcode{std::string} temporary instead in that case. However, \tcode{std::path} demonstrates it is usable to have \tcode{string_view} overloads and there might be many places where it can be handy, or even better."

Proposed change: "Provide the overloads for \tcode{std::regex}, the exception classes, \tcode{std::bitset}, \tcode{std::locale} and more."

by providing changes for library sections 22, 23.9, 24.3.4, 25 and 31. The "and more" part is in 30.7.1/30.7.6 with respect to the quoted output manipulator and the application of string view to string streams is given in p0408.

\chapter{Acknowledgements}
\begin{itemize}
\item LEWG in Issaquah for proposing me to write this paper, even when it can not make it into C++17.
\item Alisdair Meredith for extensive review and suggestions by email in July 2017.
\item Arthur O'Dwyer for suggesting numeric conversions to use \tcode{string_view} as well.
\end{itemize}

\chapter{Changes from previous versions}
\section{p0506r1} 
\begin{itemize}
\item include section 24.3.4 numeric conversions to employ \tcode{string_view} instead of \tcode{const string\&} as suggested by Arthur O. Dwyer.
\item Among some things Alisdair pointed out several places where deduction is incomplete, or an \tcode{Allocator} template parameter was sticking around. After thinking about that, I figured that \tcode{bitset} requires to keep a \tcode{char const *} constructor overload and just should replace the \tcode{const string \&} overload with a \tcode{string_view} overload
\item Alisdair further pointed out, that quoted will not work with a basic_string_view overload only. Also the standard text changed in between the version when this paper was started wrt LWG2785 to add an additional quoted overload for \tcode{basic_string_view}. I tried to implement it and figured out, that template argument deduction won't work nicely with implicit conversions, without all 3 template versions. So I suggest to sidestep from templatizing \tcode{quoted} for output and provide deliberate overloads for the relevant stream character types (\tcode{char}, \tcode{wchar_t}) in the standard. With such an implementation one \tcode{string_view} overload is sufficient to cover arguments of all kinds of string representations (character pointers, string, string view). This results in only two overloads instead of three templated overloads for output. We won't have streams for other character types than \tcode{char} and \tcode{wchar_t} in the foreseeable future, I believe. Unfortuntely C++17 shipped with the three template overloads for quoted output (sadly).

\item As Alisdair suggested I removed reference to construction from nullptr from the locale section.

\item According to Alisdair 22.5.7 system error and filesystem error needs to be adapted as well to reduce the number of ctor overloads (didn't have time to specify it yet).

\end{itemize}

\section{p0506r0} 
\begin{itemize}
\item removed unnecessary Allocator template parameter
\item change layout in regex adaptation to see changes easier piecewise judgement
\item adjust latex to most current std.tex macros
\item adjust to new standard chapter numbering
\item make \tcode{regex_search} allocator aware again by taking the allocator from a string parameter.
\end{itemize}


%\chapter{example code}


\chapter{Impact on the Standard}
Using string view as parameter type instead of overloading for char pointers and string references has the potential to significantly shorten the specification. Most notable this happens in the regex library, where we get from six overloads down to two, for example, for \tcode{regex_replace}.

In my opinion such a change for a new C++ standard is an important simplification and sidesteps current "pessimizations" due to extra string objects created when passed as arguments.

A separate paper p0408 specifies the application of \tcode{basic_string_view} for \tcode{basic_stringbuf} and string streams to optimize access to their respective internal buffer.


%\chapter{Technical Specifications}
The following is relative to the CD/current working draft.

\section{22.2 {Exception classes} [std.exceptions]}
For all subclasses of std::exception, std::logic_error, and std::runtime_error specified in section 22.2 [stdexcept.syn] apply the following changes respectively by replacing \emph{\tcode{std_exception}} with the corresponding class and \emph{\tcode{base_exception}} by its respective base class:


%\rSec2[logic.error]{Class \tcode{logic_error}}
%%%%%%%%%\indexlibrary{\idxcode{logic_error}}%
\begin{codeblock}
namespace std {
  class @\emph{std_exception}@ : public @\emph{base_exception}@ {
  public:
    @\added{explicit std_exception(string_view what_arg);}@
    @\removed{explicit std_exception(const string \& what_arg);}@
    @\removed{explicit std_exception(const char* what_arg);}@
  };
}
\end{codeblock}

\pnum
The class
\emph{\tcode{std_exception}} ... \emph{no change}.

%%%%%%%%%\indexlibrary{\idxcode{std_exception}!constructor}%
\begin{itemdecl}
@\removed{std_exception(const string\& what_arg);}@
@\added{std_exception(string_view what_arg);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\emph{\tcode{std_exception}}.

\pnum
\postconditions
\removed{\tcode{strcmp(what(), what_arg.c_str()) == 0}.\\}
\added{\tcode{what_arg.compare(what()) == 0}.}
\end{itemdescr}

\begin{removedblock}
%%%%%%%%%\indexlibrary{\idxcode{std_exception}!constructor}%
\begin{itemdecl}
std_exception(const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{std_exception}.

\pnum
\postconditions
\tcode{strcmp(what(), what_arg) == 0}.
\end{itemdescr}
\end{removedblock}


\section{22.5.7 {Class \tcode{system_error}} [syserr.syserr]}
Change the class definition in 22.5.7.1 [syserr.syserr.overview] as follows:
\indexlibrary{\idxcode{system_error}}%
\begin{codeblock}
namespace std {
  class system_error : public runtime_error {
  public:
    system_error(error_code ec, @\removed{const }@string@\added{_view}\removed{\&}@ what_arg);
    @\removed{system_error(error_code ec, const char* what_arg);}@
    system_error(error_code ec);
    system_error(int ev, const error_category& ecat, @\removed{const }@string@\added{_view}\removed{\&}@ what_arg);
    @\removed{system_error(int ev, const error_category\& ecat, const char* what_arg);}@
    system_error(int ev, const error_category& ecat);
    const error_code& code() const noexcept;
    const char* what() const noexcept override;
  };
}
\end{codeblock}

Change the constructor definitions in 22.5.7.2 [syserr.syserr.members] {Class \tcode{system_error} members} 
accordingly:

\indexlibrary{\idxcode{system_error}!constructor}%
\begin{itemdecl}
system_error(error_code ec,  @\removed{const }@string@\added{_view}\removed{\&}@ what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{system_error}.

\pnum
\postconditions \tcode{code() == ec} and
\tcode{string(what()).find(what_arg) != string::npos}.
\end{itemdescr}

\begin{removedblock}
\indexlibrary{\idxcode{system_error}!constructor}%
\begin{itemdecl}
system_error(error_code ec, const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{system_error}.

\pnum
\postconditions \tcode{code() == ec} and
\tcode{string(what()).find(what_arg) != string::npos}.
\end{itemdescr}
\end{removedblock}

\indexlibrary{\idxcode{system_error}!constructor}%
\begin{itemdecl}
system_error(error_code ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{system_error}.

\pnum
\postconditions \tcode{code() == ec}.
\end{itemdescr}

\indexlibrary{\idxcode{system_error}!constructor}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat,  @\removed{const }@string@\added{_view}\removed{\&}@ what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{system_error}.

\pnum
\postconditions \raggedright \tcode{code() == error_code(ev, ecat)} and\linebreak
\tcode{string(what()).find(what_arg) != string::npos}.
\end{itemdescr}

\begin{removedblock}
\indexlibrary{\idxcode{system_error}!constructor}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat, const char* what_arg);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{system_error}.

\pnum
\postconditions \raggedright \tcode{code() == error_code(ev, ecat)} and\linebreak
\tcode{string(what()).find(what_arg) != string::npos}.
\end{itemdescr}
\end{removedblock}

\indexlibrary{\idxcode{system_error}!constructor}%
\begin{itemdecl}
system_error(int ev, const error_category& ecat);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{system_error}.

\pnum
\postconditions \tcode{code() == error_code(ev, ecat)}.
\end{itemdescr}

%%%%%%%%%%
\section{ 30.10.8 Class filesystem_error [fs.class.filesystem_error]}
Change the const string reference parameters of \tcode{filesystem_error} constructors to \tcode{string_view} to sidestep extra string temporaries. LEWG should discuss if this is beneficial enough to warrant an ABI breaking change. 

Change the definition of class filesystem_error as follows:
\indexlibrary{\idxcode{filesystem_error}}%
\begin{codeblock}
namespace std::filesystem {
  class filesystem_error : public system_error {
  public:
    filesystem_error(@\removed{const }@string@\added{_view}\removed{\&}@ what_arg, error_code ec);
    filesystem_error(@\removed{const }@string@\added{_view}\removed{\&}@ what_arg,
                     const path& p1, error_code ec);
    filesystem_error(@\removed{const }@string@\added{_view}\removed{\&}@ what_arg,
                     const path& p1, const path& p2, error_code ec);

    const path& path1() const noexcept;
    const path& path2() const noexcept;
    const char* what() const noexcept override;
  };
}
\end{codeblock}
\pnum
The class \tcode{filesystem_error} defines the type of
objects thrown as exceptions to report file system errors from functions described in this
subclause.

\subsection{30.10.8.1 [fs.filesystem_error.members]{\tcode{filesystem_error} members} }

In section 30.10.8.1 [fs.filesystem_error.members]{\tcode{filesystem_error} members} change the constructors accordingly:

\pnum
 Constructors are provided that store zero, one, or two paths associated with
an error.

\indexlibrary{\idxcode{filesystem_error}!constructor}%
\begin{itemdecl}
filesystem_error(@\removed{const }@string@\added{_view}\removed{\&}@ what_arg, error_code ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions The postconditions of this function are indicated in
Table~\ref{tab:filesystem_error.1}.
\end{itemdescr}

\begin{floattable}
{\tcode{filesystem_error(\removed{const }string\added{_view}\removed{\&} , error_code)} effects}{tab:filesystem_error.1}
{ll}
\topline
\lhdr{Expression}		& \rhdr{Value} \\ \capsep
\tcode{\added{what_arg.compare(}runtime_error::what()\added{)}}	& \tcode{\removed{what_arg.c_str()}\added{0}} \\ \rowsep
\tcode{code()}			& \tcode{ec}	\\ \rowsep
\tcode{path1().empty()}		& \tcode{true}	\\ \rowsep
\tcode{path2().empty()}		& \tcode{true}	\\ \rowsep
\end{floattable}

\indexlibrary{\idxcode{filesystem_error}!constructor}%
\begin{itemdecl}
filesystem_error(@\removed{const }@string@\added{_view}\removed{\&}@ what_arg, const path& p1, error_code ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions The postconditions of this function are indicated in
Table~\ref{tab:filesystem_error.2}.

\begin{floattable}
{\tcode{filesystem_error(\removed{const }string\added{_view}\removed{\&} , const path\&, error_code)} effects}{tab:filesystem_error.2}
{ll}
\topline
\lhdr{Expression}		& \rhdr{Value} \\ \capsep
\tcode{\added{what_arg.compare(}runtime_error::what()\added{)}}	& \tcode{\removed{what_arg.c_str()}\added{0}} \\ \rowsep
\tcode{code()}			& \tcode{ec}	\\ \rowsep
\tcode{path1()}			& Reference to stored copy of \tcode{p1}	\\ \rowsep
\tcode{path2().empty()}		& \tcode{true}	\\ \rowsep
\end{floattable}
\end{itemdescr}

\indexlibrary{\idxcode{filesystem_error}!constructor}%
\begin{itemdecl}
filesystem_error(@\removed{const }@string@\added{_view}\removed{\&}@ what_arg, const path& p1, const path& p2, error_code ec);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions The postconditions of this function are indicated in
Table~\ref{tab:filesystem_error.3}.

\begin{floattable}
{\tcode{filesystem_error(\removed{const }string\added{_view}\removed{\&}, const path\&, const path\&, error_code)} effects}{tab:filesystem_error.3}
{ll}
\topline
\lhdr{Expression}		& \rhdr{Value} \\ \capsep
\tcode{\added{what_arg.compare(}runtime_error::what()\added{)}}	& \tcode{\removed{what_arg.c_str()}\added{0}} \\ \rowsep
\tcode{code()}			& \tcode{ec}	\\ \rowsep
\tcode{path1()}			& Reference to stored copy of \tcode{p1}	\\ \rowsep
\tcode{path2()}			& Reference to stored copy of \tcode{p2}	\\ \rowsep
\end{floattable}
\end{itemdescr}


%%%%%%%%%%
\section{ 23.9 Class template \tcode{bitset}  [template.bitset]}%

Note to the reviewers: It should be considered if this new constructor could be made constexpr.

In p1 replace the constructors taking \tcode{string const \&} and \tcode{char const *} by one taking \tcode{string_view} by applying the following changes:

\begin{codeblock}
namespace std {
  template<size_t N> class bitset {
  public:
//...
    // \ref{bitset.cons} constructors:
    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
   
    template<class charT, class traits>
      explicit bitset(
        basic_string_view<charT, traits> sv,
        typename basic_string_view<charT, traits>::size_type pos = 0,
        typename basic_string_view<charT, traits>::size_type n =
          basic_string_view<charT, traits>::npos,
          charT zero = charT('0'), charT one = charT('1'));
    
\end{codeblock}
\end{addedblock}
\begin{removedblock}
\begin{codeblock}
    template<class charT, class traits, class Allocator>
      explicit bitset(
        const basic_string<charT, traits, Allocator>& str,
        typename basic_string<charT, traits, Allocator>::size_type pos = 0,
        typename basic_string<charT, traits, Allocator>::size_type n =
          basic_string<charT, traits, Allocator>::npos,
          charT zero = charT('0'), charT one = charT('1'));
\end{codeblock}
\end{removedblock}
\begin{codeblock}
    template <class charT>
      explicit bitset(
        const charT* str,
        typename basic_string@\added{_view}@<charT>::size_type n = basic_string@\added{_view}@<charT>::npos,
        charT zero = charT('0'), charT one = charT('1'));
        //...
        };
\end{codeblock}

In 23.9.1 replace p3 to p6 defining the removed constructor by the following:

%%%%%%%%%\indexlibrary{\idxcode{bitset}!constructor}%
\begin{addedblock}
\begin{itemdecl}
template <class charT, class traits>
explicit
bitset(basic_string_view<charT, traits> sv,
       typename basic_string_view<charT, traits>::size_type pos = 0,
       typename basic_string_view<charT, traits>::size_type n =
         basic_string_view<charT, traits>::npos,
         charT zero = charT('0'), charT one = charT('1'));
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws
\tcode{out_of_range}
if
\tcode{pos > str.size()}
or \tcode{invalid_argument} if an invalid character is found (see below).%
%%%%%%%%%\indexlibrary{\idxcode{out_of_range}}

\pnum
\effects
Determines the effective length
\tcode{rlen} of the initializing string as the smaller of
\tcode{n} and
\tcode{str.size() - pos}.

The function then throws%
%%%%%%%%%\indexlibrary{\idxcode{invalid_argument}}
\tcode{invalid_argument}
if any of the \tcode{rlen}
characters in \tcode{str} beginning at position \tcode{pos} is
other than \tcode{zero} or \tcode{one}. The function uses \tcode{traits::eq()}
to compare the character values.

Otherwise, the function constructs an object of class
\tcode{bitset<N>},
initializing the first \tcode{M} bit
positions to values determined from the corresponding characters in the string
\tcode{str}.
\tcode{M} is the smaller of \tcode{N} and \tcode{rlen}.

\pnum
An element of the constructed object has value zero if the
corresponding character in \tcode{str}, beginning at position
\tcode{pos}, is
\tcode{zero}.
Otherwise, the element has the value one.
Character position \tcode{pos + M - 1} corresponds to bit position zero.
Subsequent decreasing character positions correspond to increasing bit positions.

\pnum
If \tcode{M < N}, remaining bit positions are initialized to zero.
\end{itemdescr}
\end{addedblock}

In 23.9.1 change p7 defining the changed constructor as follows:

\begin{itemdecl}
template <class charT>
  explicit bitset(
    const charT* str,
    typename basic_string@\added{_view}@<charT>::size_type n = basic_string@\added{_view}@<charT>::npos,
    charT zero = charT('0'),
    charT one = charT('1'));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of class \tcode{bitset<N>} as if by:
\begin{codeblock}
bitset(n == basic_string@\added{_view}@<charT>::npos
          ? basic_string@\added{_view}@<charT>(str)
          : basic_string@\added{_view}@<charT>(str, n),
       0, n, zero, one)
\end{codeblock}
\end{itemdescr}


%%%%%%%%
\section{24.3.4 Numeric conversions [string.confersions]}
Change the section as follows, by replacing all \tcode{const string \&} with \tcode{string_view} instead and 
all \tcode{const wstring \&} with \tcode{wstring_view}. Accordingly change the header in 24.3.1 accordingly and LEWG should consider moving the \tcode{sto}\textit{x} \tcode{wsto}\textit{x} functions to the \tcode{<string_view>} header 24.4.1 instead and splitting 24.3.4 into two sections and put the "to" functions to a new section in 24.4. I wait for that guidance before taking everything into account.

%\rSec2[string.conversions]{Numeric conversions}

%\indexlibrary{\idxcode{stoi}}%
%\indexlibrary{\idxcode{stol}}%
%\indexlibrary{\idxcode{stoul}}%
%\indexlibrary{\idxcode{stoll}}%
%\indexlibrary{\idxcode{stoull}}%
\begin{itemdecl}
int stoi(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr, int base = 10);
long stol(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr, int base = 10);
long long stoll(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr, int base = 10);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \added{The functions behave as if the character sequence denoted by \tcode{str} is null-terminated while the following calls happen.} The first two functions call \tcode{strtol(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr, base)},
and the last three functions call \tcode{strtoul(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr, base)},
\tcode{strtoll(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr, base)}, and \tcode{strtoull(\brk{}str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr,
base)}, respectively. Each function returns the converted result, if any. The
argument \tcode{ptr} designates a pointer to an object internal to the function
that is used to determine what to store at \tcode{*idx}. If the function does
not throw an exception and \tcode{idx != 0}, the function stores in \tcode{*idx}
the index of the first unconverted element of \tcode{str}.

\pnum
\returns The converted result.

\pnum
\throws \tcode{invalid_argument} if \tcode{strtol}, \tcode{strtoul},
\tcode{strtoll}, or \tcode{strtoull} reports that no conversion could be
performed. Throws \tcode{out_of_range} if \tcode{strtol}, \tcode{strtoul},
\tcode{strtoll} or \tcode{strtoull} sets \tcode{errno} to \tcode{ERANGE},
or if the converted value is outside the range of representable values
for the return type.
\end{itemdescr}

\indexlibrary{\idxcode{stof}}%
\indexlibrary{\idxcode{stod}}%
\indexlibrary{\idxcode{stold}}%
\begin{itemdecl}
float stof(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr);
double stod(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr);
long double stold(@\added{string_view}\removed{const string\&}@ str, size_t* idx = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \added{Theses functions behave as if the character sequence denoted by \tcode{str} is null-terminated while the following calls happen.} These functions call
\tcode{strtof(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr)}, \tcode{strtod(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr)}, and
\tcode{strtold(\brk{}str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr)}, respectively. Each function returns
the converted result, if any. The argument \tcode{ptr} designates a pointer to
an object internal to the function that is used to determine what to store at
\tcode{*idx}. If the function does not throw an exception and \tcode{idx != 0},
the function stores in \tcode{*idx} the index of the first unconverted element
of \tcode{str}.

\pnum
\returns The converted result.

\pnum
\throws \tcode{invalid_argument} if \tcode{strtof}, \tcode{strtod}, or
\tcode{strtold} reports that no conversion could be performed. Throws
\tcode{out_of_range} if \tcode{strtof}, \tcode{strtod}, or
\tcode{strtold} sets \tcode{errno} to \tcode{ERANGE}
or if the converted value is outside the range of representable
values for the return type.
\end{itemdescr}

\indexlibrary{\idxcode{stoi}}%
\indexlibrary{\idxcode{stol}}%
\indexlibrary{\idxcode{stoul}}%
\indexlibrary{\idxcode{stoll}}%
\indexlibrary{\idxcode{stoull}}%
\begin{itemdecl}
int stoi(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr, int base = 10);
long stol(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr, int base = 10);
unsigned long stoul(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr, int base = 10);
long long stoll(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr, int base = 10);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \added{Theses functions behave as if the character sequence denoted by \tcode{str} is null-terminated while the following calls happen.}
The first two functions call \tcode{wcstol(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr, base)},
and the last three functions call \tcode{wcstoul(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr, base)},
\tcode{wcstoll(str.c_str(), ptr, base)}, and \tcode{wcstoull(\brk{}str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr,
base)}, respectively. Each function returns the converted result, if any. The
argument \tcode{ptr} designates a pointer to an object internal to the function
that is used to determine what to store at \tcode{*idx}. If the function does
not throw an exception and \tcode{idx != 0}, the function stores in \tcode{*idx}
the index of the first unconverted element of \tcode{str}.

\pnum
\returns The converted result.

\pnum
\throws \tcode{invalid_argument} if \tcode{wcstol}, \tcode{wcstoul}, \tcode{wcstoll}, or
\tcode{wcstoull} reports that no conversion could be performed. Throws
\tcode{out_of_range} if the converted value is outside the range of representable values
for the return type.
\end{itemdescr}

\indexlibrary{\idxcode{stof}}%
\indexlibrary{\idxcode{stod}}%
\indexlibrary{\idxcode{stold}}%
\begin{itemdecl}
float stof(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr);
double stod(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr);
long double stold(@\added{wstring_view}\removed{const wstring\&}@ str, size_t* idx = nullptr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \added{Theses functions behave as if the character sequence denoted by \tcode{str} is null-terminated while the following calls happen.}
These functions call \tcode{wcstof(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr)},
\tcode{wcstod(str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr)}, and \tcode{wcstold(\brk{}str.}\added{\tcode{data()}}\removed{\tcode{c_str()}}\tcode{, ptr)},
respectively. Each function returns the converted
result, if any. The argument \tcode{ptr} designates a pointer to an object internal to
the function that is used to determine what to store at \tcode{*idx}. If the function
does not throw an exception and \tcode{idx != 0}, the function stores in \tcode{*idx}
the index of the first unconverted element of \tcode{str}.

\pnum
\returns The converted result.

\pnum
\throws \tcode{invalid_argument} if \tcode{wcstof}, \tcode{wcstod}, or \tcode{wcstold} reports that no
conversion could be performed. Throws \tcode{out_of_range} if \tcode{wcstof}, \tcode{wcstod}, or
\tcode{wcstold} sets \tcode{errno} to \tcode{ERANGE}.
\end{itemdescr}



%%%%%%%%
\section{25.3 Locale}
The following things could be adapted:
\begin{itemize}
\item locale's ctors 
\item locale's call operator
\item \tcode{wstring_convert} (not proposed)
\item all \tcode{xxx_byname} template class constructors.
\end{itemize}


Change the synopsis of class \tcode{locale} as follows:
\begin{codeblock}
namespace std {
  class locale {
  public:
    // types:
    class facet;
    class id;
    using category = int;
    static const category   // values assigned here are for exposition only
      none     = 0,
      collate  = 0x010, ctype    = 0x020,
      monetary = 0x040, numeric  = 0x080,
      time     = 0x100, messages = 0x200,
      all = collate | ctype | monetary | numeric | time  | messages;

    // construct/copy/destroy:
    locale() noexcept;
    locale(const locale& other) noexcept;
    @\removed{explicit locale(const char* std_name);}@
    explicit locale(@\removed{const }@string@\added{_view}\removed{\&}@ std_name);
    @\removed{locale(const locale\& other, const char* std_name, category);}@
    locale(const locale& other, @\removed{const }@string@\added{_view}\removed{\&}@ std_name, category);
    template <class Facet> locale(const locale& other, Facet* f);
    locale(const locale& other, const locale& one, category);
    ~locale();                  // not virtual
    const locale& operator=(const locale& other) noexcept;
    template <class Facet> locale combine(const locale& other) const;

    // locale operations:
    basic_string<char>                  name() const;

    bool operator==(const locale& other) const;
    bool operator!=(const locale& other) const;

// note: this change might require 3 overloads for charT pointers, basic_string and basic_string_view
// because template argument deduction will fail. is that used at all somewhere?
    template <class charT, class traits@\removed{, class Allocator}@>
      bool operator()(@\removed{const }@basic_string@\added{_view}@<charT,traits@\removed{,Allocator}@>@\removed{\&}@ s1,
                      @\removed{const }@basic_string@\added{_view}@<charT,traits@\removed{,Allocator}@>@\removed{\&}@ s2) const;

    // global locale objects:
    static       locale  global(const locale&);
    static const locale& classic();
  };
}
\end{codeblock}

\subsection{25.3.1.1.2 Class \tcode{locale::facet} [locale.facet]}
Change p4 as follows:

\pnum
For some standard facets a standard
``$\ldots$\tcode{_byname}''
class, derived from it, implements the virtual function semantics
equivalent to that facet of the locale constructed by
\tcode{locale(\removed{const char*}\added{string_view})}
with the same name.
Each such facet provides a constructor that takes a
\tcode{\removed{const char*}\added{string_view}}
argument, which names the locale, and a \tcode{refs}
argument, which is passed to the base class constructor.
\removed{Each such facet also provides a constructor that takes a
\tcode{string} argument \tcode{str} and a \tcode{refs}
argument, which has the same effect as calling the first constructor with the
two arguments \tcode{str.c_str()} and \tcode{refs}.}
If there is no
``$\ldots$\tcode{_byname}''
version of a facet, the base class implements named locale
semantics itself by reference to other facets.

\subsection{23.3.1.2 \tcode{locale} constructors and destructor [locale.cons]}
Change p4 to p11 as follows. Note: since locale must store the passed string_view string value internally (as a string), it is not an issue, if it is not a NTBS.:

%%%\indexlibrary{\idxcode{locale}!constructor}%
\begin{itemdecl}
explicit locale(@\removed{const char*}\added{string_view}@ std_name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a locale using standard C locale names, e.g., \tcode{"POSIX"}.
The resulting locale implements semantics defined to be associated
with that name.

\pnum
\throws
\tcode{runtime_error}
if the argument is not valid\removed{, or is null}.

\pnum
\remarks
The set of valid string argument values is \tcode{"C"\added{sv}}, \tcode{""\added{sv}},
and any \impldef{locale names} values.
\end{itemdescr}

\begin{removedblock}
%%%\indexlibrary{\idxcode{locale}!constructor}%
\begin{itemdecl}
explicit locale(const string& std_name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The same as \tcode{locale(std_name.c_str())}.
\end{itemdescr}
\end{removedblock}

%%%\indexlibrary{\idxcode{locale}!constructor}%
\begin{itemdecl}
locale(const locale& other, @\removed{const char*}\added{string_view}@ std_name, category);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a locale as a copy of
\tcode{other}
except for the facets identified by the
\tcode{category}
argument, which instead implement the same semantics as
\tcode{locale(std_name)}.

\pnum
\throws
\tcode{runtime_error}
if the argument is not valid\removed{, or is  null}.

\pnum
\remarks
The locale has a name if and only if
\tcode{other}
has a name.
\end{itemdescr}
\begin{removedblock}
%%%\indexlibrary{\idxcode{locale}!constructor}%
\begin{itemdecl}
locale(const locale& other, const string& std_name, category cat);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The same as \tcode{locale(other, std_name.c_str(), cat)}.
\end{itemdescr}
\end{removedblock}

\subsection{25.3.1.3 \tcode{locale} members [locale.members]}
Change p5 as follows:

%%\indexlibrarymember{locale}{name}%
\begin{itemdecl}
basic_string<char> name() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The name of
\tcode{*this},
if it has one; otherwise, the string \tcode{"*"}.
If
\tcode{*this}
has a name, then
\tcode{locale(name()\removed{.\brk{}c\textunderscore{}str()})}
is equivalent to
\tcode{*this}.
Details of the contents of the resulting string are otherwise \impldef{return value of \tcode{locale::name}}.
\end{itemdescr}

\subsection{25.3.1.4 \tcode{locale} operators [locale.operators]}
Change the definition of \tcode{operator()} p3-p5 as follows:

%\indexlibrarymember{locale}{operator()}%
\begin{itemdecl}
template <class charT, class traits@del{, class Allocator}@>
  bool operator()(@\removed{const }@basic_string@\added{_view}@<charT,traits@\removed{,Allocator}@>@\removed{\&}@ s1,
                  @\removed{const }@basic_string@\added{_view}@<charT,traits@\removed{,Allocator}@>@\removed{\&}@ s2) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Compares two strings according to the
\tcode{collate<charT>}
facet.

\pnum
\remarks
This member operator template (and therefore
\tcode{locale}
itself) satisfies requirements for a comparator predicate template argument
(Clause~\ref{algorithms}) applied to strings.

\pnum
\returns
The result of the following expression:

\begin{codeblock}
use_facet< collate<charT> >(*this).compare
  (s1.data(), s1.data()+s1.size(), s2.data(), s2.data()+s2.size()) < 0;
\end{codeblock}
\end{itemdescr}

\subsection{25.3.3.2.2 string conversions [conversions.string]}
While there is potential to remove some of the overloads of \tcode{wstring_convert}'s member functions, I refrain from proposing a change, because I feel not be able to judge the potential impact. At least the reduction from 4 to 3 overloads each, seems to be achievable.

\subsection{ ``$\ldots$\tcode{_byname}'' class templates }
For each of the following class templates referred in the following as \tcode{xxx_byname} with its corresponding base class template referred to as \tcode{xxx_base}
\begin{itemize}
\item \tcode{ctype_byname} (25.4.1.2 [locale.ctype.byname])
\item \tcode{codecvt_byname} (25.4.1.5 [locale.codecvt.byname])
\item \tcode{numpunct_byname} (25.4.3.2 [locale.numpunct.byname])
\item \tcode{collate_byname} (25.4.4.2 [locale.collate.byname])
\item \tcode{time_get_byname} (25.4.5.2 [locale.time.get.byname])
\item \tcode{time_put_byname} (25.4.5.4 [locale.time.put.byname])
\item \tcode{moneypunct_byname} (25.4.6.4 [locale.moneypunct.byname])
\item \tcode{messages_byname} (25.4.7.2 [locale.messages.byname])
\end{itemize}
replace the overloaded explicit constructors as follows

\begin{codeblock}
namespace std {
  template <@$\ldots$@>
  class xxx_byname : public xxx_base {
  public:
    // other members, if any
    @\removed{explicit xxx_byname(const char*, size_t refs = 0);}@
    explicit xxx_byname(@\removed{const }@string@\added{_view}\removed{\&}@, size_t refs = 0);
  protected:
   ~xxx_byname();
  };
}
\end{codeblock}

%%%%%%%%%
\section{30.7.1 Overview [iostream.format.overview]}
Change the header \tcode{<iomanip>}'s synopsis as follows:

\begin{codeblock}
namespace std {
  // types \tcode{T1}, \tcode{T2}, ... are unspecified implementation types
  @\textit{T1}@ resetiosflags(ios_base::fmtflags mask);
  @\textit{T2}@ setiosflags  (ios_base::fmtflags mask);
  @\textit{T3}@ setbase(int base);
  template<charT> @\textit{T4}@ setfill(charT c);
  @\textit{T5}@ setprecision(int n);
  @\textit{T6}@ setw(int n);
  template <class moneyT> @\textit{T7}@ get_money(moneyT& mon, bool intl = false);
  template <class moneyT> @\textit{T8}@ put_money(const moneyT& mon, bool intl = false);
  template <class charT> @\textit{T9}@ get_time(struct tm* tmb, const charT* fmt);
  template <class charT> @\textit{T10}@ put_time(const struct tm* tmb, const charT* fmt);
\end{codeblock}
\begin{removedblock}
\begin{codeblock}
  template <class charT>
    @\textit{T11}@ quoted(const charT* s, charT delim = charT('"'), charT escape = charT('\\'));
  template <class charT, class traits, class Allocator>
    @\textit{T12}@ quoted(const basic_string<charT, traits, Allocator>& s,
    @\itcorr@           charT delim = charT('"'), charT escape = charT('\\'));
\end{codeblock}
\end{removedblock}
\begin{addedblock}
\begin{codeblock}
    @\textit{T11}@ quoted(string_view s,
    @\itcorr@           char delim = '"', char escape = '\\');

    @\textit{T12}@ quoted(wstring_view s,
    @\itcorr@           wchar_t delim = L'"', wchar_t escape = L'\\');
\end{codeblock}
\end{addedblock}
\begin{codeblock}
  template <class charT, class traits, class Allocator>
    @\textit{T13}@ quoted(basic_string<charT, traits, Allocator>& s,
    @\itcorr@           charT delim = charT('"'), charT escape = charT('\\'));

\end{codeblock}
\begin{removedblock}
\begin{codeblock}
  template <class charT, class traits>
    @\textit{T14}@ quoted(basic_string_view<charT, traits> s,
    @\itcorr@           charT delim = charT('"'), charT escape = charT('\\'));
\end{codeblock}
\end{removedblock}
\begin{codeblock}
}
\end{codeblock}
\subsection{30.7.6 Quoted manipulators[quoted.manip]}
Change the specification for the output manipulator as follows:
\begin{removedblock}
\begin{itemdecl}
template <class charT>
  @\unspec@ quoted(const charT* s, charT delim = charT('"'), charT escape = charT('\\'));
template <class charT, class traits, class Allocator>
  @\unspec@ quoted(const basic_string<charT, traits, Allocator>& s,
  @\itcorr@                   charT delim = charT('"'), charT escape = charT('\\'));
template <class charT, class traits>
  @\unspec@ quoted(basic_string_view<charT, traits> s,
  @\itcorr@                   charT delim = charT('"'), charT escape = charT('\\'));
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
\begin{itemdecl}
  @\unspec@ quoted(string_view s,
  @\itcorr@                   char delim = '"', char escape = '\\');
  @\unspec@ quoted(wstring_view s,
  @\itcorr@                   wchar_t delim = L'"', wchar_t escape = L'\\');
\end{itemdecl}
\end{addedblock}


\begin{itemdescr}
\pnum
\returns An object of unspecified type such that if \tcode{out} is an instance
of \tcode{basic_ostream} with \added{corresponding} member type\added{s} \tcode{char_type} 
\removed{the same as
\tcode{charT}} and \removed{with member type} \tcode{traits_type}\added{ as the type of parameter \tcode{s}}\removed{, which in the second and third
form is the same as \tcode{traits}}, then the expression
\tcode{out << quoted(s, delim, escape)}
behaves as a formatted output function~(\ref{ostream.formatted.reqmts})
of \tcode{out}. This forms a character sequence \tcode{seq}, initially
consisting of the following elements:
\begin{itemize}
\item \tcode{delim}.
\item Each character in \tcode{s}. If the character to be output is equal to
\tcode{escape} or \tcode{delim}, as determined by \tcode{traits_type::eq}, first
output \tcode{escape}.
\item \tcode{delim}.
\end{itemize}
Let \tcode{x} be the number of elements initially in \tcode{seq}.
Then padding is determined for \tcode{seq} as described
in~\ref{ostream.formatted.reqmts}, \tcode{seq} is inserted as if by calling
\tcode{out.rdbuf()->sputn(seq, n)}, where \tcode{n} is the larger of
\tcode{out.width()} and \tcode{x}, and \tcode{out.width(0)} is called.
The expression \tcode{out << quoted(s, delim, escape)} shall have type
\tcode{basic_ostream<charT, traits>\&} and value \tcode{out}.
\end{itemdescr}


%%%%%%%%%%%%%%%%%
\section{ 31 Regular Expression library  [re]}%
Changes here get a bit more involved, so it might not be wise to adopt this for C++17, unless there is implementation experience. However, I try my best to go ahead with it. 

My analysis brought up the following areas that could be simplified by using \tcode{string_view} instead of 2 or more overloads with \tcode{char const *} and \tcode{basic_string<C,T,A> const \&}:
\begin{itemize}
\item 31.4. and 31.9.2 \tcode{sub_match} comparison operators (including \tcode{char} only, 3 overloads to 1 overload)
\item 31.4 and 31.11.2 \tcode{regex_match} constructor overloads
\item 31.4 and 31.11.3 \tcode{regex_search} overloads
\item 31.4 and 31.11.4 \tcode{regex_replace} overloads
\item 31.8 \tcode{basic_regex} constructor overloads, \tcode{operator=()} and \tcode{assign()} overloads
\item 31.10 \tcode{match_results::format()} overloads
\end{itemize}


\subsection{31.4 Header \tcode{<regex>} synopsis [re.syn]}
In the namespace std of the header synopsis, apply the following marked changes. Note, unchanged parts are deliberately omitted to keep this paper of a manageable size.

Adjust the declarations of the free function sub_match comparison operators after the comment \tcode{// 31.9.2 sub_match non-member operators:} as follows.

For each comparison operator function template taking a \tcode{basic_string} by const reference as one of its parameter types, replace it with one taking a \tcode{basic_string_view} parameter in the same position instead. Remove all comparison operator function taking a \tcode{typename iterator_traits<BiIter>::value_type const*} parameter. The latter will be subsumed by the new string_view overloads. There is no change to the free comparison operator function templates taking a \tcode{typename iterator_traits<BiIter>::value_type const \&}. This should result in the following changes:

\begin{addedblock}
\begin{codeblock}
  template <class BiIter, class ST> 
    bool operator==(
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST> 
    bool operator!=(
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST> 
    bool operator<(
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST> 
    bool operator>(
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST> 
    bool operator>=(
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST> 
    bool operator<=(
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> lhs,
      const sub_match<BiIter>& rhs);

  template <class BiIter, class ST> 
    bool operator==(
      const sub_match<BiIter>& lhs,
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> rhs);
  template <class BiIter, class ST> 
    bool operator!=(
      const sub_match<BiIter>& lhs,
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> rhs);
  template <class BiIter, class ST> 
    bool operator<(
      const sub_match<BiIter>& lhs,
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> rhs);
  template <class BiIter, class ST> 
    bool operator>(
      const sub_match<BiIter>& lhs,
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> rhs);
  template <class BiIter, class ST> 
    bool operator>=(
      const sub_match<BiIter>& lhs,
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> rhs);
  template <class BiIter, class ST> 
    bool operator<=(
      const sub_match<BiIter>& lhs,
      basic_string_view<
        typename iterator_traits<BiIter>::value_type, ST> rhs);

\end{codeblock}
\end{addedblock}

\begin{removedblock}
\begin{codeblock}
  template <class BiIter, class ST, class SA> 
    bool operator==(
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator!=(
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator<(
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator>(
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator>=(
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
      const sub_match<BiIter>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator<=(
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
      const sub_match<BiIter>& rhs);

  template <class BiIter, class ST, class SA> 
    bool operator==(
      const sub_match<BiIter>& lhs,
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator!=(
      const sub_match<BiIter>& lhs,
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator<(
      const sub_match<BiIter>& lhs,
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator>(
      const sub_match<BiIter>& lhs,
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator>=(
      const sub_match<BiIter>& lhs,
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
  template <class BiIter, class ST, class SA> 
    bool operator<=(
      const sub_match<BiIter>& lhs,
      const basic_string<
        typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);

  template <class BiIter> 
    bool operator==(typename iterator_traits<BiIter>::value_type const* lhs, 
                    const sub_match<BiIter>& rhs); 
  template <class BiIter> 
    bool operator!=(typename iterator_traits<BiIter>::value_type const* lhs, 
                    const sub_match<BiIter>& rhs); 
  template <class BiIter> 
    bool operator<(typename iterator_traits<BiIter>::value_type const* lhs, 
                   const sub_match<BiIter>& rhs); 
  template <class BiIter> 
    bool operator>(typename iterator_traits<BiIter>::value_type const* lhs, 
                   const sub_match<BiIter>& rhs); 
  template <class BiIter> 
    bool operator>=(typename iterator_traits<BiIter>::value_type const* lhs, 
                    const sub_match<BiIter>& rhs); 
  template <class BiIter> 
    bool operator<=(typename iterator_traits<BiIter>::value_type const* lhs, 
                    const sub_match<BiIter>& rhs); 

  template <class BiIter> 
    bool operator==(const sub_match<BiIter>& lhs, 
                    typename iterator_traits<BiIter>::value_type const* rhs); 
  template <class BiIter> 
    bool operator!=(const sub_match<BiIter>& lhs, 
                    typename iterator_traits<BiIter>::value_type const* rhs); 
  template <class BiIter> 
    bool operator<(const sub_match<BiIter>& lhs, 
                   typename iterator_traits<BiIter>::value_type const* rhs); 
  template <class BiIter> 
    bool operator>(const sub_match<BiIter>& lhs, 
                   typename iterator_traits<BiIter>::value_type const* rhs); 
  template <class BiIter> 
    bool operator>=(const sub_match<BiIter>& lhs, 
                    typename iterator_traits<BiIter>::value_type const* rhs); 
  template <class BiIter> 
    bool operator<=(const sub_match<BiIter>& lhs, 
                    typename iterator_traits<BiIter>::value_type const* rhs); 
\end{codeblock}
\end{removedblock}

In the code section following the comment \tcode{// 31.11.2 function template regex_match} apply the following changes:

\begin{codeblock}
  template <class BidirectionalIterator, class Allocator,
      class charT, class traits>
    bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                     match_results<BidirectionalIterator, Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template <class BidirectionalIterator, class charT, class traits>
  bool regex_match(BidirectionalIterator first, BidirectionalIterator last,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  template <class ST, class Allocator, class charT, class traits>
    bool regex_match(basic_string_view<charT, ST> s,
                     match_results<
                       typename basic_string_view<charT, ST>::const_iterator,
                       Allocator>& m, 
                     const basic_regex<charT, traits>& e, 
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
\end{codeblock}
\end{addedblock}
\begin{removedblock}
\begin{codeblock}
  template <class charT, class Allocator, class traits>
    bool regex_match(const charT* str, match_results<const charT*, Allocator>& m,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template <class ST, class SA, class Allocator, class charT, class traits>
    bool regex_match(const basic_string<charT, ST, SA>& s,
                     match_results<
                       typename basic_string<charT, ST, SA>::const_iterator, 
                       Allocator>& m, 
                     const basic_regex<charT, traits>& e, 
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
\end{codeblock}
\end{removedblock}
\begin{codeblock}
  template <class ST, class SA, class Allocator, class charT, class traits> 
    bool regex_match(const basic_string<charT, ST, SA>&&, 
                     match_results<
                       typename basic_string<charT, ST, SA>::const_iterator, 
                       Allocator>&, 
                     const basic_regex<charT, traits>&, 
                     regex_constants::match_flag_type = 
                       regex_constants::match_default) = delete;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  template <class ST, class charT, class traits>
    bool regex_match(basic_string_view<charT, ST> s,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);


\end{codeblock}
\end{addedblock}
\begin{removedblock}
\begin{codeblock}
  template <class charT, class traits>
    bool regex_match(const charT* str,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);
  template <class ST, class SA, class charT, class traits>
    bool regex_match(const basic_string<charT, ST, SA>& s,
                     const basic_regex<charT, traits>& e,
                     regex_constants::match_flag_type flags =
                       regex_constants::match_default);


\end{codeblock}
\end{removedblock}

In the code section following the comment \tcode{// 31.11.3 function template regex_search} apply the following changes:
\begin{codeblock}
  template <class BidirectionalIterator, class Allocator,
      class charT, class traits>
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      match_results<BidirectionalIterator, Allocator>& m,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template <class BidirectionalIterator, class charT, class traits>
    bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}                        
  template <class ST, class charT, class traits>
    bool regex_search(basic_string_view<charT, ST> s,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template <class ST, class Allocator, class charT, class traits>
    bool regex_search(basic_string_view<charT, ST> s,
                      match_results<
                        typename basic_string_view<charT, ST>::const_iterator, 
                        Allocator>& m,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
\end{codeblock}
\end{addedblock}
\begin{removedblock}
\begin{codeblock}                        
  template <class charT, class Allocator, class traits>
    bool regex_search(const charT* str,
                      match_results<const charT*, Allocator>& m,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template <class charT, class traits>
    bool regex_search(const charT* str,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template <class ST, class SA, class charT, class traits>
    bool regex_search(const basic_string<charT, ST, SA>& s,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
  template <class ST, class SA, class Allocator, class charT, class traits>
    bool regex_search(const basic_string<charT, ST, SA>& s,
                      match_results<
                        typename basic_string<charT, ST, SA>::const_iterator, 
                        Allocator>& m,
                      const basic_regex<charT, traits>& e,
                      regex_constants::match_flag_type flags =
                        regex_constants::match_default);
\end{codeblock}
\end{removedblock}
\begin{codeblock}                                         
  template <class ST, class SA, class Allocator, class charT, class traits> 
    bool regex_search(const basic_string<charT, ST, SA>&&, 
                      match_results<
                        typename basic_string<charT, ST, SA>::const_iterator, 
                        Allocator>&, 
                      const basic_regex<charT, traits>&, 
                      regex_constants::match_flag_type = 
                        regex_constants::match_default) = delete;
\end{codeblock}
In the code section following the comment \tcode{// 31.11.4 function template regex_replace} apply the following changes (Note, that here we might use a feature, specifying the allocator for the returned string to be given by the string's allocator. We might consider only replacing the character pointer versions):
\begin{addedblock}
\begin{codeblock}
  template <class OutputIterator, class BidirectionalIterator,
      class traits, class charT, class ST>
    OutputIterator 
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex<charT, traits>& e,
                  basic_string_view<charT, ST> fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
\end{codeblock}
\end{addedblock}
\begin{removedblock}
\begin{codeblock}
  template <class OutputIterator, class BidirectionalIterator,
      class traits, class charT, class ST, class SA>
    OutputIterator 
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex<charT, traits>& e,
                  const basic_string<charT, ST, SA>& fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template <class OutputIterator, class BidirectionalIterator,
      class traits, class charT>
    OutputIterator
    regex_replace(OutputIterator out,
                  BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex<charT, traits>& e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
\end{codeblock}
\end{removedblock}
\begin{addedblock}
\begin{codeblock}                        
  template <class traits, class charT, class ST, class SA,
      class FST>
    basic_string<charT, ST, SA>
    regex_replace(const basic_string<charT, ST, SA>& s,
                  const basic_regex<charT, traits>& e,
                  basic_string_view<charT, FST> fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default); // optional to allow specifying allocator
                    
  template <class traits, class charT, class ST, 
      class FST>
    basic_string<charT, ST>
    regex_replace(basic_string_view<charT, ST> s,
                  const basic_regex<charT, traits>& e,
                  basic_string_view<charT, FST> fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
\end{codeblock}
\end{addedblock}
\begin{removedblock}
\begin{codeblock}                        
  template <class traits, class charT, class ST, class SA,
      class FST, class FSA>
    basic_string<charT, ST, SA>
    regex_replace(const basic_string<charT, ST, SA>& s,
                  const basic_regex<charT, traits>& e,
                  const basic_string<charT, FST, FSA>& fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template <class traits, class charT, class ST, class SA>
    basic_string<charT, ST, SA>
    regex_replace(const basic_string<charT, ST, SA>& s,
                  const basic_regex<charT, traits>& e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template <class traits, class charT, class ST, class SA>
    basic_string<charT>
    regex_replace(const charT* s,
                  const basic_regex<charT, traits>& e,
                  const basic_string<charT, ST, SA>& fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);
  template <class traits, class charT>
    basic_string<charT>
    regex_replace(const charT* s,
                  const basic_regex<charT, traits>& e,
                  const charT* fmt,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default);

\end{codeblock}
\end{removedblock}

\subsection{31.8 Class template \tcode{basic_regex} [re.regex]}

In the class definition in p3 apply the following changes after the comment \tcode{//31.8.2, construct/copy/destroy}:

\begin{codeblock}
    basic_regex();
\end{codeblock}
\begin{removedblock}
\begin{codeblock}
    explicit basic_regex(const charT* p,
      flag_type f = regex_constants::ECMAScript);
\end{codeblock}
\end{removedblock}
%% latex problem with destructor tilde, no idea where it comes from...
\begin{codeblock}                          
    basic_regex(const charT* p, size_t len, flag_type f = regex_constants::ECMAScript);
    basic_regex(const basic_regex&);
    basic_regex(basic_regex&&) noexcept;
    template <class ST@\removed{, class SA}@>
      explicit basic_regex(@\removed{const }@basic_string@\added{_view}@<charT, ST@\removed{, SA}@>@\removed{\&}@ p, 
                           flag_type f = regex_constants::ECMAScript);
    template <class ForwardIterator>
      basic_regex(ForwardIterator first, ForwardIterator last, 
                  flag_type f = regex_constants::ECMAScript);
    basic_regex(initializer_list<charT>,
      flag_type = regex_constants::ECMAScript);
    ~basic_regex();
    basic_regex& operator=(const basic_regex&);
    basic_regex& operator=(basic_regex&&) noexcept;
    @\removed{basic_regex\& operator=(const charT* ptr);}@
    basic_regex& operator=(initializer_list<charT> il);
    template <class ST@\removed{, class SA}@>
      basic_regex& operator=(@\removed{const }@basic_string@\added{_view}@<charT, ST@\removed{, SA}@>@\removed{\&}@ p);

    // 31.8.3, assign:
    basic_regex& assign(const basic_regex& that);
    basic_regex& assign(basic_regex&& that) noexcept;
\end{codeblock}
\begin{removedblock}
\begin{codeblock}
    basic_regex& assign(const charT* ptr,
      flag_type f = regex_constants::ECMAScript);
\end{codeblock}
\end{removedblock}
\begin{codeblock}                          
    basic_regex& assign(const charT* p, size_t len, flag_type f);
    template <class string_traits@\removed{, class A}@>
      basic_regex& assign(@\removed{const }@basic_string@\added{_view}@<charT, string_traits@\removed{, A}@>@\removed{\&}@ s,
                          flag_type f = regex_constants::ECMAScript);
    template <class InputIterator>
      basic_regex& assign(InputIterator first, InputIterator last,
                          flag_type f = regex_constants::ECMAScript);
    basic_regex& assign(initializer_list<charT>,
                        flag_type = regex_constants::ECMAScript);
\end{codeblock}

\subsection{31.8.2 \tcode{basic_regex} constructors[re.regex.construct]}

strike p2 to p5 defining the \tcode{charT} pointer constructor overload. 
Change p14 to p16 as follows:

\begin{itemdecl}
template <class ST@\removed{, class SA}@>
  explicit basic_regex(@\removed{const }@basic_string@\added{_view}@<charT, ST@\removed{, SA}@>@\removed{\&} s,
                       flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws  \tcode{regex_error} if \tcode{s} is not a valid regular expression. 

\pnum
\effects  Constructs an object of class \tcode{basic_regex}; the object's
internal finite state machine is constructed from the regular
expression contained in the string \added{view} \tcode{s}, and interpreted according to the
flags specified in \tcode{f}.

\pnum\postconditions
\tcode{flags()} returns \tcode{f}.  
\tcode{mark_count()} returns the number of marked sub-expressions
within the expression.
\end{itemdescr}

\subsection{31.8.3 \tcode{basic_regex} assign[re.regex.assign]}
Strike p5 and p6 defining operator= for \tcode{charT} pointer and replace p8 as follows:
\begin{removedblock}
\begin{itemdecl}
basic_regex& operator=(const charT* ptr); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires  \tcode{ptr} shall not be a null pointer. 

\pnum
\effects Returns \tcode{assign(ptr)}.
\end{itemdescr}
\end{removedblock}

\begin{itemdecl}
template <class ST@\removed{, class SA}@>
  basic_regex& operator=(@\removed{const }@basic_string@\added{_view}@<charT, ST@\removed{, SA}@>@\removed{\&} p); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Returns \tcode{assign(p)}.
\end{itemdescr}

Strike p13 and modify p15-18 as follows (note we keep the charT pointer, length assign function overload):
\begin{removedblock}
\begin{itemdecl}
basic_regex& assign(const charT* ptr, flag_type f = regex_constants::ECMAScript); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns  \tcode{assign(string_type(ptr), f)}.
\end{itemdescr}
\end{removedblock}
%%%%%%%%%\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
basic_regex& assign(const charT* ptr, size_t len,
  flag_type f = regex_constants::ECMAScript);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{assign(string_type(ptr, len), f)}.
\end{itemdescr}

%%%%%%%%%\indexlibrarymember{basic_regex}{assign}%
\begin{itemdecl}
template <class string_traits@\removed{, class A}@>
  basic_regex& assign(@\removed{const }@basic_string@\added{_view}@<charT, string_traits@\removed{, A}@>@\removed{\&}@ s,
                      flag_type f = regex_constants::ECMAScript); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\throws  \tcode{regex_error} if \tcode{s} is not a valid regular expression. 

\pnum
\returns  \tcode{*this}.

\pnum
\effects  Assigns the regular expression contained in the string \added{view}
\tcode{s}, interpreted according the flags specified in \tcode{f}. 
If an exception is thrown, \tcode{*this} is unchanged.  

\pnum
\postconditions
If no exception is thrown,
\tcode{flags()} returns \tcode{f} and \tcode{mark_count()}
returns the number of marked sub-expressions within the expression.
\end{itemdescr}

\section{31.9 Class template \tcode{sub_match} [re.submatch]}
Change the member function compare overloads to take a \tcode{string_view} instead of a pointer or string const reference. For convenience I suggest adding a type alias for that as follows.
\begin{codeblock}
namespace std {
  template <class BidirectionalIterator>
  class sub_match : public std::pair<BidirectionalIterator, BidirectionalIterator> {
  public:
     using value_type      =
             typename iterator_traits<BidirectionalIterator>::value_type;
     using difference_type =
             typename iterator_traits<BidirectionalIterator>::difference_type;
     using iterator        = BidirectionalIterator;
     using string_type     = basic_string<value_type>;
     @\added{using string_view_type     = basic_string_view<value_type>;}@

     bool matched;

     constexpr sub_match();

     difference_type length() const;
     operator string_type() const;
     string_type str() const;

     int compare(const sub_match& s) const;
     int compare(@\removed{const }@string_@\added{view_}@type@\removed{\&}@ s) const;
     @\removed{int compare(const value_type* s) const;}@
  }; 
}
\end{codeblock}
\subsection{31.9.1 \tcode{sub_match} members [re.submatch.members]}
Change p6 as follows and strike p7:

\begin{itemdecl}
int compare(@\removed{const }@string_@\added{view_}@type@\removed{\&}@ s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{str().compare(s)}.
\end{itemdescr}

%%%%%%%%%\indexlibrarymember{sub_match}{compare}%
\begin{removedblock}
\begin{itemdecl}
int compare(const value_type* s) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{str().compare(s)}.
\end{itemdescr}
\end{removedblock}

\subsection{31.9.2 \tcode{sub_match} non-member operators [re.submatch.op]}
Change the section as follows:

%%%%%%%%\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template <class BiIter>
  bool operator==(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(rhs) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator"!=}%
\begin{itemdecl}
template <class BiIter>
  bool operator!=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns \tcode{lhs.compare(rhs) != 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<}%
\begin{itemdecl}
template <class BiIter>
  bool operator<(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(rhs) < 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<=}%
\begin{itemdecl}
template <class BiIter>
  bool operator<=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(rhs) <= 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>=}%
\begin{itemdecl}
template <class BiIter>
  bool operator>=(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(rhs) >= 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>}%
\begin{itemdecl}
template <class BiIter>
  bool operator>(const sub_match<BiIter>& lhs, const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(rhs) > 0}.
\end{itemdescr}

\begin{addedblock}
%%%%%%%%\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator==(
    basic_string_view<
      typename iterator_traits<BiIter>::value_type, ST> lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs.compare(typename sub_match<BiIter>::string_view_type(lhs.data(), lhs.size())) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator"!=}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator!=(
    basic_string_view<
      typename iterator_traits<BiIter>::value_type, ST> lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator<(
    basic_string_view<
      typename iterator_traits<BiIter>::value_type, ST> lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs.compare(typename sub_match<BiIter>::string_view_type(lhs.data(), lhs.size())) > 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator>(
    basic_string_view<
      typename iterator_traits<BiIter>::value_type, ST> lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>=}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator>=(
    basic_string_view<
      typename iterator_traits<BiIter>::value_type, ST> lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<=}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator<=(
    basic_string_view<
      typename iterator_traits<BiIter>::value_type, ST> lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(rhs < lhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator==}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator==(const sub_match<BiIter>& lhs,
                  basic_string_view<
                    typename iterator_traits<BiIter>::value_type, ST> rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(typename sub_match<BiIter>::string_view_type(rhs.data(), rhs.size())) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrary{\idxcode{operator"!=}!\idxcode{sub_match}}%
%%%%%%%%\indexlibrary{\idxcode{sub_match}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator!=(const sub_match<BiIter>& lhs,
                  basic_string_view<
                    typename iterator_traits<BiIter>::value_type, ST> rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrary{\idxcode{operator>}!\idxcode{sub_match}}%
%%%%%%%%\indexlibrary{\idxcode{sub_match}!\idxcode{operator<}}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator<(const sub_match<BiIter>& lhs,
                 basic_string_view<
                   typename iterator_traits<BiIter>::value_type, ST> rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(typename sub_match<BiIter>::string_view_type(rhs.data(), rhs.size())) < 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator>}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator>(const sub_match<BiIter>& lhs,
                 basic_string_view<
                   typename iterator_traits<BiIter>::value_type, ST> rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator>=}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator>=(const sub_match<BiIter>& lhs,
                  basic_string_view<
                    typename iterator_traits<BiIter>::value_type, ST> rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator<=}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST>
  bool operator<=(const sub_match<BiIter>& lhs,
                  basic_string_view<
                    typename iterator_traits<BiIter>::value_type, ST> rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(rhs < lhs)}.
\end{itemdescr}
\end{addedblock}
\begin{removedblock}
%%%%%%%%\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator==(
    const basic_string<
      typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs.compare(typename sub_match<BiIter>::string_type(lhs.data(), lhs.size())) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator"!=}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator!=(
    const basic_string<
      typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator<(
    const basic_string<
      typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs.compare(typename sub_match<BiIter>::string_type(lhs.data(), lhs.size())) > 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator>(
    const basic_string<
      typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>=}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator>=(
    const basic_string<
      typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<=}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator<=(
    const basic_string<
      typename iterator_traits<BiIter>::value_type, ST, SA>& lhs,
    const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(rhs < lhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator==}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator==(const sub_match<BiIter>& lhs,
                  const basic_string<
                    typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(typename sub_match<BiIter>::string_type(rhs.data(), rhs.size())) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrary{\idxcode{operator"!=}!\idxcode{sub_match}}%
%%%%%%%%\indexlibrary{\idxcode{sub_match}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator!=(const sub_match<BiIter>& lhs,
                  const basic_string<
                    typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrary{\idxcode{operator>}!\idxcode{sub_match}}%
%%%%%%%%\indexlibrary{\idxcode{sub_match}!\idxcode{operator<}}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator<(const sub_match<BiIter>& lhs,
                 const basic_string<
                   typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(typename sub_match<BiIter>::string_type(rhs.data(), rhs.size())) < 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator>}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator>(const sub_match<BiIter>& lhs,
                 const basic_string<
                   typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator>=}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator>=(const sub_match<BiIter>& lhs,
                  const basic_string<
                    typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{operator<=}{sub_match}%
\begin{itemdecl}
template <class BiIter, class ST, class SA>
  bool operator<=(const sub_match<BiIter>& lhs,
                  const basic_string<
                    typename iterator_traits<BiIter>::value_type, ST, SA>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(rhs < lhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template <class BiIter> 
  bool operator==(typename iterator_traits<BiIter>::value_type const* lhs, 
                  const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs.compare(lhs) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator"!=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator!=(typename iterator_traits<BiIter>::value_type const* lhs, 
                  const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<(typename iterator_traits<BiIter>::value_type const* lhs, 
                 const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs.compare(lhs) > 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>(typename iterator_traits<BiIter>::value_type const* lhs, 
                 const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>=(typename iterator_traits<BiIter>::value_type const* lhs, 
                  const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<=(typename iterator_traits<BiIter>::value_type const* lhs, 
                  const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(rhs < lhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template <class BiIter> 
  bool operator==(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const* rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(rhs) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator"!=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator!=(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const* rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<(const sub_match<BiIter>& lhs, 
                 typename iterator_traits<BiIter>::value_type const* rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{lhs.compare(rhs) < 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>(const sub_match<BiIter>& lhs, 
                 typename iterator_traits<BiIter>::value_type const* rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>=(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const* rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<=(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const* rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns  \tcode{!(rhs < lhs)}.
\end{itemdescr}
\end{removedblock}
%%%%%%%%\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template <class BiIter> 
  bool operator==(typename iterator_traits<BiIter>::value_type const& lhs, 
                  const sub_match<BiIter>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs.compare(typename sub_match<BiIter>::string_type(1, lhs)) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator"!=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator!=(typename iterator_traits<BiIter>::value_type const& lhs, 
                  const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<(typename iterator_traits<BiIter>::value_type const& lhs, 
                 const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs.compare(typename sub_match<BiIter>::string_type(1, lhs)) > 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>(typename iterator_traits<BiIter>::value_type const& lhs, 
                 const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>=(typename iterator_traits<BiIter>::value_type const& lhs, 
                  const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<=(typename iterator_traits<BiIter>::value_type const& lhs, 
                  const sub_match<BiIter>& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(rhs < lhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator==}%
\begin{itemdecl}
template <class BiIter> 
  bool operator==(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) == 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator"!=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator!=(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs == rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<(const sub_match<BiIter>& lhs, 
                 typename iterator_traits<BiIter>::value_type const& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{lhs.compare(typename sub_match<BiIter>::string_type(1, rhs)) < 0}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>(const sub_match<BiIter>& lhs, 
                 typename iterator_traits<BiIter>::value_type const& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{rhs < lhs}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator>=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator>=(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(lhs < rhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrarymember{sub_match}{operator<=}%
\begin{itemdecl}
template <class BiIter> 
  bool operator<=(const sub_match<BiIter>& lhs, 
                  typename iterator_traits<BiIter>::value_type const& rhs); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(rhs < lhs)}.
\end{itemdescr}

%%%%%%%%\indexlibrary{\idxcode{basic_ostream}}%
%%%%%%%%\indexlibrarymember{sub_match}{operator\shl}%
\begin{itemdecl}
template <class charT, class ST, class BiIter>
  basic_ostream<charT, ST>&
  operator<<(basic_ostream<charT, ST>& os, const sub_match<BiIter>& m); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns  \tcode{(os <{}< m.str())}.
\end{itemdescr}

\section{31.10 Class template \tcode{match_results} [re.results]}
Change the code in the class template after the comment \tcode{//31.10.5, format:} as follows. (Note, I propose a slight semantic change to the existing format returning a string. In the original version this would take the allocator type from the passed in fmt parameter instead of the default allocator, which is used with the character pointer version):

\begin{removedblock}
\begin{codeblock}
     template <class OutputIter>
      OutputIter
      format(OutputIter out,
             const char_type* fmt_first, const char_type* fmt_last,
             regex_constants::match_flag_type flags =
              regex_constants::format_default) const;
\end{codeblock}
\end{removedblock}
\begin{codeblock}
     template <class OutputIter, class ST@\removed{, class SA}@>
       OutputIter
       format(OutputIter out,
              @\removed{const }@basic_string@\added{_view}@<char_type, ST@\removed{, SA}@>@\removed{\&}@ fmt,
              regex_constants::match_flag_type flags =
                regex_constants::format_default) const;
     template <class ST@\removed{, class SA}@>
      @\removed{basic_string<char_type, ST, SA>}\added{string_type}@
      format(@\removed{const }@basic_string@\added{_view}@<char_type, ST@\removed{, SA}@>@\removed{\&}@ fmt,
             regex_constants::match_flag_type flags =
               regex_constants::format_default) const;
\end{codeblock}
\begin{removedblock}
\begin{codeblock}               
     string_type
     format(const char_type* fmt,
            regex_constants::match_flag_type flags =
              regex_constants::format_default) const;


\end{codeblock}
\end{removedblock}

\subsection{31.10.5 \tcode{match_results} formatting [re.results.form]}
I suggest that we lose the option to specify the allocator indirectly by the string type used.
Change p4 to p10 as follows:
\begin{itemdecl}
template <class OutputIter, class ST@\removed{, class SA}@>
  OutputIter format(OutputIter out,
              @\removed{const }@basic_string@\added{_view}@<char_type, ST@\removed{, SA}@>@\removed{\&}@ fmt,
                    regex_constants::match_flag_type flags =
                      regex_constants::format_default) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return format(out, fmt.data(), fmt.data() + fmt.size(), flags);
\end{codeblock}
\end{itemdescr}

%%%%%%%\indexlibrarymember{match_results}{format}%
\begin{itemdecl}
template <class ST@\removed{, class SA}@>
  @\removed{basic_string<char_type, ST, SA>}\added{string_type}@
  format(@\removed{const }@basic_string@\added{_view}@<char_type, ST@\removed{, SA}@>@\removed{\&}@ fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{ready() == true}.

\pnum
\effects
Constructs an empty string \tcode{result} of type \removed{\tcode{basic_string<char_type, ST, SA>}}\added{\tcode{string_type}} and
calls:
\begin{codeblock}
format(back_inserter(result), fmt, flags);
\end{codeblock}

\pnum
\returns\ \tcode{result}.
\end{itemdescr}

\begin{removedblock}
%%%%%%%\indexlibrarymember{match_results}{format}%
\begin{itemdecl}
string_type
  format(const char_type* fmt,
         regex_constants::match_flag_type flags =
           regex_constants::format_default) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{ready() == true}.

\pnum
\effects\ Constructs an empty string \tcode{result} of type \tcode{string_type} and
calls:
\begin{codeblock}
format(back_inserter(result),
       fmt, fmt + char_traits<char_type>::length(fmt), flags);
\end{codeblock}

\pnum
\returns\ \tcode{result}.
\end{itemdescr}
\end{removedblock}

\section{31.11 Regular expression algorithms [re.alg]}
Adjust the changed function apis from the synopsis accordingly.
\subsection{31.11.2 \tcode{regex_match}[re.alg.match]}
Change p5 to p8 as follows:

\begin{removedblock}
%%%%%%\indexlibrary{\idxcode{regex_match}}%
\begin{itemdecl}
template <class charT, class Allocator, class traits>
  bool regex_match(const charT* str,
                   match_results<const charT*, Allocator>& m,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns  \tcode{regex_match(str, str + char_traits<charT>::length(str), m, e, flags)}.
\end{itemdescr}
%%%%%%\indexlibrary{\idxcode{regex_match}}%
\begin{itemdecl}
template <class ST, class SA, class Allocator, class charT, class traits>
  bool regex_match(const basic_string<charT, ST, SA>& s,
                   match_results<
                     typename basic_string<charT, ST, SA>::const_iterator, 
                     Allocator>& m, 
                   const basic_regex<charT, traits>& e, 
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default); 
\end{itemdecl}
\end{removedblock}

\begin{addedblock}
%%%%%%\indexlibrary{\idxcode{regex_match}}%
\begin{itemdecl}
template <class ST, class Allocator, class charT, class traits>
  bool regex_match(basic_string_view<charT, ST> s,
                   match_results<
                     typename basic_string_view<charT, ST>::const_iterator, 
                     Allocator>& m, 
                   const basic_regex<charT, traits>& e, 
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default); 
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\returns  \tcode{regex_match(s.begin(), s.end(), m, e, flags)}.
\end{itemdescr}

\begin{removedblock}
%%%%%%\indexlibrary{\idxcode{regex_match}}%
\begin{itemdecl}
template <class charT, class traits>
  bool regex_match(const charT* str,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns  \tcode{regex_match(str, str + char_traits<charT>::length(str), e, flags)}
\end{itemdescr}

%%%%%%\indexlibrary{\idxcode{regex_match}}%
\begin{itemdecl}
template <class ST, class SA, class charT, class traits>
  bool regex_match(const basic_string<charT, ST, SA>& s,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default); 
\end{itemdecl}

\end{removedblock}
\begin{addedblock}
%%%%%%\indexlibrary{\idxcode{regex_match}}%
\begin{itemdecl}
template <class ST, class charT, class traits>
  bool regex_match(basic_string_view<charT, ST> s,
                   const basic_regex<charT, traits>& e,
                   regex_constants::match_flag_type flags =
                     regex_constants::match_default); 
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\returns  \tcode{regex_match(s.begin(), s.end(), e, flags)}.
\end{itemdescr}

\subsection{31.11.3 \tcode{regex_search}[re.alg.search]}
Change p4 to p5 and p7 to p8 as follows:
%%%%%\indexlibrary{\idxcode{regex_search}}%
\begin{removedblock}
\begin{itemdecl}
template <class charT, class Allocator, class traits>
bool regex_search(const charT* str, match_results<const charT*, Allocator>& m,
                  const basic_regex<charT, traits>& e,
                  regex_constants::match_flag_type flags =
                    regex_constants::match_default); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns  The result of \tcode{regex_search(str, 
str + char_traits<charT>::length(str), m, e, flags)}. 
\end{itemdescr}

%%%%%\indexlibrary{\idxcode{regex_search}}%
\begin{itemdecl}
template <class ST, class SA, class Allocator, class charT, class traits>
  bool regex_search(const basic_string<charT, ST, SA>& s,
                    match_results<
                      typename basic_string<charT, ST, SA>::const_iterator, 
                      Allocator>& m, 
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default); 
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
%%%%%\indexlibrary{\idxcode{regex_search}}%
\begin{itemdecl}
template <class ST, class Allocator, class charT, class traits>
  bool regex_search(basic_string_view<charT, ST> s,
                    match_results<
                      typename basic_string_view<charT, ST>::const_iterator, 
                      Allocator>& m, 
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default); 
\end{itemdecl}
\end{addedblock}
\begin{itemdescr}
\pnum\returns  The result of \tcode{regex_search(s.begin(), s.end(), m,
e, flags)}.
\end{itemdescr}

%%%%%\indexlibrary{\idxcode{regex_search}}%
\begin{itemdecl}
template <class BidirectionalIterator, class charT, class traits>
  bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects  Behaves ``as if'' by constructing an object \tcode{what}
of type \tcode{match_results<BidirectionalIterator>}, and then returning
the result of \tcode{regex_search(first, last, what, e, flags)}.
\end{itemdescr}

\begin{removedblock}
%%%%%\indexlibrary{\idxcode{regex_search}}%
\begin{itemdecl}
template <class charT, class traits>
  bool regex_search(const charT* str,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{regex_search(str, str + char_traits<charT>::length(str), e, flags)}.
\end{itemdescr}

%%%%%\indexlibrary{\idxcode{regex_search}}%
\begin{itemdecl}
template <class ST, class SA, class charT, class traits>
  bool regex_search(const basic_string<charT, ST, SA>& s,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default); 
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
%%%%%\indexlibrary{\idxcode{regex_search}}%
\begin{itemdecl}
template <class ST, class charT, class traits>
  bool regex_search(basic_string_view<charT, ST> s,
                    const basic_regex<charT, traits>& e,
                    regex_constants::match_flag_type flags =
                      regex_constants::match_default); 
\end{itemdecl}
\end{addedblock}
\begin{itemdescr}
\pnum\returns  \tcode{regex_search(s.begin(), s.end(), e, flags)}.
\end{itemdescr}

\subsection{31.11.4 \tcode{regex_replace}[re.alg.replace]}
Change the section as follows:

%%%%\indexlibrary{\idxcode{regex_replace}}%
\begin{itemdecl}
template <class OutputIterator, class BidirectionalIterator,
    class traits, class charT, class ST@\removed{, class SA}@>
  OutputIterator 
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex<charT, traits>& e,
                @\removed{const }@basic_string@\added{_view}@<charT, ST@\removed{, SA}@>@\removed{\&}@ fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
\end{itemdecl}
\begin{removedblock}
\begin{itemdecl}
template <class OutputIterator, class BidirectionalIterator,
    class traits, class charT>
  OutputIterator
  regex_replace(OutputIterator out,
                BidirectionalIterator first, BidirectionalIterator last,
                const basic_regex<charT, traits>& e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
\end{itemdecl}
\end{removedblock}
\begin{itemdescr}
\pnum
%%%%\indexlibrary{\idxcode{format_no_copy}}%
%%%%\indexlibrary{\idxcode{format_first_only}}%
\effects
Constructs a \tcode{regex_iterator} object \tcode{i}
as if by
\begin{codeblock}
regex_iterator<BidirectionalIterator, charT, traits> i(first, last, e, flags)
\end{codeblock}
and uses \tcode{i} to enumerate through all
of the matches \tcode{m} of type \tcode{match_results<BidirectionalIterator>} 
that occur within the sequence \range{first}{last}.
If no such
matches are found and
\tcode{!(flags \& regex_constants::format_no_copy)}, then calls
\begin{codeblock}
out = std::copy(first, last, out)
\end{codeblock}
If any matches are found then, for each such match:
\begin{itemize}
\item
If \tcode{!(flags \& regex_constants::format_no_copy)}, calls 
\begin{codeblock}
out = std::copy(m.prefix().first, m.prefix().second, out)
\end{codeblock}
\item
Then calls
\begin{codeblock}
out = m.format(out, fmt, flags)
\end{codeblock}
\removed{for the first form of the function and}
\begin{removedblock}
\begin{codeblock}
out = m.format(out, fmt, fmt + char_traits<charT>::length(fmt), flags)
\end{codeblock}
\end{removedblock}
\removed{for the second.}
\end{itemize}
Finally, if such a match
is found and \tcode{!(flags \& regex_constants::format_no_copy)},
calls
\begin{codeblock}
out = std::copy(last_m.suffix().first, last_m.suffix().second, out)
\end{codeblock}
where \tcode{last_m} is a copy of the last match
found. If \tcode{flags \& regex_constants::format_first_only} 
is non-zero, then only the first match found is replaced.

\pnum\returns  \tcode{out}.
\end{itemdescr}

%%%%\indexlibrary{\idxcode{regex_replace}}%
\begin{itemdecl}
template <class traits, class charT, class ST, class SA, class FST@\removed{, class FSA}@>
  basic_string<charT, ST, SA>
  regex_replace(const basic_string<charT, ST, SA>& s,
                const basic_regex<charT, traits>& e,
                @\removed{const }@basic_string@\added{_view}@<charT, FST@\removed{, FSA}@>@\removed{\&}@ fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default); 
\end{itemdecl}
\begin{removedblock}
\begin{itemdecl}                  
template <class traits, class charT, class ST, class SA>
  basic_string<charT, ST, SA>
  regex_replace(const basic_string<charT, ST, SA>& s,
                const basic_regex<charT, traits>& e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
\end{itemdecl}
\end{removedblock}
\begin{itemdescr}
\pnum\effects  Constructs an empty string \tcode{result} of
type \tcode{basic_string<charT, ST , SA>} and calls: 
\begin{codeblock}
regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags);
\end{codeblock}

\pnum
\returns\ \tcode{result}.
\end{itemdescr}
%%%%\indexlibrary{\idxcode{regex_replace}}%
\begin{itemdecl}
template <class traits, class charT, class ST, class @\removed{SA}\added{FST}@>
  basic_string<charT>
  regex_replace(@\removed{const }\added{basic_string_view<}@charT@\added{,ST>}\removed{*}@ s,
                const basic_regex<charT, traits>& e,
                @\removed{const }@basic_string@\added{_view}@<charT, @\added{FST}\removed{ST, SA}@>@\removed{\&}@ fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
\end{itemdecl}
\begin{removedblock}
\begin{itemdecl}
template <class traits, class charT>
  basic_string<charT>
  regex_replace(const charT* s,
                const basic_regex<charT, traits>& e,
                const charT* fmt,
                regex_constants::match_flag_type flags =
                  regex_constants::match_default);
\end{itemdecl}
\end{removedblock}

\begin{itemdescr}
\pnum
\effects  Constructs an empty string \tcode{result} of
type \tcode{basic_string<charT}\added{\tcode{,ST}}\tcode{>} and calls: 
\begin{codeblock}
regex_replace(back_inserter(result),
              s, s + char_traits<charT>::length(s), e, fmt, flags);
\end{codeblock}

\pnum
\returns\ \tcode{result}.
\end{itemdescr}



\end{document}

