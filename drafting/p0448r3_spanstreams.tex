\documentclass[ebook,11pt,article]{memoir}
\usepackage{geometry}  % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}  % ... or a4paper or a5paper or ... 
%\geometry{landscape}  % Activate for for rotated page geometry
%%% from std.tex
%\usepackage[american]
%           {babel}        % needed for iso dates
%\usepackage[iso,american]
%           {isodate}      % use iso format for dates
\usepackage[final]
           {listings}     % code listings
\usepackage{longtable}    % auto-breaking tables
\usepackage{ltcaption}    % fix captions for long tables
\usepackage{relsize}      % provide relative font size changes
%\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{underscore}   % remove special status of '_' in ordinary text
%\usepackage{parskip}      % handle non-indented paragraphs "properly"
%\usepackage{array}        % new column definitions for tables
\usepackage[normalem]{ulem}
\usepackage{enumitem}
\usepackage{color}        % define colors for strikeouts and underlines
%\usepackage{amsmath}      % additional math symbols
%\usepackage{mathrsfs}     % mathscr font
\usepackage[final]{microtype}
%\usepackage{multicol}
\usepackage{xspace}
%\usepackage{lmodern}
\usepackage[T1]{fontenc} % makes tilde work! and is better for umlauts etc.
%\usepackage[pdftex, final]{graphicx}
\usepackage[pdftex,
%            pdftitle={C++ International Standard},
%            pdfsubject={C++ International Standard},
%            pdfcreator={Richard Smith},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}
%\usepackage{memhfixc}     % fix interactions between hyperref and memoir
%\usepackage[active,header=false,handles=false,copydocumentclass=false,generate=std-gram.ext,extract-cmdline={gramSec},extract-env={bnftab,simplebnf,bnf,bnfkeywordtab}]{extract} % Grammar extraction
%
\renewcommand\RSsmallest{5.5pt}  % smallest font size for relsize


%%%% reuse all four from std.tex:
\input{layout}
\input{styles}
\input{macros}
\input{tables}

\renewcommand{\iref}[1]{[#1]}


\pagestyle{myheadings}

\newcommand{\papernumber}{d0448r3}
\newcommand{\paperdate}{2020-12-07}

\markboth{\papernumber{} \paperdate{}}{\papernumber{} \paperdate{}}

\title{\papernumber{} - A strstream replacement using span\textless{}charT\textgreater{} as buffer}
\author{Peter Sommerlad}
\date{\paperdate}                % Activate to display a given date or no date
\setsecnumdepth{subsection}

\begin{document}
\maketitle
\begin{center}
\begin{tabular}[t]{|l|l|}\hline 
Document Number:&  \papernumber \hfill (N2065 done right?)\\\hline
Date: & \paperdate \\\hline
Project: & Programming Language C++\\\hline 
Audience: & LEWG/LWG\\\hline
\end{tabular}
\end{center}
\chapter{History}
Streams have been the oldest part of the C++ standard library and especially strstreams that can use pre-allocated buffers have been deprecated for a long time now, waiting for a replacement. p0407 and p0408 provide the efficient access to the underlying buffer for stringstreams that strstream provided solving half of the problem that strstreams provide a solution for. The other half is using a fixed size pre-allocated buffer, e.g., allocated on the stack, that is used as the stream buffers internal storage.

A combination of external-fixed and internal-growing buffer allocation that strstreambuf provides is IMHO a doomed approach and very hard to use right.

There had been a proposal for the pre-allocated external memory buffer streams in N2065 but that went nowhere. Today, with \tcode{span<T>} we actually have a library type representing such buffers views we can use for specifying (and implementing) such streams. They can be used in areas where dynamic (re-)allocation of stringstreams is not acceptable but the burden of caring for a pre-existing buffer during the lifetime of the stream is manageable. 

\section{Changes from p0448r2}
Based on the review of p0408 in Cologne 2019, some adjustments were made here accordingly to the feedback given there.
\begin{itemize}
\item update editorial advise to include header and feature test macro, as well as the section number to 29.
\item made wording adjustments like suggested for p0408 in Cologne 2019 by LWG in the hope to make reviewing it faster.
\item removed mentioning a template parameter Extent in all uses of span.
\item tried to fix the adopted wording (from \tcode{basic_stringbuf}) wrt seekoff by removing tables in favor of words.
\item removed impossible to achieve \tcode{noexcept} from move and swap operations.
\item some more email and review feedback from LWG telecon (spelling, spacing, etc).
\item rephrased constructor wording to read more modern (Initializes vs constructs).
\end{itemize}


\section{Changes from p0448r1}
There was email discussion (Alisdair, Marshall, Titus and library mailing list) on semantics of move, timing and wording of strstream removal. Therefore, this paper needs to be reconsidered with that design respect by LEWG. I also acquired an additional paper number for a paper to propose the strstream removal, so I drop it from here.

Marshall gave a list of review comments, I'd like to answer below:
\begin{itemize}

\item  
The synopsis shows these classes in std::experimental, while the class descriptions show std:: only.
\textit{fixed, copy relict}.
\item  
The synopsis should probably \#include <span> and <string>, since that's where span and char_traits come from.
\textit{yes to <span> not to <string> since the base class basic_streambuf already has a dependency to char_traits, so no gain from mentioning <string>, but including <streambuf> might be shown. Fixed. However, I found no precedence to such include directives for stream classes in n4791 (may be a more modern style of specification introduced with C++11. I guess mentioning a required identifier encourages implementors to make its definition available. }
\item 
Why a separate <spanstream> header? why not just put it in one of the existing ones? 
       (we're adding headers at a surprising - to me - rate)
\textit{First, because strstreams are also in their separate header. Second, LEWG blessed/asked for it.
Third, the base class already has the dependency to char_traits.}
\item  7.4.2/1 is really generic: "Move assigns the base and members of *this from the base and corresponding members of rhs."
\textit{These words are almost identical to basic_istringstream move assignment. Took the challenge and now use (more) code.}
\item  7.4.2/2 is mixing prose and code; I suspect it would be better just as code. "Effects Equivalent to: <two lines of code>"
\textit{almost identical to basic_istringstream::swap wording. see above.}
\item  Is the span that you pass to the constructors required to be non-empty?  setbuf does have that requirement.
\textit{The latter is not really true: setbuf() is defined per streambuf subclass and we are free to define it any way. most subclasses say that setbuf(0,0) has no effect, filebuf makes I/O unbuffered and all say any other combination has implementation defined behavior. I do not require a non-empty span, the stream is then just not particularly useful, except to behave as a null object.}
\end{itemize}

Alisdair raised the question if the spanbuf move operations should actually disassociate the buffer/stream from the original span, like (all?) other streambuf subclasses to when moved from. 
\begin{quote}
{"I have a huge concern about the definition of move construction and move assignment
for basic_spanbuf.  The reason is that this is simply a copy operation, but we allowed
move semantics on streams/buffers following the unique ownership principle.  In other
words, it would be very surprising that writing to the move-from stream would have any
impact on the moved-to stream."}
\end{quote}

Titus had the counter argument that one should not spend cycles on cleaning up moved from objects.
 
The streambuf base class can only be copied. filebuf and stringbuf both disassociate the right hand side from its underlying data source that they both own. strstreambuf does neither support move or copy. 

I am torn, so I made that implementation defined.

Now to what really changed...
\begin{itemize}
\item rebase to n4791
\item removed superfluous experimental namespace from synopsis
\item added header includes in header synopsis for <streambuf> and <span> (even so no other iostream headers seem to do so).
\item introduce an exposition-only member \tcode{span<charT> buf} representing the span. This will make wording, especially of move constructor more clear. 
\item make the wording of the move constructor more clear instead of hand waving about "locale and other state of rhs".
\item make wording of spanbuf/streams's members more clear by code instead of weasel wording obtained from stringbuf/streams.
\item TODO
\end{itemize}



\section{Changes from p0448r0}
\begin{itemize}
\item provide explanation why non-copy-ability, while technically feasible, is an OK thing.
\item remove wrong Allocator template parameter (we never allocate anything).
\item adhere to new section numbering of the standard.
\item tried to clarify lifetime and threading issues.
\end{itemize}


\chapter{Introduction}
This paper proposes a class template \tcode{basic_spanbuf} and the corresponding stream class templates to enable the use of streams on externally provided memory buffers. No ownership or re-allocation support is given. For those features we have string-based streams.

\chapter{Acknowledgements}
\begin{itemize}
\item Thanks to those ISO C++ meeting members attending the Oulu meeting encouring me to write this proposal. I believe Neil and Pablo have been among them, but can't remember who else.
\item Thanks go to Jonathan Wakely who pointed the problem of \tcode{strstream} out to me and to Neil Macintosh to provide the span library type specification.
\item Thanks to Felix Morgner for proofreading.
\item Thanks to Kona LEWG small group discussion suggesting some clarifications and Thomas K\"oppe for allowing me to use using type aliases instead of \tcode{typedef}.
\item Thanks to remote LWG meeting December 2020 and surrounding email feedback by Jeff Garland, Tim Song, Jens Maurer, Volle Voutilainen
\end{itemize}

\chapter{Motivation}
To finally get rid of the deprecated \tcode{strstream} in the C++ standard we need a replacement. p0407/p0408 provide one for one half of the needs for \tcode{strstream}. This paper provides one for the second half: fixed sized buffers. 

\begin{example} reading input from a fixed pre-arranged character buffer:
\begin{codeblock}
char input[] = "10 20 30";
ispanstream is{span<char>{input}};
int i;
is >> i;
ASSERT_EQUAL(10,i);
is >> i;
ASSERT_EQUAL(20,i);
is >> i;
ASSERT_EQUAL(30,i);
is >>i;
ASSERT(!is);
\end{codeblock}
\end{example}
\begin{example} writing to a fixed pre-arranged character buffer:
\begin{codeblock}
char  output[30]{}; // zero-initialize array
ospanstream os{span<char>{output}};
os << 10 << 20 << 30;
auto const sp = os.span();
ASSERT_EQUAL(6,sp.size());
ASSERT_EQUAL("102030",std::string(sp.data(),sp.size()));
ASSERT_EQUAL(static_cast<void*>(output),sp.data()); // no copying of underlying data!
ASSERT_EQUAL("102030",output); // initialization guaranteed NUL termination
\end{codeblock}
\end{example}

\chapter{Impact on the Standard}
This is an extension to the standard library to enable deletion of the deprecated \tcode{strstream} classes by providing \tcode{basic_spanbuf}, \tcode{basic_spanstream}, \tcode{basic_ispanstream}, and \tcode{basic_ospanstream} class templates that take an object of type \tcode{span<charT>} which provides an external buffer to be used by the stream. 

It also proposes to remove the deprecated strstreams [depr.str.strstreams] assuming p0407 is also included in the standard.

\chapter{Design Decisions}
\section{General Principles}
The design follows from the principles of the iostream library. If discussed a person knowledgable about iostream's implementation is favorable, because of its many legacy design decisions, that would no longer be taken by modern C++ class designers. The behavior presented is part of what "frozen" strstreams provide, namely relying on a pre-allocated buffer, without the idiosynchracy of (o)strstream that automatically (re-)allocates a new buffer on the C-heap, when the original buffer is insufficient for the output, which happens when such a buffer is not explicitly marked as "frozen". This broken design is the reason it has long been deprecated, but its use with pre-allocated buffers is one of the reasons it has not been banned completely, yet. Together with p0407 this paper gets rid of it.

As with all existing stream classes, using a stream object or a streambuf object from multiple threads can result in a data race. Only the pre-defined global stream objects cin/cout/cerr are exempt from this.

\section{Older Open Issues (to be) Discussed by LEWG / LWG}
\begin{itemize}
\item Should arbitrary types as template arguments to \tcode{span} be allowed to provide the underlying buffer by using the \tcode{byte} sequence representation \tcode{span} provides. (I do not think so and some people in LEWG inofficially agree with it). You can always get a span of characters from the underlying byte sequence, so there is no need to put that functionality into spanbuf, it would break orthogonality and could lead to undefined behavior, because the streambuf would be aliasing with an arbitrary object.
\item Should the \tcode{basic_spanbuf} be copy-able? It doesn't own any resources, so copying like with handles or \tcode{span} might be fine. Other concrete streambuf classes in the standard that own their buffer (\tcode{basic_stringbuf}, \tcode{basic_filebuf}) naturally prohibit copying, where the base class \tcode{basic_streambuf} provides a protected copy-ctor. I considered providing copyability for \tcode{basic_spanbuf}, because the implementation is \tcode{=default}. Note, none of the stream classes in the standard is copyable as are the stream classes provided here. Other streambuf subclasses are not copyable, mainly because they either represent an external resource (fstreambuf), or because one usually would not access it via its concrete type and only through its \tcode{basic_streambuf} abstraction, i.e., by using an associated stream's \tcode{rdbuf()} member function. I speculate that another reason, why basic_stringbuf is not copyable, is that copying its underlying string and re-establishing a new stream with it is possible and copying a streambuf felt not natural. Therefore, I stick with my decision to prohibit copying \tcode{basic_spanbuf}.
\end{itemize}


\section{Current (r2) Open Issues (to be) Discussed by LEWG / LWG}
\begin{itemize}
\item Should we keep a separate header <spanstream> ? Where to put it instead? \added{LEWG(Kona2019): yes!}
\item Is adding a default constructor for basic_spanbuf OK? \added{LEWG(Kona2019): yes!}
\item \added{LEWG(Kona2019): Forward to LWG for C++20!}
\end{itemize}


\chapter{Technical Specifications}

\emph{Introduce a new header \tcode{\textless{}spanstream\textgreater} in subclause ([headers]): Table 19 ([tab:headers.cpp]).}

\emph{In section [version.syn] add the feature test macro \tcode{__cpp_lib_spanstream} 
%to Table 19 ([tab:cpp.predefined.ft]) 
with the corresponding value for the header \tcode{\textless{}spanstream\textgreater}:}
\begin{codeblock}
#define __cpp_lib_spanstream  @\emph{TBD}@ // also in <spanstream>
\end{codeblock}

\emph{Insert a new section 29.x in chapter 29 [input.output] after section 29.8 [string.streams] and adjust table [tab:iostreams.summary] accordingly.}


\section{29.3.1 Header \tcode{<iosfwd>} synopsis [iosfwd.syn]}

\emph{In 29.3.1 [iosfwd.syn] add the following forward declarations and type aliases in the appropriate places.}

\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
    class basic_spanbuf;
  template <class charT, class traits = char_traits<charT>>
    class basic_ispanstream;
  template <class charT, class traits = char_traits<charT>>
    class basic_ospanstream;
  template <class charT, class traits = char_traits<charT>>
    class basic_spanstream;

  using spanbuf     = basic_spanbuf<char>;
  using ispanstream = basic_ispanstream<char>;
  using ospanstream = basic_ospanstream<char>;
  using spanstream  = basic_spanstream<char>;

  using wspanbuf     = basic_spanbuf<wchar_t>;
  using wispanstream = basic_ispanstream<wchar_t>;
  using wospanstream = basic_ospanstream<wchar_t>;
  using wspanstream  = basic_spanstream<wchar_t>;
}
\end{codeblock}



\section{29.x Span-based Streams [span.streams]}

\pnum
This section introduces a stream interface for user-provided fixed-size buffers. 
\subsection{29.x.1 Overview [span.streams.overview]}
The header \tcode{<spanstream>} defines class templates and types that associate stream buffers with objects of class template \tcode{span} as described in [views.span]. 

\begin{note}
A user of theses classes is responsible that the character sequence represented by the given \tcode{span} outlives the use of the sequence by objects of the classes in this chapter. Using multiple \tcode{basic_spanbuf} objects referring to overlapping underlying sequences from different threads, where at least one \tcode{basic_spanbuf} object is used for writing to the sequence, results in a data race.
\end{note}

\subsection{Header \tcode{<spanstream>} synopsis [span.streams.syn]}

\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
    class basic_spanbuf;
    
  using spanbuf = basic_spanbuf<char>;
  using wspanbuf = basic_spanbuf<wchar_t>;

  template <class charT, class traits = char_traits<charT>>
    class basic_ispanstream;

  using ispanstream = basic_ispanstream<char>;
  using wispanstream = basic_ispanstream<wchar_t>;

  template <class charT, class traits = char_traits<charT>>
    class basic_ospanstream;

  using ospanstream = basic_ospanstream<char>;
  using wospanstream = basic_ospanstream<wchar_t>;

  template <class charT, class traits = char_traits<charT>>
    class basic_spanstream;

  using spanstream = basic_spanstream<char>;
  using wspanstream = basic_spanstream<wchar_t>;
}
\end{codeblock}
\section{29.x.2 Class template \tcode{basic_spanbuf} [spanbuf]}
%\rSec2[spanbuf]{Class template \tcode{basic_spanbuf}}
%\indexlibrary{\idxcode{basic_spanbuf}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_spanbuf
    : public basic_streambuf<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{spanbuf.cons}, constructors
    basic_spanbuf() : basic_spanbuf(ios_base::in | ios_base::out) {}
    explicit basic_spanbuf(ios_base::openmode which)
      : basic_spanbuf(std::span<charT>(), which) {}
    explicit basic_spanbuf(
      std::span<charT> s,
      ios_base::openmode which = ios_base::in | ios_base::out);
    basic_spanbuf(const basic_spanbuf&) = delete;
    basic_spanbuf(basic_spanbuf&& rhs);

    // \iref{spanbuf.assign}, assign and swap
    basic_spanbuf& operator=(const basic_spanbuf&) = delete;
    basic_spanbuf& operator=(basic_spanbuf&& rhs);
    void swap(basic_spanbuf& rhs);

    // \iref{spanbuf.members}, get and set
    std::span<charT> span() const noexcept;
    void span(std::span<charT> s) noexcept;

  protected:
    // \iref{spanbuf.virtuals}, overridden virtual functions
    basic_streambuf<charT, traits>* setbuf(charT*, streamsize) override;

    pos_type seekoff(off_type off, ios_base::seekdir way,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    pos_type seekpos(pos_type sp,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;

  private:
    ios_base::openmode mode;  // \expos
    std::span<charT> buf; // \expos
  };

  template <class charT, class traits>
    void swap(basic_spanbuf<charT, traits>& x,
              basic_spanbuf<charT, traits>& y);
}
\end{codeblock}

\pnum
The class template
\tcode{basic_spanbuf}
is derived from
\tcode{basic_streambuf}
to associate possibly the input sequence and possibly
the output sequence with a sequence of arbitrary characters.
The sequence is provided by an object of class
\tcode{span<charT>}.
% literally take from basic_stringbuf.

\pnum
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{ios_base::openmode mode},
has
\tcode{in}
set if the input sequence can be read, and
\tcode{out}
set if the output sequence can be written.
\item
\tcode{std::span<charT> buf}
is the view to the underlying character sequence.
\end{itemize}
%%%

\section{29.x.2.1 \tcode{basic_spanbuf} constructors [spanbuf.cons]}
%\rSec3[spanbuf.cons]{\tcode{basic_spanbuf}  constructors}

\indexlibrary{\idxcode{basic_spanbuf}!constructor}%
\begin{itemdecl}
explicit basic_spanbuf(
  std::span<charT> s,
  ios_base::openmode which = ios_base::in | ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_streambuf()}~(\iref{streambuf.cons}), and
\tcode{mode}
with \tcode{which}. 
Initializes the internal pointers as if calling \tcode{span(s)}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_spanbuf}!constructor}%
%basic_spanbuf(basic_spanbuf const & rhs) noexcept;
\begin{itemdecl}
basic_spanbuf(basic_spanbuf&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
%Copy/
Initializes the base class with \tcode{std::move(rhs)}
and \tcode{mode} with \tcode{std::move(rhs.mode)} and \tcode{buf} with \tcode{std::move(rhs.buf)}.
%Both \tcode{basic_spanbuf} objects share the same underlying \tcode{span}.
The sequence pointers in 
\tcode{*this}
(\tcode{eback()}, \tcode{gptr()}, \tcode{egptr()},
\tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}) obtain
the values which \tcode{rhs} had.
%% the following gives the same leeway as other streambufs
It is 
\impldef{whether \tcode{rhs.buf.empty()} returns true after the move}
whether \tcode{rhs.buf.empty()} returns true after the move.

%It
%is
%\impldef{whether sequence pointers are copied by \tcode{basic_spanbuf} move
%constructor} whether the sequence pointers in \tcode{*this}
%(\tcode{eback()}, \tcode{gptr()}, \tcode{egptr()},
%\tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}) obtain
%the values which \tcode{rhs} had. Whether they do or not, \tcode{*this}
%and \tcode{rhs} reference the same \tcode{span} after the
%construction. 

\pnum
\postconditions Let \tcode{rhs_p} refer to the state of
\tcode{rhs} just prior to this construction.

\begin{itemize}
\item \tcode{span().data() == rhs_p.span().data()}
\item \tcode{span().size() == rhs_p.span().size()}
\item \tcode{eback() == rhs_p.eback()}
\item \tcode{gptr() == rhs_p.gptr()}
\item \tcode{egptr() == rhs_p.egptr()}
\item \tcode{pbase() == rhs_p.pbase()}
\item \tcode{pptr() == rhs_p.pptr()}
\item \tcode{epptr() == rhs_p.epptr()}
\item \tcode{getloc() == rhs_p.getloc()}
\end{itemize}
\end{itemdescr}


\subsection{29.x.2.2 Assign and swap [spanbuf.assign]}

%\rSec3[spanbuf.assign]{Assign and swap}
%\indexlibrarymember{operator=}{basic_spanbuf}%
%basic_spanbuf& operator=(basic_spanbuf const & rhs) noexcept;
\begin{itemdecl}
basic_spanbuf& operator=(basic_spanbuf&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
    basic_spanbuf tmp{std::move(rhs)};
    this->swap(tmp);
    return *this;
\end{codeblock}
\end{itemdescr}

%\indexlibrarymember{swap}{basic_spanbuf}%
\begin{itemdecl}
void swap(basic_spanbuf& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock} 
    basic_streambuf<charT, traits>::swap(rhs);
    std::swap(mode, rhs.mode);
    std::swap(buf, rhs.buf);
\end{codeblock}
% swap is std::swap, because mode and buf's types are from std.
\end{itemdescr}

%\indexlibrarymember{swap}{basic_spanbuf}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_spanbuf<charT, traits>& x,
            basic_spanbuf<charT, traits>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}


\subsection{29.x.2.3 Member functions [spanbuf.members]}
%\rSec3[spanbuf.members]{Member functions}

%\indexlibrarymember{span}{basic_spanbuf}%
\begin{itemdecl}
std::span<charT> span() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{ios_base::out} is set in \tcode{mode},
returns \tcode{std::span<charT>(pbase(), pptr())}, 
otherwise returns \tcode{buf}. 

\begin{note}
In contrast to \tcode{basic_stringbuf}, the underlying sequence never grows and is not owned. 
An owning copy can be obtained by converting the result to \tcode{basic_string<charT>}.
\end{note}


\end{itemdescr}

%\indexlibrarymember{str}{basic_spanbuf}%
\begin{itemdecl}
void span(std::span<charT> s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
\tcode{buf = s}. Initializes the input and output sequences according to \tcode{mode}.
% expect feedback


\pnum
\postconditions 
\begin{itemize}
\item If \tcode{ ios_base::out} is set in \tcode{mode}, 
\tcode{(pbase() == s.data()} \tcode{\&\&} \tcode{epptr() == pbase() + s.size())} is \tcode{true}; 
\begin{itemize}
\item in addition, 
if \tcode{ios_base::ate} is set in \tcode{mode},
\tcode{pptr() == pbase() + s.size()} is \tcode{true}, 
\item otherwise \tcode{pptr() == pbase()} is \tcode{true}. 
\end{itemize}
\item If \tcode{ios_base::in} is set in \tcode{mode}, 
\tcode{(eback() == s.data()} \tcode{\&\&}  \tcode{gptr()
== eback()} \tcode{\&\&} \tcode{egptr() == eback() + s.size())} is \tcode{true}.
\end{itemize}


\end{itemdescr}

\subsection{29.x.2.4 Overridden virtual functions [spanbuf.virtuals]}
%\rSec3[spanbuf.virtuals]{Overridden virtual functions}
\pnum
\begin{note}
Because the underlying buffer is of fixed size, neither \tcode{overflow}, \tcode{underflow}, nor \tcode{pbackfail} can provide useful behavior.
\end{note}

%\indexlibrarymember{seekoff}{basic_spanbuf}%
\begin{itemdecl}
pos_type seekoff(off_type off, ios_base::seekdir way,
                 ios_base::openmode which
                   = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one or both of the
controlled sequences, if possible, as follows:
\begin{itemize}
\item if \tcode{ios_base::in} is set in \tcode{which}, positions the input sequence; \tcode{xnext} is \tcode{gptr()}, \tcode{xbeg} is \tcode{eback()}.
\item if \tcode{ios_base::out} is set in \tcode{which}, positions the output sequence; \tcode{xnext} is \tcode{pptr()}, \tcode{xbeg} is \tcode{pbase()}.
\end{itemize}

\pnum
If both \tcode{ios_base::in} and \tcode{ios_base::out} are set in \tcode{which} and \tcode{way} is 
%neither \tcode{ios_base::beg}, nor \tcode{ios_base::end} 
\tcode{ios_base::cur}
the positioning operation fails.


%indicated in Table~\ref{tab:spanbuf.seekoff.positioning}1\iref{tab:spanbuf.seekoff.positioning}.

%\begin{libtab2}{\tcode{seekoff} positioning}{tab:spanbuf.seekoff.positioning}
%{p{2.5in}l}{Conditions}{Result}
%\tcode{(which \& ios_base::in)}\br\tcode{ == ios_base::in}  &
% positions the input sequence; \tcode{xnext} is \tcode{gptr()}, \tcode{xbeg} is \tcode{eback()} \\ \rowsep
%\tcode{(which \& ios_base::out)}\br\tcode{ == ios_base::out}  &
% positions the output sequence; \tcode{xnext} is \tcode{pptr()}, \tcode{xbeg} is \tcode{pbase()} \\ \rowsep
%\tcode{(which \& (ios_base::in |}\br
%\tcode{ios_base::out)) ==}\br
%\tcode{(ios_base::in |}\br
%\tcode{ios_base::out)}\br
%and \tcode{way ==} either\br
%\tcode{ios_base::beg} or\br
%\tcode{ios_base::end}     &
% positions both the input and the output sequences  \\ \rowsep
%Otherwise &
% the positioning operation fails. \\
%\end{libtab2}

\pnum
For a sequence to be positioned, if its next pointer \tcode{xnext}
(either
\tcode{gptr()}
or
\tcode{pptr()})
is a null pointer and the new offset \tcode{newoff} as computed below is nonzero, the positioning
operation fails. Otherwise, the function determines \tcode{baseoff} as a value of type \tcode{off_type} as follows:
\begin{itemize}
\item \tcode{0} when \tcode{way} is \tcode{ios_base::beg};
\item \tcode{(pptr() - pbase())} for the output sequence, or \newline
      \tcode{(gptr() - eback())} for the input sequence when \tcode{way} is \tcode{ios_base::cur};
\item when \tcode{way} is \tcode{ios_base::end} :  
\begin{itemize}
\item \tcode{(pptr() - pbase())} if \tcode{mode} is \tcode{ios_base::out}, 
\item \tcode{buf.size()} otherwise.
\end{itemize}
\end{itemize}




%indicated in
%Table~\ref{tab:spanbuf.baseoff.values}2\iref{tab:spanbuf.baseoff.values}.
%
%\begin{libtab2}{\tcode{baseoff} values}{tab:spanbuf.baseoff.values}
%{lp{2.0in}}{Condition}{\tcode{baseoff} Value}
%\tcode{way == ios_base::beg}  &
% 0  \\ \rowsep
%\tcode{way == ios_base::cur}  &
% \tcode{pptr() - pbase()} or \tcode{gptr() - eback()}. \\ \rowsep
%\tcode{way == ios_base::end}  &
%  \tcode{(mode == ios_base::out)?} \tcode{pptr() - pbase() : }\tcode{buf.size()}   \\
%\end{libtab2}

\pnum
If \tcode{baseoff} + \tcode{off} would overflow, or 
if \tcode{baseoff} + \tcode{off} is less than zero, or 
if \tcode{baseoff} + \tcode{off} is greater than \tcode{buf.size()},
the positioning operation fails.
Otherwise, the function computes 
\begin{codeblock}
off_type newoff = baseoff + off;
\end{codeblock}
and assigns
\tcode{xbeg + newoff}
to the next pointer \tcode{xnext}.

\pnum
\returns
\tcode{pos_type(off_type(-1))} if the positioning operation fails;
\tcode{pos_type(newoff)} otherwise.
\end{itemdescr}

%\indexlibrarymember{seekpos}{basic_spanbuf}%
\begin{itemdecl}
pos_type seekpos(pos_type sp,
                 ios_base::openmode which
                   = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: 
\begin{codeblock}
return seekoff(off_type(sp), ios_base::beg, which);
\end{codeblock}
\end{itemdescr}

%\indexlibrarymember{setbuf}{basic_streambuf}%
\begin{itemdecl}
basic_streambuf<charT, traits>* setbuf(charT* s, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{this->span(std::span<charT>(s, n));}

\pnum
\returns
\tcode{this}.
\end{itemdescr} 

%\rSec2[ispanstream]{Class template \tcode{basic_ispanstream}}
\section{29.x.3 Class template \tcode{basic_ispanstream} [ispanstream] }

%\indexlibrary{\idxcode{basic_ispanstream}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
  class basic_ispanstream
    : public basic_istream<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{ispanstream.cons}, constructors
    explicit basic_ispanstream(
      std::span<charT> s,
      ios_base::openmode which = ios_base::in);
    basic_ispanstream(const basic_ispanstream&) = delete;
    basic_ispanstream(basic_ispanstream&& rhs);

    // \iref{ispanstream.assign}, assign and swap
    basic_ispanstream& operator=(const basic_ispanstream&) = delete;
    basic_ispanstream& operator=(basic_ispanstream&& rhs);
    void swap(basic_ispanstream& rhs);

    // \iref{ispanstream.members}, members
    basic_spanbuf<charT, traits>* rdbuf() const noexcept;

    std::span<charT> span() const noexcept;
    void span(std::span<charT> s) noexcept;
  private:
    basic_spanbuf<charT, traits> sb; // \expos
  };

  template <class charT, class traits>
    void swap(basic_ispanstream<charT, traits>& x,
              basic_ispanstream<charT, traits>& y);
}
\end{codeblock}

%\pnum
%The class
%\tcode{basic_ispanstream<charT, traits>}
%supports reading from objects of class
%\tcode{span<charT>}.
%It uses a
%\tcode{basic_spanbuf<charT, traits>}
%object to control the associated span.
%For the sake of exposition, the maintained data is presented here as:
%\begin{itemize}
%\item
%\tcode{sb}, the \tcode{spanbuf} object.
%\end{itemize}

%\rSec3[ispanstream.cons]{\tcode{basic_ispanstream} constructors}
\subsection{29.x.3.1 \tcode{basic_ispanstream} constructors [ispanstream.cons]}
\label{ispanstream.cons}

%\indexlibrary{\idxcode{basic_ispanstream}!constructor}%
\begin{itemdecl}
explicit basic_ispanstream(
  std::span<charT> s,
  ios_base::openmode which = ios_base::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_istream<charT, traits>(addressof(sb))}
and \tcode{sb} with
\tcode{basic_spanbuf<charT, traits>(s, which | ios_base::in)}~(\iref{spanbuf.cons}).
\end{itemdescr}

%\indexlibrary{\idxcode{basic_ispanstream}!constructor}%
\begin{itemdecl}
basic_ispanstream(basic_ispanstream&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Initializes the base class with \tcode{std::move(rhs)} 
and \tcode{sb} with \tcode{std::move(rhs.sb)}.
% LWG: base class does not touch sb member on move, only the pointer is moved and needs to be readjusted
Next, \tcode{basic_istream<charT, traits>::set_rdbuf(addressof(sb))} is called to
install the contained \tcode{basic_spanbuf}.
\end{itemdescr}

%\rSec3[ispanstream.assign]{Assign and swap}
\subsection{29.x.3.2 Assign and swap [ispanstream.assign]}
\label{ispanstream.assign}

%%\indexlibrarymember{operator=}{basic_ispanstream}%
%\begin{itemdecl}
%basic_ispanstream& operator=(basic_ispanstream&& rhs);
%\end{itemdecl}
%
%\begin{itemdescr}
%\pnum
%\effects Equivalent to:
%\begin{codeblock}
%   basic_istream<charT, traits>::swap(rhs);
%   sb = std::move(rhs.sb);
%   return *this;
%\end{codeblock}
%\end{itemdescr}

%\indexlibrarymember{swap}{basic_ispanstream}%
\begin{itemdecl}
void swap(basic_ispanstream& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
    basic_istream<charT, traits>::swap(rhs);
    sb.swap(rhs.sb);
\end{codeblock}
% text from basic_istringstream:
%Exchanges the state of \tcode{*this} and
%\tcode{rhs} by calling
%\tcode{basic_istream<charT, traits>::swap(rhs)} and
%\tcode{sb.swap(rhs.sb)}.
\end{itemdescr}


%\indexlibrarymember{swap}{basic_ispanstream}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_ispanstream<charT, traits>& x,
            basic_ispanstream<charT, traits>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: 
\tcode{x.swap(y)}.
\end{itemdescr}

%\rSec3[ispanstream.members]{Member functions}
\subsection{29.x.3.3 Member functions [ispanstream.members]}
\label{ispanstream.members}

%\indexlibrarymember{rdbuf}{basic_ispanstream}%
\begin{itemdecl}
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:\\
\tcode{return const_cast<basic_spanbuf<charT, traits>*>(addressof(sb));}
\end{itemdescr}

%\indexlibrarymember{str}{basic_ispanstream}%
\begin{itemdecl}
std::span<charT> span() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:\\
\tcode{return rdbuf()->span();}
\end{itemdescr}

%\indexlibrarymember{str}{basic_ispanstream}%
\begin{itemdecl}
void span(std::span<charT> s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{rdbuf()->span(s)}.
\end{itemdescr}

%\rSec2[ospanstream]{Class template \tcode{basic_ospanstream}}
\section{29.x.4 Class template \tcode{basic_ospanstream} [ospanstream] }

%\indexlibrary{\idxcode{basic_ospanstream}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
  class basic_ospanstream
    : public basic_ostream<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{ospanstream.cons}, constructors
    explicit basic_ospanstream(
      std::span<charT> s,
      ios_base::openmode which = ios_base::out);
    basic_ospanstream(const basic_ospanstream&) = delete;
    basic_ospanstream(basic_ospanstream&& rhs);

    // \iref{ospanstream.assign}, assign and swap
    basic_ospanstream& operator=(const basic_ospanstream&) = delete;
    basic_ospanstream& operator=(basic_ospanstream&& rhs);
    void swap(basic_ospanstream& rhs);

    // \iref{ospanstream.members}, members
    basic_spanbuf<charT, traits>* rdbuf() const noexcept;

    std::span<charT> span() const noexcept;
    void span(std::span<charT> s) noexcept;
  private:
    basic_spanbuf<charT, traits> sb; // \expos
  };

  template <class charT, class traits>
    void swap(basic_ospanstream<charT, traits>& x,
              basic_ospanstream<charT, traits>& y);
}
\end{codeblock}

%\pnum
%The class
%\tcode{basic_ospanstream<charT, traits>}
%supports writing to objects of class
%\tcode{span<charT, traits>}.
%It uses a
%\tcode{basic_spanbuf<charT, traits>}
%object to control the associated span.
%For the sake of exposition, the maintained data is presented here as:
%\begin{itemize}
%\item
%\tcode{sb}, the \tcode{spanbuf} object.
%\end{itemize}

%\rSec3[ospanstream.cons]{\tcode{basic_ospanstream} constructors}
\subsection{29.x.4.1 \tcode{basic_ospanstream} constructors [ospanstream.cons]}
\label{ospanstream.cons}

%\indexlibrary{\idxcode{basic_ospanstream}!constructor}%
\begin{itemdecl}
explicit basic_ospanstream(
  std::span<charT> s,
  ios_base::openmode which = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}
and \tcode{sb} with
\tcode{basic_spanbuf<charT, traits>(span, which | ios_base::out)}~(\iref{spanbuf.cons}).
\end{itemdescr}

%\indexlibrary{\idxcode{basic_ospanstream}!constructor}%
\begin{itemdecl}
basic_ospanstream(basic_ospanstream&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Initializes the base class with \tcode{std::move(rhs)} 
and \tcode{sb} with \tcode{std::move(rhs.sb)}.
%move constructing the base class, and the contained \tcode{basic_spanbuf}.
Next, \tcode{basic_ostream<charT, traits>::set_rdbuf(addressof(sb))} is called to
install the contained \tcode{basic_spanbuf}.
\end{itemdescr}

%\rSec3[ospanstream.assign]{Assign and swap}
\subsection{29.x.4.2 Assign and swap [ospanstream.assign]}
\label{ospanstream.assign}

%%\indexlibrarymember{operator=}{basic_ospanstream}%
%\begin{itemdecl}
%basic_ospanstream& operator=(basic_ospanstream&& rhs);
%\end{itemdecl}
%
%\begin{itemdescr}
%\pnum
%\effects Equivalent to: 
%\begin{codeblock}
%    basic_ostream<charT, traits>::swap(rhs);
%    sb = std::move(rhs.sb);
%    return *this;
%\end{codeblock}
%\end{itemdescr}

%\indexlibrarymember{swap}{basic_ospanstream}%
\begin{itemdecl}
void swap(basic_ospanstream& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
    basic_ostream<charT, traits>::swap(rhs);
    sb.swap(rhs.sb);
\end{codeblock}
\end{itemdescr}


%\indexlibrarymember{swap}{basic_ospanstream}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_ospanstream<charT, traits>& x,
            basic_ospanstream<charT, traits>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}

%\rSec3[ospanstream.members]{Member functions}
\subsection{29.x.4.3 Member functions [ospanstream.members]}
\label{ospanstream.members}

%\indexlibrarymember{rdbuf}{basic_ospanstream}%
\begin{itemdecl}
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \\
\tcode{return const_cast<basic_spanbuf<charT, traits>*>(addressof(sb));}
\end{itemdescr}

%\indexlibrarymember{str}{basic_ospanstream}%
\begin{itemdecl}
std::span<charT> span() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \\
\tcode{return rdbuf()->span();}
\end{itemdescr}

%\indexlibrarymember{str}{basic_ospanstream}%
\begin{itemdecl}
void span(std::span<charT> s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{rdbuf()->span(s)}.
\end{itemdescr}

%\rSec2[spanstream]{Class template \tcode{basic_spanstream}}
\section{29.x.5 Class template \tcode{basic_spanstream} [spanstream] }

%\indexlibrary{\idxcode{basic_spanstream}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
  class basic_spanstream
    : public basic_iostream<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{spanstream.cons}, constructors
    explicit basic_spanstream(
      std::span<charT> s,
      ios_base::openmode which = ios_base::out | ios_base::in);
    basic_spanstream(const basic_spanstream&) = delete;
    basic_spanstream(basic_spanstream&& rhs);

    // \iref{spanstream.assign}, assign and swap
    basic_spanstream& operator=(const basic_spanstream&) = delete;
    basic_spanstream& operator=(basic_spanstream&& rhs);
    void swap(basic_spanstream& rhs);

    // \iref{spanstream.members}, members
    basic_spanbuf<charT, traits>* rdbuf() const noexcept;

    std::span<charT> span() const noexcept;
    void span(std::span<charT> s) noexcept;
  private:
    basic_spanbuf<charT, traits> sb; // \expos
  };

  template <class charT, class traits>
    void swap(basic_spanstream<charT, traits>& x,
              basic_spanstream<charT, traits>& y);
}
\end{codeblock}

%\pnum
%The class
%\tcode{basic_spanstream<charT, traits>}
%supports reading from and writing to objects of class
%\tcode{span<charT, traits>}.
%It uses a
%\tcode{basic_spanbuf<charT, traits>}
%object to control the associated span.
%For the sake of exposition, the maintained data is presented here as:
%\begin{itemize}
%\item
%\tcode{sb}, the \tcode{spanbuf} object.
%\end{itemize}

%\rSec3[spanstream.cons]{\tcode{basic_spanstream} constructors}
\subsection{29.x.5.1 \tcode{basic_spanstream} constructors [spanstream.cons]}
\label{spanstream.cons}

%\indexlibrary{\idxcode{basic_spanstream}!constructor}%
\begin{itemdecl}
explicit basic_spanstream(
  std::span<charT> s,
  ios_base::openmode which = ios_base::out | ios_bas::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}
and \tcode{sb} with
\tcode{basic_spanbuf<charT, traits>(s, which)}~(\iref{spanbuf.cons}).
\end{itemdescr}

%\indexlibrary{\idxcode{basic_spanstream}!constructor}%
\begin{itemdecl}
basic_spanstream(basic_spanstream&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes the base class with \tcode{std::move(rhs)} 
and \tcode{sb} with \tcode{std::move(rhs.sb)}.
%move constructing the base class, and the contained
%\tcode{basic_spanbuf}.
Next, \tcode{basic_iostream<charT, traits>::set_rdbuf(addressof(sb))} is called to
install the contained \tcode{basic_spanbuf}.
\end{itemdescr}

%\rSec3[spanstream.assign]{Assign and swap}
\subsection{29.x.5.2 Assign and swap [spanstream.assign]}
\label{spanstream.assign}

%%\indexlibrarymember{operator=}{basic_spanstream}%
%\begin{itemdecl}
%basic_spanstream& operator=(basic_spanstream&& rhs);
%\end{itemdecl}
%
%\begin{itemdescr}
%\pnum
%\effects Equivalent to:
%\begin{codeblock}
%    basic_iostream<charT, traits>::swap(rhs);
%    sb = std::move(rhs.sb);
%    return *this;
%\end{codeblock}
%\end{itemdescr}

%\indexlibrarymember{swap}{basic_spanstream}%
\begin{itemdecl}
void swap(basic_spanstream& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
    basic_iostream<charT, traits>::swap(rhs);
    sb.swap(rhs.sb);
\end{codeblock}
\end{itemdescr}


%\indexlibrarymember{swap}{basic_spanstream}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_spanstream<charT, traits>& x,
            basic_spanstream<charT, traits>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}

%\rSec3[spanstream.members]{Member functions}
\subsection{29.x.5.3 Member functions [spanstream.members]}
\label{spanstream.members}

%\indexlibrarymember{rdbuf}{basic_spanstream}%
\begin{itemdecl}
basic_spanbuf<charT, traits>* rdbuf() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \\
\tcode{return const_cast<basic_spanbuf<charT, traits>*>(addressof(sb));}
\end{itemdescr}

%\indexlibrarymember{str}{basic_spanstream}%
\begin{itemdecl}
std::span<charT> span() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \\
\tcode{return rdbuf()->span();}
\end{itemdescr}

%\indexlibrarymember{str}{basic_spanstream}%
\begin{itemdecl}
void span(std::span<charT> s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\tcode{rdbuf()->span(s)}.
\end{itemdescr}



\chapter{Appendix: Example Implementations}
An example implementation is available under the author's github account at:
\url{https://github.com/PeterSommerlad/SC22WG21_Papers/tree/master/workspace/p0448}
\end{document}

