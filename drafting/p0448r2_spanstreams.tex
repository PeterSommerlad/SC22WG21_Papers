\documentclass[ebook,11pt,article]{memoir}
\usepackage{geometry}  % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}  % ... or a4paper or a5paper or ... 
%\geometry{landscape}  % Activate for for rotated page geometry
%%% from std.tex
%\usepackage[american]
%           {babel}        % needed for iso dates
%\usepackage[iso,american]
%           {isodate}      % use iso format for dates
\usepackage[final]
           {listings}     % code listings
\usepackage{longtable}    % auto-breaking tables
\usepackage{ltcaption}    % fix captions for long tables
\usepackage{relsize}      % provide relative font size changes
%\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{underscore}   % remove special status of '_' in ordinary text
%\usepackage{parskip}      % handle non-indented paragraphs "properly"
%\usepackage{array}        % new column definitions for tables
\usepackage[normalem]{ulem}
\usepackage{enumitem}
\usepackage{color}        % define colors for strikeouts and underlines
%\usepackage{amsmath}      % additional math symbols
%\usepackage{mathrsfs}     % mathscr font
\usepackage[final]{microtype}
%\usepackage{multicol}
\usepackage{xspace}
%\usepackage{lmodern}
\usepackage[T1]{fontenc} % makes tilde work! and is better for umlauts etc.
%\usepackage[pdftex, final]{graphicx}
\usepackage[pdftex,
%            pdftitle={C++ International Standard},
%            pdfsubject={C++ International Standard},
%            pdfcreator={Richard Smith},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}
%\usepackage{memhfixc}     % fix interactions between hyperref and memoir
%\usepackage[active,header=false,handles=false,copydocumentclass=false,generate=std-gram.ext,extract-cmdline={gramSec},extract-env={bnftab,simplebnf,bnf,bnfkeywordtab}]{extract} % Grammar extraction
%
\renewcommand\RSsmallest{5.5pt}  % smallest font size for relsize


%%%% reuse all four from std.tex:
\input{layout}
\input{styles}
\input{macros}
\input{tables}

\renewcommand{\iref}[1]{[#1]}


\pagestyle{myheadings}

\newcommand{\papernumber}{p0448r2}
\newcommand{\paperdate}{2019-01-21}

\markboth{\papernumber{} \paperdate{}}{\papernumber{} \paperdate{}}

\title{\papernumber{} - A strstream replacement using span\textless{}charT\textgreater{} as buffer}
\author{Peter Sommerlad}
\date{\paperdate}                % Activate to display a given date or no date
\setsecnumdepth{subsection}

\begin{document}
\maketitle
\begin{center}
\begin{tabular}[t]{|l|l|}\hline 
Document Number:&  \papernumber \hfill (N2065 done right?)\\\hline
Date: & \paperdate \\\hline
Project: & Programming Language C++\\\hline 
Audience: & LEWG/LWG\\\hline
\end{tabular}
\end{center}
\chapter{History}
Streams have been the oldest part of the C++ standard library and especially strstreams that can use pre-allocated buffers have been deprecated for a long time now, waiting for a replacement. p0407 and p0408 provide the efficient access to the underlying buffer for stringstreams that strstream provided solving half of the problem that strstreams provide a solution for. The other half is using a fixed size pre-allocated buffer, e.g., allocated on the stack, that is used as the stream buffers internal storage.

A combination of external-fixed and internal-growing buffer allocation that strstreambuf provides is IMHO a doomed approach and very hard to use right.

There had been a proposal for the pre-allocated external memory buffer streams in N2065 but that went nowhere. Today, with \tcode{span<T>} we actually have a library type representing such buffers views we can use for specifying (and implementing) such streams. They can be used in areas where dynamic (re-)allocation of stringstreams is not acceptable but the burden of caring for a pre-existing buffer during the lifetime of the stream is manageable. 

\section{Changes from p0448r1}
There was email discussion (Alisdair, Marshall, Titus and library mailing list) on semantics of move, timing and wording of strstream removal. Therefore, this paper needs to be reconsidered with that design respect by LEWG. I also acquired an additional paper number for a paper to propose the strstream removal, so I drop it from here.

Marshall gave a list of review comments, I'd like to answer below:
\begin{itemize}

\item  
The synopsis shows these classes in std::experimental, while the class descriptions show std:: only.
\textit{fixed, copy relict}.
\item  
The synopsis should probably \#include <span> and <string>, since that's where span and char_traits come from.
\textit{yes to <span> not to <string> since the base class basic_streambuf already has a dependency to char_traits, so no gain from mentioning <string>, but including <streambuf> might be shown. Fixed. However, I found no precedence to such include directives for stream classes in n4791 (may be a more modern style of specification introduced with C++11. I guess mentioning a required identifier encourages implementors to make its definition available. }
\item 
Why a separate <spanstream> header? why not just put it in one of the existing ones? 
       (we're adding headers at a surprising - to me - rate)
\textit{First, because strstreams are also in their separate header. Second, LEWG blessed/asked for it.
Third, the base class already has the dependency to char_traits.}
\item  7.4.2/1 is really generic: "Move assigns the base and members of *this from the base and corresponding members of rhs."
\textit{These words are almost identical to basic_istringstream move assignment. Took the challenge and now use (more) code.}
\item  7.4.2/2 is mixing prose and code ; I suspect it would be better just as code. "Effects Equivalent to: <two lines of code>"
\textit{almost identical to basic_istringstream::swap wording. see above.}
\item  Is the span that you pass to the constructors required to be non-empty?  setbuf does have that requirement.
\textit{The latter is not really true: setbuf() is defined per streambuf subclass and we are free to define it any way. most subclasses say that setbuf(0,0) has no effect, filebuf makes I/O unbuffered and all say any other combination has implementation defined behavior. I do not require a non-empty span, the stream is then just not particularly useful, except to behave as a null object.}
\end{itemize}

Alisdair raised the question if the spanbuf move operations should actually disassociate the buffer/stream from the original span, like (all?) other streambuf subclasses to when moved from. 
\begin{quote}
{"I have a huge concern about the definition of move construction and move assignment
for basic_spanbuf.  The reason is that this is simply a copy operation, but we allowed
move semantics on streams/buffers following the unique ownership principle.  In other
words, it would be very surprising that writing to the move-from stream would have any
impact on the moved-to stream."}
\end{quote}

Titus had the counter argument that one should not spend cycles on cleaning up moved from objects.
 
The streambuf base class can only be copied. filebuf and stringbuf both disassociate the right hand side from its underlying data source that they both own. strstreambuf does neither support move or copy. 

I am torn, so I made that implementation defined.

Now to what really changed...
\begin{itemize}
\item rebase to n4791
\item removed superfluous experimental namespace from synopsis
\item added header includes in header synopsis for <streambuf> and <span> (even so no other iostream headers seem to do so).
\item introduce an exposition-only member \tcode{span<charT> buf} representing the span. This will make wording, especially of move constructor more clear. 
\item make the wording of the move constructor more clear instead of hand waving about "locale and other state of rhs".
\item make wording of spanbuf/streams's members more clear by code instead of weasel wording obtained from stringbuf/streams.
\item TODO
\end{itemize}



\section{Changes from p0448r0}
\begin{itemize}
\item provide explanation why non-copy-ability, while technically feasible, is an OK thing.
\item remove wrong Allocator template parameter (we never allocate anything).
\item adhere to new section numbering of the standard.
\item tried to clarify lifetime and threading issues.
\end{itemize}


\chapter{Introduction}
This paper proposes a class template \tcode{basic_spanbuf} and the corresponding stream class templates to enable the use of streams on externally provided memory buffers. No ownership or re-allocation support is given. For those features we have string-based streams.

\chapter{Acknowledgements}
\begin{itemize}
\item Thanks to those ISO C++ meeting members attending the Oulu meeting encouring me to write this proposal. I believe Neil and Pablo have been among them, but can't remember who else.
\item Thanks go to Jonathan Wakely who pointed the problem of \tcode{strstream} out to me and to Neil Macintosh to provide the span library type specification.
\item Thanks to Felix Morgner for proofreading.
\item Thanks to Kona LEWG small group discussion suggesting some clarifications and Thomas K\"oppe for allowing me to use using type aliases instead of \tcode{typedef}.
\end{itemize}

\chapter{Motivation}
To finally get rid of the deprecated \tcode{strstream} in the C++ standard we need a replacement. p0407/p0408 provide one for one half of the needs for \tcode{strstream}. This paper provides one for the second half: fixed sized buffers. 

\begin{example} reading input from a fixed pre-arranged character buffer:
\begin{codeblock}
char input[] = "10 20 30";
ispanstream is{span<char>{input}};
int i;
is >> i;
ASSERT_EQUAL(10,i);
is >> i ;
ASSERT_EQUAL(20,i);
is >> i;
ASSERT_EQUAL(30,i);
is >>i;
ASSERT(!is);
\end{codeblock}
\end{example}
\begin{example} writing to a fixed pre-arranged character buffer:
\begin{codeblock}
char  output[30]{}; // zero-initialize array
ospanstream os{span<char>{output}};
os << 10 << 20 << 30 ;
auto const sp = os.span();
ASSERT_EQUAL(6,sp.size());
ASSERT_EQUAL("102030",std::string(sp.data(),sp.size()));
ASSERT_EQUAL(static_cast<void*>(output),sp.data()); // no copying of underlying data!
ASSERT_EQUAL("102030",output); // initialization guaranteed NUL termination
\end{codeblock}
\end{example}

\chapter{Impact on the Standard}
This is an extension to the standard library to enable deletion of the deprecated \tcode{strstream} classes by providing \tcode{basic_spanbuf}, \tcode{basic_spanstream}, \tcode{basic_ispanstream}, and \tcode{basic_ospanstream} class templates that take an object of type \tcode{span<charT>} which provides an external buffer to be used by the stream. 

It also proposes to remove the deprecated strstreams [depr.str.strstreams] assuming p0407 is also included in the standard.

\chapter{Design Decisions}
\section{General Principles}
The design follows from the principles of the iostream library. If discussed a person knowledgable about iostream's implementation is favorable, because of its many legacy design decisions, that would no longer be taken by modern C++ class designers. The behavior presented is part of what "frozen" strstreams provide, namely relying on a pre-allocated buffer, without the idiosynchracy of (o)strstream that automatically (re-)allocates a new buffer on the C-heap, when the original buffer is insufficient for the output, which happens when such a buffer is not explicitly marked as "frozen". This broken design is the reason it has long been deprecated, but its use with pre-allocated buffers is one of the reasons it has not been banned completely, yet. Together with p0407 this paper gets rid of it.

As with all existing stream classes, using a stream object or a streambuf object from multiple threads can result in a data race. Only the pre-defined global stream objects cin/cout/cerr are exempt from this.

\section{Older Open Issues (to be) Discussed by LEWG / LWG}
\begin{itemize}
\item Should arbitrary types as template arguments to \tcode{span} be allowed to provide the underlying buffer by using the \tcode{byte} sequence representation \tcode{span} provides. (I do not think so and some people in LEWG inofficially agree with it). You can always get a span of characters from the underlying byte sequence, so there is no need to put that functionality into spanbuf, it would break orthogonality and could lead to undefined behavior, because the streambuf would be aliasing with an arbitrary object.
\item Should the \tcode{basic_spanbuf} be copy-able? It doesn't own any resources, so copying like with handles or \tcode{span} might be fine. Other concrete streambuf classes in the standard that own their buffer (\tcode{basic_stringbuf}, \tcode{basic_filebuf}) naturally prohibit copying, where the base class \tcode{basic_streambuf} provides a protected copy-ctor. I considered providing copyability for \tcode{basic_spanbuf}, because the implementation is \tcode{=default}. Note, none of the stream classes in the standard is copyable as are the stream classes provided here. Other streambuf subclasses are not copyable, mainly because they either represent an external resource (fstreambuf), or because one usually would not access it via its concrete type and only through its \tcode{basic_streambuf} abstraction, i.e., by using an associated stream's \tcode{rdbuf()} member function. I speculate that another reason, why basic_stringbuf is not copyable, is that copying its underlying string and re-establishing a new stream with it is possible and copying a streambuf felt not natural. Therefore, I stick with my decision to prohibit copying \tcode{basic_spanbuf}.
\end{itemize}


\section{Current (r2) Open Issues (to be) Discussed by LEWG / LWG}
\begin{itemize}
\item Should we keep a separate header <spanstream> ? Where to put it instead?
\item Is adding a default constructor for basic_spanbuf OK?
\end{itemize}


\chapter{Technical Specifications}

Insert a new section 28.x in chapter 28 [input.output] after section 28.8 [string.streams]

\section{28.x Span-based Streams [span.streams]}
This section introduces a stream interface for user-provided fixed-size buffers. 
\subsection{28.x.1 Overview [span.streams.overview]}
The header \tcode{<spanstream>} defines four class templates and eight types that associate stream buffers with objects of class \tcode{span} as described in [span]. 
\begin{note}
A user of theses classes is responsible that the character sequence represented by the given span outlives the use of the sequence by objects of the classes in this chapter. Using multiple basic_spanbuf objects referring to overlapping underlying sequences from different threads, where at least one spanbuf is used for writing to the sequence results in a data race.
\end{note}

\paragraph{Header \tcode{<spanstream>} synopsis}

\begin{codeblock}
#include <streambuf>
#include <span>

namespace std {
  template <class charT, class traits = char_traits<charT> >
    class basic_spanbuf;
  using spanbuf = basic_spanbuf<char>;
  using wspanbuf = basic_spanbuf<wchar_t>;
  template <class charT, class traits = char_traits<charT> >
    class basic_ispanstream;
  using ispanstream = basic_ispanstream<char>;
  using wispanstream = basic_ispanstream<wchar_t>;
  template <class charT, class traits = char_traits<charT> >
    class basic_ospanstream;
  using ospanstream = basic_ospanstream<char>;
  using wospanstream = basic_ospanstream<wchar_t>;
  template <class charT, class traits = char_traits<charT> >
    class basic_spanstream;
  using spanstream = basic_spanstream<char>;
  using wspanstream = basic_spanstream<wchar_t>;
}
\end{codeblock}
\section{28.x.2 Class template \tcode{basic_spanbuf} [spanbuf]}
%\rSec2[spanbuf]{Class template \tcode{basic_spanbuf}}
%\indexlibrary{\idxcode{basic_spanbuf}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_spanbuf
    : public basic_streambuf<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{spanbuf.cons}, constructors:
    basic_spanbuf() : basic_spanbuf(ios_base::in | ios_base::out) {}
    explicit basic_spanbuf(ios_base::openmode which)
      : basic_spanbuf(span<charT>(),which) {}
    template <ptrdiff_t Extent>
    explicit basic_spanbuf(
      span<charT, Extent> span,
      ios_base::openmode which = ios_base::in | ios_base::out);
    basic_spanbuf(const basic_spanbuf& rhs) = delete;
    basic_spanbuf(basic_spanbuf&& rhs) noexcept;

    // \iref{spanbuf.assign}, assign and swap:
    basic_spanbuf& operator=(const basic_spanbuf& rhs) = delete;
    basic_spanbuf& operator=(basic_spanbuf&& rhs) noexcept;
    void swap(basic_spanbuf& rhs) noexcept;

    // \iref{spanbuf.members}, get and set:
    span<charT> span() const noexcept;
    void span(span<charT> s) noexcept;

  protected:
    // \iref{spanbuf.virtuals}, overridden virtual functions:
    int_type underflow() override;
    int_type pbackfail(int_type c = traits::eof()) override;
    int_type overflow (int_type c = traits::eof()) override;
    basic_streambuf<charT, traits>* setbuf(charT*, streamsize) override;

    pos_type seekoff(off_type off, ios_base::seekdir way,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;
    pos_type seekpos(pos_type sp,
                     ios_base::openmode which
                      = ios_base::in | ios_base::out) override;

  private:
    ios_base::openmode mode;  // \expos
    span<charT> buf; // \expos
  };

  template <class charT, class traits>
    void swap(basic_spanbuf<charT, traits>& x,
              basic_spanbuf<charT, traits>& y) noexcept;
}
\end{codeblock}

\pnum
The class
\tcode{basic_spanbuf}
is derived from
\tcode{basic_streambuf}
to associate possibly the input sequence and possibly
the output sequence with a sequence of arbitrary
\term{characters}.
The sequence is provided by an object of class
\tcode{span<charT>}.

\pnum
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{ios_base::openmode mode},
has
\tcode{in}
set if the input sequence can be read, and
\tcode{out}
set if the output sequence can be written.
\item
\tcode{span<charT> buf}
is the view to the underlying character sequence.
\end{itemize}
%%%

\section{28.x.2.1 \tcode{basic_spanbuf} constructors [spanbuf.cons]}
%\rSec3[spanbuf.cons]{\tcode{basic_spanbuf}  constructors}

\indexlibrary{\idxcode{basic_spanbuf}!constructor}%
\begin{itemdecl}
template <ptrdiff_t Extent>
explicit basic_spanbuf(
  basic_span<charT, Extent> s,
  ios_base::openmode which = ios_base::in | ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_spanbuf},
initializing the base class with
\tcode{basic_streambuf()}~(\iref{streambuf.cons}), initializing
\tcode{mode}
with \tcode{which}. 
Initializes the internal pointers as if calling \tcode{span(s)}.
\end{itemdescr}

\indexlibrary{\idxcode{basic_spanbuf}!constructor}%
%basic_spanbuf(basic_spanbuf const & rhs) noexcept;
\begin{itemdecl}
basic_spanbuf(basic_spanbuf&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
%Copy/
Move constructs from the rvalue \tcode{rhs}. 
This is accomplished by copy constructing the base class 
and initializing \tcode{mode} from \tcode{rhs.mode} and \tcode{buf} from \tcode{rhs.buf}.
%Both \tcode{basic_spanbuf} objects share the same underlying \tcode{span}.
The sequence pointers in 
\tcode{*this}
(\tcode{eback()}, \tcode{gptr()}, \tcode{egptr()},
\tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}) obtain
the values which \tcode{rhs} had.
%% the following gives the same leeway as other streambufs
It is 
\impldef{wether \tcode{rhs.buf.empty()} returns true after the move}
wether \tcode{rhs.buf.empty()} returns true after the move.

%It
%is
%\impldef{whether sequence pointers are copied by \tcode{basic_spanbuf} move
%constructor} whether the sequence pointers in \tcode{*this}
%(\tcode{eback()}, \tcode{gptr()}, \tcode{egptr()},
%\tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}) obtain
%the values which \tcode{rhs} had. Whether they do or not, \tcode{*this}
%and \tcode{rhs} reference the same \tcode{span} after the
%construction. 

\pnum
\postconditions Let \tcode{rhs_p} refer to the state of
\tcode{rhs} just prior to this construction.

\begin{itemize}
\item \tcode{span() == rhs_p.span()}
\item \tcode{eback() == rhs_p.eback()}
\item \tcode{gptr() == rhs_p.gptr()}
\item \tcode{egptr() == rhs_p.egptr()}
\item \tcode{pbase() == rhs_p.pbase()}
\item \tcode{pptr() == rhs_p.pptr()}
\item \tcode{epptr() == rhs_p.epptr()}
\item \tcode{getloc() == rhs_p.getloc()}
\end{itemize}
\end{itemdescr}


\subsection{28.x.2.2 Assign and swap [spanbuf.assign]}

%\rSec3[spanbuf.assign]{Assign and swap}
%\indexlibrarymember{operator=}{basic_spanbuf}%
%basic_spanbuf& operator=(basic_spanbuf const & rhs) noexcept;
\begin{itemdecl}
basic_spanbuf& operator=(basic_spanbuf&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects After the 
%copy/
move assignment \tcode{*this} has the observable state it would
have had if it had been 
%copy/
move constructed from \tcode{rhs} (see~\iref{spanbuf.cons}).

\pnum
\returns \tcode{*this}.
\end{itemdescr}

%\indexlibrarymember{swap}{basic_spanbuf}%
\begin{itemdecl}
void swap(basic_spanbuf& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: 
\tcode{basic_streambuf<charT, traits>::swap(rhs);} \tcode{std::swap(mode,rhs.mode);} \tcode{std::swap(buf, rhs.buf)}.
%Exchanges the state of \tcode{*this}
%and \tcode{rhs}.
\end{itemdescr}

%\indexlibrarymember{swap}{basic_spanbuf}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_spanbuf<charT, traits>& x,
            basic_spanbuf<charT, traits>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}


\subsection{28.x.2.3 Member functions [spanbuf.members]}
%\rSec3[spanbuf.members]{Member functions}

%\indexlibrarymember{span}{basic_spanbuf}%
\begin{itemdecl}
span<charT> span() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
If \tcode{mode == ios_base::out} is true,
returns \tcode{span<charT>(pbase(),pptr())}, 
otherwise returns \tcode{buf}. 
\begin{note}
In constrast to \tcode{basic_stringbuf} the underlying sequence can never grow and will not be owned. An owning copy can be obtained by converting the result to \tcode{basic_string<charT>}.
\end{note}


\end{itemdescr}

%\indexlibrarymember{str}{basic_spanbuf}%
\begin{itemdecl}
template<ptrdiff_t Extent>
void span(span<charT,Extent> s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{buf = s;} Initializes the input and output sequences according to \tcode{mode}.

\pnum
\postconditions 
If \tcode{mode \& ios_base::out} is true, 
\tcode{pbase() == s.data()} and \tcode{epptr() == pbase() + s.size()} holds; 
in addition, 
if \tcode{mode \& ios_base::ate} is true,
\tcode{pptr() == pbase() + s.size()} holds, 
otherwise \tcode{pptr() == pbase()} is true. 
If \tcode{mode \& ios_base::in} is true, 
\tcode{eback() == s.data()}, and both \tcode{gptr()
== eback()} and \tcode{egptr() == eback() + s.size()} hold.

\begin{note}
Using append mode does not make sense for \tcode{span}-based streams.
\end{note}

\end{itemdescr}

\subsection{28.x.2.4 Overridden virtual functions [spanbuf.virtuals]}
%\rSec3[spanbuf.virtuals]{Overridden virtual functions}
\pnum
\begin{note}
Since the underlying buffer is of fixed size, neither \tcode{overflow}, \tcode{underflow} or \tcode{pbackfail} can provide useful behavior.
\end{note}

%\indexlibrarymember{underflow}{basic_spanbuf}%
\begin{itemdecl}
int_type underflow() override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
%If the input sequence has a read position available,
%returns
%\tcode{traits::to_int_type(*gptr())}.
%Otherwise, returns
\tcode{traits::eof()}.
%Any character in the underlying buffer which has been initialized is considered
%to be part of the input sequence. 
\end{itemdescr}

%\indexlibrarymember{pbackfail}{basic_spanbuf}%
\begin{itemdecl}
int_type pbackfail(int_type c = traits::eof()) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{traits::eof()}.
\end{itemdescr}

%\indexlibrarymember{overflow}{basic_spanbuf}%
\begin{itemdecl}
int_type overflow(int_type c = traits::eof()) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{traits::eof()}.

\end{itemdescr}

%\indexlibrarymember{seekoff}{basic_spanbuf}%
\begin{itemdecl}
pos_type seekoff(off_type off, ios_base::seekdir way,
                 ios_base::openmode which
                   = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Alters the stream position within one of the
controlled sequences, if possible, as indicated in Table~\ref{tab:spanbuf.seekoff.positioning}\iref{tab:spanbuf.seekoff.positioning}.

\begin{libtab2}{\tcode{seekoff} positioning}{tab:spanbuf.seekoff.positioning}
{p{2.5in}l}{Conditions}{Result}
\tcode{(which \& ios_base::in)}\tcode{ == ios_base::in}  &
 positions the input sequence (xnext is \tcode{gptr()}, xbeg is \tcode{eback()}) \\ \rowsep
\tcode{(which \& ios_base::out)}\tcode{ == ios_base::out}  &
 positions the output sequence (xnext is \tcode{pptr()}, xbeg is \tcode{pbase()}) \\ \rowsep
\tcode{(which \& (ios_base::in |}\br
\tcode{ios_base::out)) ==}\br
\tcode{(ios_base::in |}\br
\tcode{ios_base::out)}\br
and \tcode{way ==} either\br
\tcode{ios_base::beg} or\br
\tcode{ios_base::end}     &
 positions both the input and the output sequences  \\ \rowsep
Otherwise &
 the positioning operation fails. \\
\end{libtab2}

\pnum
For a sequence to be positioned, if its next pointer xnext
(either
\tcode{gptr()}
or
\tcode{pptr()})
is a null pointer and the new offset \tcode{newoff} is nonzero, the positioning
operation fails. Otherwise, the function determines \tcode{newoff} as indicated in
Table~\ref{tab:spanbuf.newoff.values}\iref{tab:spanbuf.newoff.values}.

\begin{libtab2}{\tcode{newoff} values}{tab:spanbuf.newoff.values}
{lp{2.0in}}{Condition}{\tcode{newoff} Value}
\tcode{way == ios_base::beg}  &
 0  \\ \rowsep
\tcode{way == ios_base::cur}  &
 \tcode{pptr()-pbase()} or \tcode{gptr()-eback()}. \\ \rowsep
\tcode{way == ios_base::end}  &
  \tcode{(mode == ios_base::out)?} \tcode{pptr()-pbase() : }\tcode{buf.size()}   \\
\end{libtab2}

\pnum
If
\tcode{(newoff + off) < 0},
or if \tcode{(newoff + off)}  \tcode{ >= buf.size()},
the positioning operation fails.
Otherwise, the function assigns
\tcode{xbeg + newoff + off}
to the next pointer \tcode{xnext}.

\pnum
\returns
\tcode{pos_type(newoff)},
constructed from the resultant offset \tcode{newoff}
(of type
\tcode{off_type}),
that stores the resultant stream position, if possible.
If the positioning operation fails, or
if the constructed object cannot represent the resultant stream position,
the return value is
\tcode{pos_type(off_type(-1))}.
\end{itemdescr}

%\indexlibrarymember{seekpos}{basic_spanbuf}%
\begin{itemdecl}
pos_type seekpos(pos_type sp,
                 ios_base::openmode which
                   = ios_base::in | ios_base::out) override;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{seekoff(off_type(sp), ios_base::beg, which)}.

\pnum
\returns
\tcode{sp}
to indicate success, or
\tcode{pos_type(off_type(-1))}
to indicate failure.
\end{itemdescr}

%\indexlibrarymember{setbuf}{basic_streambuf}%
\begin{itemdecl}
basic_streambuf<charT, traits>* setbuf(charT* s, streamsize n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{s} and \tcode{n} denote a non-empty span
\tcode{this->span(span<charT>(s,n));}

\pnum
\returns
\tcode{this}.
\end{itemdescr} 

%\rSec2[ispanstream]{Class template \tcode{basic_ispanstream}}
\section{28.x.3 Class template \tcode{basic_ispanstream} [ispanstream] }

%\indexlibrary{\idxcode{basic_ispanstream}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
  class basic_ispanstream
    : public basic_istream<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{ispanstream.cons}, constructors:
    template <ptrdiff_t Extent>
    explicit basic_ispanstream(
      span<charT, Extent> span,
      ios_base::openmode which = ios_base::in);
    basic_ispanstream(const basic_ispanstream& rhs) = delete;
    basic_ispanstream(basic_ispanstream&& rhs) noexcept;

    // \iref{ispanstream.assign}, assign and swap:
    basic_ispanstream& operator=(const basic_ispanstream& rhs) = delete;
    basic_ispanstream& operator=(basic_ispanstream&& rhs) noexcept;
    void swap(basic_ispanstream& rhs) noexcept;

    // \iref{ispanstream.members}, members:
    basic_spanbuf<charT, traits>* rdbuf() const noexcept;

    span<charT> span() const noexcept;
	template<ptrdiff_t Extent>
    void span(span<charT> s) noexcept;
  private:
    basic_spanbuf<charT, traits> sb; // \expos
  };

  template <class charT, class traits>
    void swap(basic_ispanstream<charT, traits>& x,
              basic_ispanstream<charT, traits>& y) noexcept;
}
\end{codeblock}

\pnum
The class
\tcode{basic_ispanstream<charT, traits>}
supports reading objects of class
\tcode{span<charT, traits>}.
It uses a
\tcode{basic_spanbuf<charT, traits>}
object to control the associated span.
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{sb}, the \tcode{spanbuf} object.
\end{itemize}

%\rSec3[ispanstream.cons]{\tcode{basic_ispanstream} constructors}
\subsection{28.x.3.1 \tcode{basic_ispanstream} constructors [ispanstream.cons]}
\label{ispanstream.cons}

%\indexlibrary{\idxcode{basic_ispanstream}!constructor}%
\begin{itemdecl}
template <ptrdiff_t Extent>
explicit basic_ispanstream(
  span<charT, Extent> span,
  ios_base::openmode which = ios_base::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_ispanstream<charT, traits>},
initializing the base class with
\tcode{basic_istream(\&sb)}
and initializing \tcode{sb} with
\tcode{basic_spanbuf<charT, traits>(span, which | ios_base::in)}~(\iref{spanbuf.cons}).
\end{itemdescr}

%\indexlibrary{\idxcode{basic_ispanstream}!constructor}%
\begin{itemdecl}
basic_ispanstream(basic_ispanstream&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Move constructs from the rvalue \tcode{rhs}.
This is accomplished by 
initializing the base \tcode{basic_istream<charT, traits>} from \tcode{std::move(rhs)} 
and initializing \tcode{sb} from \tcode{std::move(rhs.sb)}.
%move constructing the base class, and the contained \tcode{basic_spanbuf}.
Next \tcode{basic_istream<charT, traits>::set_rdbuf(\&sb)} is called to
install the contained \tcode{basic_spanbuf}.
\end{itemdescr}

%\rSec3[ispanstream.assign]{Assign and swap}
\subsection{28.x.3.2 Assign and swap [ispanstream.assign]}
\label{ispanstream.assign}

%\indexlibrarymember{operator=}{basic_ispanstream}%
\begin{itemdecl}
basic_ispanstream& operator=(basic_ispanstream&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{basic_istream<charT, traits>::swap(rhs);} \tcode{sb = std::move(rhs.sb)}.
%Move assigns the base and members of \tcode{*this} from the base and corresponding
%members of \tcode{rhs}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

%\indexlibrarymember{swap}{basic_ispanstream}%
\begin{itemdecl}
void swap(basic_ispanstream& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{basic_istream<charT, traits>::swap(rhs);} \tcode{sb.swap(rhs.sb)}.
% text from basic_istringstream:
%Exchanges the state of \tcode{*this} and
%\tcode{rhs} by calling
%\tcode{basic_istream<charT, traits>::swap(rhs)} and
%\tcode{sb.swap(rhs.sb)}.
\end{itemdescr}


%\indexlibrarymember{swap}{basic_ispanstream}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_ispanstream<charT, traits>& x,
            basic_ispanstream<charT, traits>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by 
\tcode{x.swap(y)}.
\end{itemdescr}

%\rSec3[ispanstream.members]{Member functions}
\subsection{28.x.3.3 Member functions [ispanstream.members]}
\label{ispanstream.members}

%\indexlibrarymember{rdbuf}{basic_ispanstream}%
\begin{itemdecl}
basic_spanbuf<charT>* rdbuf() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<basic_spanbuf<charT>*>(\&sb)}.
\end{itemdescr}

%\indexlibrarymember{str}{basic_ispanstream}%
\begin{itemdecl}
span<charT> span() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->span()}.
\end{itemdescr}

%\indexlibrarymember{str}{basic_ispanstream}%
\begin{itemdecl}
template<ptrdiff_t Extent>
void span(span<charT, Extent> s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->span(s)}.
\end{itemdescr}

%\rSec2[ospanstream]{Class template \tcode{basic_ospanstream}}
\section{28.x.4 Class template \tcode{basic_ospanstream} [ospanstream] }

%\indexlibrary{\idxcode{basic_ospanstream}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
  class basic_ospanstream
    : public basic_ostream<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{ospanstream.cons}, constructors:
    template <ptrdiff_t Extent>
    explicit basic_ospanstream(
      span<charT, Extent> span,
      ios_base::openmode which = ios_base::out);
    basic_ospanstream(const basic_ospanstream& rhs) = delete;
    basic_ospanstream(basic_ospanstream&& rhs) noexcept;

    // \iref{ospanstream.assign}, assign and swap:
    basic_ospanstream& operator=(const basic_ospanstream& rhs) = delete;
    basic_ospanstream& operator=(basic_ospanstream&& rhs) noexcept;
    void swap(basic_ospanstream& rhs) noexcept;

    // \iref{ospanstream.members}, members:
    basic_spanbuf<charT, traits>* rdbuf() const noexcept;

    span<charT> span() const noexcept;
	template<ptrdiff_t Extent>
    void span(span<charT> s) noexcept;
  private:
    basic_spanbuf<charT, traits> sb; // \expos
  };

  template <class charT, class traits>
    void swap(basic_ospanstream<charT, traits>& x,
              basic_ospanstream<charT, traits>& y) noexcept;
}
\end{codeblock}

\pnum
The class
\tcode{basic_ospanstream<charT, traits>}
supports writing to objects of class
\tcode{span<charT, traits>}.
It uses a
\tcode{basic_spanbuf<charT, traits>}
object to control the associated span.
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{sb}, the \tcode{spanbuf} object.
\end{itemize}

%\rSec3[ospanstream.cons]{\tcode{basic_ospanstream} constructors}
\subsection{28.x.4.1 \tcode{basic_ospanstream} constructors [ospanstream.cons]}
\label{ospanstream.cons}

%\indexlibrary{\idxcode{basic_ospanstream}!constructor}%
\begin{itemdecl}
template <ptrdiff_t Extent>
explicit basic_ospanstream(
  span<charT, Extent> span,
  ios_base::openmode which = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_ospanstream<charT, traits>},
initializing the base class with
\tcode{basic_ostream(\&sb)}
and initializing \tcode{sb} with
\tcode{basic_spanbuf<charT, traits>(span, which | ios_base::out)}~(\iref{spanbuf.cons}).
\end{itemdescr}

%\indexlibrary{\idxcode{basic_ospanstream}!constructor}%
\begin{itemdecl}
basic_ospanstream(basic_ospanstream&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Move constructs from the rvalue \tcode{rhs}. This
is accomplished by 
initializing the base \tcode{basic_ostream<charT, traits>} from \tcode{std::move(rhs)} 
and initializing \tcode{sb} from \tcode{std::move(rhs.sb)}.
%move constructing the base class, and the contained \tcode{basic_spanbuf}.
Next \tcode{basic_istream<charT, traits>::set_rdbuf(\&sb)} is called to
install the contained \tcode{basic_spanbuf}.
\end{itemdescr}

%\rSec3[ospanstream.assign]{Assign and swap}
\subsection{28.x.4.2 Assign and swap [ospanstream.assign]}
\label{ospanstream.assign}

%\indexlibrarymember{operator=}{basic_ospanstream}%
\begin{itemdecl}
basic_ospanstream& operator=(basic_ospanstream&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: 
\tcode{basic_ostream<charT, traits>::swap(rhs);} \tcode{sb = std::move(rhs.sb)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

%\indexlibrarymember{swap}{basic_ospanstream}%
\begin{itemdecl}
void swap(basic_ospanstream& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{basic_ostream<charT, traits>::swap(rhs);} \tcode{sb.swap(rhs.sb)}.
\end{itemdescr}


%\indexlibrarymember{swap}{basic_ospanstream}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_ospanstream<charT, traits>& x,
            basic_ospanstream<charT, traits>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}

%\rSec3[ospanstream.members]{Member functions}
\subsection{28.x.4.3 Member functions [ospanstream.members]}
\label{ospanstream.members}

%\indexlibrarymember{rdbuf}{basic_ospanstream}%
\begin{itemdecl}
basic_spanbuf<charT>* rdbuf() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<basic_spanbuf<charT>*>(\&sb)}.
\end{itemdescr}

%\indexlibrarymember{str}{basic_ospanstream}%
\begin{itemdecl}
span<charT> span() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->span()}.
\end{itemdescr}

%\indexlibrarymember{str}{basic_ospanstream}%
\begin{itemdecl}
template<ptrdiff_t Extent>
void span(span<charT, Extent> s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->span(s)}.
\end{itemdescr}

%\rSec2[spanstream]{Class template \tcode{basic_spanstream}}
\section{28.x.5 Class template \tcode{basic_spanstream} [spanstream] }

%\indexlibrary{\idxcode{basic_spanstream}}%
\begin{codeblock}
namespace std {
  template <class charT, class traits = char_traits<charT>>
  class basic_spanstream
    : public basic_iostream<charT, traits> {
  public:
    using char_type      = charT;
    using int_type       = typename traits::int_type;
    using pos_type       = typename traits::pos_type;
    using off_type       = typename traits::off_type;
    using traits_type    = traits;

    // \iref{spanstream.cons}, constructors:
    template <ptrdiff_t Extent>
    explicit basic_spanstream(
      span<charT, Extent> span,
      ios_base::openmode which = ios_base::out);
    basic_spanstream(const basic_spanstream& rhs) = delete;
    basic_spanstream(basic_spanstream&& rhs) noexcept;

    // \iref{spanstream.assign}, assign and swap:
    basic_spanstream& operator=(const basic_spanstream& rhs) = delete;
    basic_spanstream& operator=(basic_spanstream&& rhs) noexcept;
    void swap(basic_spanstream& rhs) noexcept;

    // \iref{spanstream.members}, members:
    basic_spanbuf<charT, traits>* rdbuf() const noexcept;

    span<charT> span() const noexcept;
	template<ptrdiff_t Extent>
    void span(span<charT> s) noexcept;
  private:
    basic_spanbuf<charT, traits> sb; // \expos
  };

  template <class charT, class traits>
    void swap(basic_spanstream<charT, traits>& x,
              basic_spanstream<charT, traits>& y) noexcept;
}
\end{codeblock}

\pnum
The class
\tcode{basic_spanstream<charT, traits>}
supports reading from and writing to objects of class
\tcode{span<charT, traits>}.
It uses a
\tcode{basic_spanbuf<charT, traits>}
object to control the associated span.
For the sake of exposition, the maintained data is presented here as:
\begin{itemize}
\item
\tcode{sb}, the \tcode{spanbuf} object.
\end{itemize}

%\rSec3[spanstream.cons]{\tcode{basic_spanstream} constructors}
\subsection{28.x.5.1 \tcode{basic_spanstream} constructors [spanstream.cons]}
\label{spanstream.cons}

%\indexlibrary{\idxcode{basic_spanstream}!constructor}%
\begin{itemdecl}
template <ptrdiff_t Extent>
explicit basic_spanstream(
  span<charT, Extent> span,
  ios_base::openmode which = ios_base::out | ios_bas::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an object of class
\tcode{basic_spanstream<charT, traits>},
initializing the base class with
\tcode{basic_iostream(\&sb)}
and initializing \tcode{sb} with
\tcode{basic_spanbuf<charT, traits>(span, which)}~(\iref{spanbuf.cons}).
\end{itemdescr}

%\indexlibrary{\idxcode{basic_spanstream}!constructor}%
\begin{itemdecl}
basic_spanstream(basic_spanstream&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Move constructs from the rvalue \tcode{rhs}. 
This is accomplished by 
initializing the base \tcode{basic_iostream<charT, traits>} from \tcode{std::move(rhs)} 
and initializing \tcode{sb} from \tcode{std::move(rhs.sb)}.
%move constructing the base class, and the contained
%\tcode{basic_spanbuf}.
Next \tcode{basic_istream<charT, traits>::set_rdbuf(\&sb)} is called to
install the contained \tcode{basic_spanbuf}.
\end{itemdescr}

%\rSec3[spanstream.assign]{Assign and swap}
\subsection{28.x.5.2 Assign and swap [spanstream.assign]}
\label{spanstream.assign}

%\indexlibrarymember{operator=}{basic_spanstream}%
\begin{itemdecl}
basic_spanstream& operator=(basic_spanstream&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{basic_iostream<charT, traits>::swap(rhs);} \tcode{sb = std::move(rhs.sb)}.
%Move assigns the base and members of \tcode{*this} from the base and corresponding
%members of \tcode{rhs}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

%\indexlibrarymember{swap}{basic_spanstream}%
\begin{itemdecl}
void swap(basic_spanstream& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{basic_iostream<charT, traits>::swap(rhs);} \tcode{sb.swap(rhs.sb)}.
\end{itemdescr}


%\indexlibrarymember{swap}{basic_spanstream}%
\begin{itemdecl}
template <class charT, class traits>
  void swap(basic_spanstream<charT, traits>& x,
            basic_spanstream<charT, traits>& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{x.swap(y)}.
\end{itemdescr}

%\rSec3[spanstream.members]{Member functions}
\subsection{28.x.5.3 Member functions [spanstream.members]}
\label{spanstream.members}

%\indexlibrarymember{rdbuf}{basic_spanstream}%
\begin{itemdecl}
basic_spanbuf<charT>* rdbuf() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{const_cast<basic_spanbuf<charT>*>(\&sb)}.
\end{itemdescr}

%\indexlibrarymember{str}{basic_spanstream}%
\begin{itemdecl}
span<charT> span() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdbuf()->span()}.
\end{itemdescr}

%\indexlibrarymember{str}{basic_spanstream}%
\begin{itemdecl}
template<ptrdiff_t Extent>
void span(span<charT, Extent> s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{rdbuf()->span(s)}.
\end{itemdescr}



\chapter{Appendix: Example Implementations}
An example implementation is available under the author's github account at:
\url{https://github.com/PeterSommerlad/SC22WG21_Papers/tree/master/workspace/p0448}
\end{document}

