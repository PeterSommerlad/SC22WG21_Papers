\documentclass[ebook,11pt,article]{memoir}
\usepackage{geometry}  % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}  % ... or a4paper or a5paper or ... 
%\geometry{landscape}  % Activate for for rotated page geometry
%%% from std.tex
%\usepackage[american]
%           {babel}        % needed for iso dates
%\usepackage[iso,american]
%           {isodate}      % use iso format for dates
\usepackage[final]
           {listings}     % code listings
%\usepackage{longtable}    % auto-breaking tables
%\usepackage{ltcaption}    % fix captions for long tables
\usepackage{relsize}      % provide relative font size changes
%\usepackage{textcomp}     % provide \text{l,r}angle
\usepackage{underscore}   % remove special status of '_' in ordinary text
%\usepackage{parskip}      % handle non-indented paragraphs "properly"
%\usepackage{array}        % new column definitions for tables
\usepackage[normalem]{ulem}
\usepackage{enumitem}
\usepackage{color}        % define colors for strikeouts and underlines
%\usepackage{amsmath}      % additional math symbols
%\usepackage{mathrsfs}     % mathscr font
\usepackage[final]{microtype}
%\usepackage{multicol}
\usepackage{xspace}
%\usepackage{lmodern}
\usepackage[T1]{fontenc} % makes tilde work! and is better for umlauts etc.
%\usepackage[pdftex, final]{graphicx}
\usepackage[pdftex,
%            pdftitle={C++ International Standard},
%            pdfsubject={C++ International Standard},
%            pdfcreator={Richard Smith},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}
%\usepackage{memhfixc}     % fix interactions between hyperref and memoir
%\usepackage[active,header=false,handles=false,copydocumentclass=false,generate=std-gram.ext,extract-cmdline={gramSec},extract-env={bnftab,simplebnf,bnf,bnfkeywordtab}]{extract} % Grammar extraction
%
\usepackage{threeparttable}

\renewcommand\RSsmallest{5.5pt}  % smallest font size for relsize


%%%% reuse all three from std.tex:
\input{macros}
\input{layout}
\input{styles}
\renewcommand{\iref}[1]{[#1]}


\pagestyle{myheadings}


\newcommand{\papernumber}{d0408r7}
\newcommand{\paperdate}{2019-07-18}

%\definecolor{insertcolor}{rgb}{0,0.5,0.25}
%\newcommand{\del}[1]{\textcolor{red}{\sout{#1}}}
%\newcommand{\ins}[1]{\textcolor{insertcolor}{\underline{#1}}}
%
%\newenvironment{insrt}{\color{insertcolor}}{\color{black}}


\markboth{\papernumber{} \paperdate{}}{\papernumber{} \paperdate{}}

\title{\papernumber{} - Efficient Access to basic\_stringbuf's Buffer\\
Including wording from p0407 Allocator-aware basic\_stringbuf}
\author{Peter Sommerlad}
\date{\paperdate}                        % Activate to display a given date or no date
\setsecnumdepth{subsection}

% test if std.tex macros can be replaced as well, but ref seems to be too special?
\renewcommand{\ref}[1]{[#1]}

\begin{document}
\maketitle
\begin{tabular}[t]{|l|l|}\hline 
Document Number: & \papernumber  \\\hline
Date: & \paperdate \\\hline
Project: & Programming Language C++\\\hline 
Audience: & LEWG / LWG\\\hline
Target: & C++20\\\hline
\end{tabular}

\chapter{Motivation}
Streams have been the oldest part of the C++ standard library and their specification doesn't take into account many things introduced since C++11. One of  the oversights is that there is no non-copying access to the internal buffer of a \tcode{basic_stringbuf} which makes at least the obtaining of the output results from an \tcode{ostringstream} inefficient, because a copy is always made. I personally speculate that this was also the reason why \tcode{basic_strbuf} took so long to get deprecated with its \tcode{char *} access.

With move semantics and \tcode{basic_string_view} there is no longer a reason to keep this pessimissation alive on \tcode{basic_stringbuf}.

\added{I also believe we should remove \tcode{basic_strbuf} from the standard's appendix [depr.str.strstreams]. This is proposed in p0448, that completes the replacement of that deprecated feature.}

\chapter{Introduction}
This paper proposes to adjust the API of \tcode{basic_stringbuf} and the corresponding stream class templates to allow accessing the underlying string more efficiently.

C++17 and library TS have \tcode{basic_string_view} allowing an efficient read-only access to a contiguous sequence of characters which I believe \tcode{basic_stringbuf} has to guarantee about its internal buffer, even if it is not implemented using \tcode{basic_string} obtaining a \tcode{basic_string_view} on the internal buffer should work sidestepping the copy overhead of calling \tcode{str()}. 

On the other hand, there is no means to construct a \tcode{basic_string} and move from it into a \tcode{basic_stringbuf} via a constructor or a move-enabled overload of \tcode{str(basic_string \&\&)}.

\section{History}
\subsection{Changes from r6}
The feedback by LWG in Cologne 2019 was incorporated.
\begin{itemize}
\item bump paper revision and base it on current working draft  (Daniel Kr√ºgler checked that all existing context wording is still OK.)
\item specify the moved from state to be "\tcode{str().empty()} is \tcode{true}" instead of comparing with an empty string literal.
\item make initialization sequencing more clear by replacing ". Calls..." with ". Then calls..."
\item reformulate constraint on constraint constructor (taking a string with a different allocator) to be in line with current wording guidelines (sentence instead of code). (also for str(SAlloc) overload).
\item simplified effects clause of constructors moving from string.
\item make conditional noexcept conform with synopsis for swap, but non-member swap gets it in synopsis without see below, because it is short enough.
\item remove obsolete wording in constructor definitions ("Constructs..." to "Initilizes")
\item replace many "Returns:" with "Effects: Equivalent to: " to obtain requirements in many places. This allows to remove some Constraints on SAlloc (if Marshall believes so).
\item replace many "Calls " with "Equivalent to:" in Effects clauses
\item simplifies wording for str() member functions by relating to view() (except for rvalue-ref qualified one)
\item make view() member specification simpler and more correct, by using "Let sv be basic_string_view<....>" and referring to sv instead of the incomplete type right now.
\item minor cosmetic adjustments wrt spacing
\end{itemize}


\subsection{Changes from r5}
There was a review in my absence (again) in San Diego, November 2018. I'll try my best to incorporate the feedback here.
\begin{itemize}
\item rebase on n4791.
\item undo premature application of p1163 (explicit -> non-explicit multi-parameter ctors by additional overloads) (ARGHHH, but I now think I follow Titus argumentation that it might be a bad idea).
\item see table \ref{tab:ctors}. LEWG might need to reconsider the combination of p0407/p0408 to agree on sane ctor overloads. LWG and Ville gave feedback on different ctor overloads. New Design: separate SFINAEd overloads for "foreign allocator" string arguments.
\item clean up \tcode{str()} member function overloads. This was in the overlap of p0407 and p0408 and not seen by LEWG in that way (sorry!). Split getter to two, one taking an allocator for the new string. Setter \tcode{str(string const\&)} member function remains a template on the string's Allocator. 
\item adjust the \emph{italic} explanations accordingly to the changes.
\item LWG question: Do the constructors taling a \tcode{SAlloc} template parameter restrict it  to \oldconcept{Allocator} requirements? It is implicit via \tcode{basic_string}.
\item Fixed a specification bug in move construction allowing keeping the original wording of move-assign. \tcode{rhs} must be "synced" first, by relying initializing \tcode{buf} from  \tcode{std::move(rhs).str()} instead from \tcode{std::move(rhs.buf)} directly.
\item merge getters \tcode{str()} specification of \tcode{high_mark} into a single specification for simplification and consistency.
\item split copying setters \tcode{str(basic_string const \&)} into the previously existing one and the one taking a basic_string with a different allocator, like with the constructors to reduce ABI problems.
\item drive by editorial fix to mention already existing Allocator template parameter in stream classes, i.e., basic_istringstream<charT, traits\added{, Allocator}> where mentioned in descriptions
\item drive-by fix to postcondition of \tcode{basic_stringbuf} move constructor to also refer to \tcode{getloc()}.
\end{itemize}

\begin{table}
\begin{threeparttable}
\caption{Overview of stringbuf/stringstream constructors}
\label{tab:ctors}
\begin{tabular}{|c|c|c|c|c|}\hline
 string & which & Allocator & ctor & comment \\\hline
        &   &   & default & exists \\\hline
        & yes &   & explicit & exists \\\hline
   copy & opt &   & explicit & exists \\\hline
        & \added{yes} & \added{yes} &  & 407 for stateful allocs \\\hline
   \added{move} & \added{opt} &  & \added{explicit} & 408, combined again \\\hline
\added{other-copy}\tnote{1} &   & \added{yes} &   & 407 other kind of strings\tnote{2} \\\hline
\added{other-copy}\tnote{1} & \added{yes} & \added{yes} &   & 407 other kind of strings\tnote{2} \\\hline
\added{other-copy}\tnote{1} & \added{opt} &     & \added{explicit}  & 407 above with default alloc\tnote{3} \\\hline
   &   & \added{yes} & \added{explicit}  & 407 for stateful allocators \\\hline
  \removed{move} & \removed{yes}  & \removed{yes} &   & 408r5 - useless, copies anyway\\\hline
\end{tabular}
\begin{tablenotes}
%\begin{enumerate}
\item{1} other-copy means has a different Allocator template argument
\item{2} allow if same or different allocator for string, because allocator is given, see copy-ctor string with allocator parameter.
\item{3} LEWG new design question: requires string Allocator different from stringbuf Allocator (new), otherwise existing ctor is changed ABI (and may be CTAD) breakage.
\item{*} in addition a move ctor is defined taking an additional Allocator argument like with basic_string
\item{**} Allocator should always be the last Parameter (is that really always the case?).
%\end{enumerate}
\end{tablenotes}
\end{threeparttable}
\end{table}

\subsection{Changes from r4}
Incorporate suggestions from LWG review in Batavia, August 2018. This was the first time the combined proposal was reviewed.
\begin{itemize}
\item Adjust specification sections to new naming schema introduced at the Rapperswil Meeting 2018 for C++20. (Requires->(Mandates (compile-time), Expects(contract)), Remarks->Constraints, Postconditions->Ensures). 

\item change the overloads of constructors with default arguments to only have the single argument version explicit according to p1163.
\item introduce an exposition-only member function \tcode{init_buf_ptrs()} in \tcode{basic_stringbuf} to set the streambuf pointers. In the standard version, that was part of the \tcode{str(string)} member function and now is needed in more than one place. Add a note there about internally violating invariants of \tcode{buf}. Explain the exposition only members in the front matter of the class.
\item reduce clutter, since bit operations are possible in enum \tcode{ios_base::openmode} parameters.
\item Provide a note that allocator properties are propagated along the properties of the basic_string member \tcode{buf} in the front matter of the class. I hope this is sufficient to address the issue from Batavia about what happens with the allocators. Also all other allocator relevant comments should be addressed through that delegation to \tcode{basic_string}'s properties.
\item I provided the following definition of \tcode{swap} for \tcode{basic_stringbuf} adopted from \tcode{basic_string}. Note, the base class swap does not give a noexcept guarantee. I provided that:
\begin{codeblock}
void swap(basic_stringbuf& s)
  noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
           allocator_traits<Allocator>::is_always_equal::value);
\end{codeblock}
\item \tcode{basic_stringbuf} move constructor now guarantees that \tcode{rhs} is empty, as if \tcode{std::move(rhs).str()} was called. This seems the easiest way to guarantee its get and put area are re-initialized accordingly. While technically not required, it makes handling moved-from streambufs (which are rare) consistent with calling the rvalue-ref-qualified \tcode{str()} member function. Please note, we do not give such a guarantee to the moved-from state of the stream objects, since they get their buffer pointer stolen and thus are completely unrelated to a streambuf after been moved-from. Only moving out the underlying string keeps the stream in working condition.
\end{itemize}


\subsection{Changes from r3}
To make the job of reviewing and integrating my stringstream adjustments easier, I incorporate the changes proposed in p0407r2 (allocator-aware basic\_stringbuf), since both papers have been forwarded by LEWG to LWG.
\begin{itemize}
\item Added full set of reasonable overloads to the constructors with and without allocator (\tcode{basic_string\&\&} does not get an allocator constructor template argument to allow efficient construction from \tcode{charT*} literals).
\end{itemize}


\subsection{Changes from r2}
Discussed in Albuquerque, where LEWG was in favor to forward it to LWG for IS with the following change.
\begin{itemize}
\item reestablish rvalue-ref qualified \tcode{str()} instead of the previously suggested \tcode{pilfer()}.
\item address LWG only in document header.
\end{itemize}


\subsection{Changes from r1}
Discussed in LEWG Issaquah. Answering some questions and raising more. Reflected in this paper.
\begin{itemize}
\item reflected new section numbers from the std. now relative to the current working draft.
\item implementation is now working with gcc 7. (not relevant for this paper)
\end{itemize}

\subsection{Changes from r0}
\begin{itemize}
\item Added more context to synopsis sections to see all overloads (Thanks Alisdair).
\item rename \tcode{str_view()} to just \tcode{view()}. There was discussion on including an explicit conversion operator as well, but I didn't add it yet (my implementation has it).
\item renamed r-value-ref qualified \tcode{str()} to \tcode{pilfer()} and removed the reference qualification from it and remaining \tcode{str()} member.
\item Added allocator parameter for the \tcode{basic_string} parameter/result to member functions (see p0407 for allocator support for stringstreams in general)
\end{itemize}


\chapter{Acknowledgements}
\begin{itemize}
\item Daniel Kr\"ugler encouraged me to pursue this track.
\item Alisdair Meredith for telling me to include context in the synopsis showing all overloads. That is the only change in this version, no semantic changes!
\item Jonathan Wakely to show me the \tcode{\#undef _GLIBCXX_EXTERN_TEMPLATE}
\end{itemize}


%\chapter{example code}


\chapter{Impact on the Standard}
This is an extension to the API of \tcode{basic_stringbuf}, \tcode{basic_stringstream}, \tcode{basic_istringstream}, and \tcode{basic_ostringstream} class templates.

\removed{This paper addresses both Library Fundamentals TS 3 and C++Next (2020?).} 
When added to the standard draft with p0448 (spanstream), section [depr.str.strstreams] should be removed.


\chapter{Design Decisions}
After experimentation I decided that substituting the \tcode{(basic_string<charT,traits,Allocator const \&)} constructors in favor of passing a \tcode{basic_string_view} would lead to ambiguities with the new move-from-string constructors.

\section{Hint to implementers}
In both libc++ and libstdc++ I needed to make basic_stringbuf a friend of basic_string to allow efficient growth of the buffer beyond the current string length (breaking an invariant) until it is retrieved using one of the str() member functions. Other implementations might use a different strategy of caring for the buffer space that should be efficiently be adopted by the returned string object, thus requiring either special basic_string constructors or access to its internals as well.

\section{Open Issues to be discussed by LWG}
Note: this list includes the discussion of p0407 features.
\begin{itemize}
\item \em{Does it make sense to add \tcode{noexcept} specifications for \tcode{move()} and \tcode{swap()} members, since the base classes and other streams do not. At least it does not make sense so for stream objects, since the base classes do not specify that.}
\begin{removedblock}
\item \em{\sout{The \tcode{basic_string} constructors that move from the string get a default template argument for \tcode{SAlloc} in the hope that allows initialization from a character string literal. Need confirmation that this trick works and selects the better constructor for temporary conversion without ambiguity, because for the copying (const-ref) overload the allocator of the string needs to be deduced. This should lead to the effect of optimizing existing usages.}}
\end{removedblock}
\end{itemize}

\section{Open Issues discussed by LEWG in Albuquerque}
\begin{itemize}
\item Should pilfer() be rvalue-ref qualified to denote the "destruction" of the underlying buffer? LEWG in Issaquah didn't think so, but I'd like to ask again. LEWG small group in Albuquerque in favor of rvalue-ref qualification.\added{ Re-establish \tcode{str()\&\&}, drop \tcode{pilfer}}
\end{itemize}

\section{Open Issues discussed by LEWG in Issaquah and Albuquerque}
\begin{itemize}
\item Is the name of the \tcode{str_view()} member function ok? No. Renamed to \tcode{view()}
\item Should the \tcode{str()\&\&} overload be provided for move-out? \removed{No. give it another name (\tcode{pilfer}) and remove rvalue-ref-qualification (Issaquah).}\added{ Re-establish \tcode{str()\&\&}, drop \tcode{pilfer}}
\item Should \tcode{str()\&\&} empty the character sequence or leave it in an unspecified but valid state? Empty it, and specify.
\item Provide guidance on validity lifetime of of the obtained \tcode{string_view} object.
\end{itemize}

\section{Open Issues to be discussed by LEWG/LWG (in Kona?)}
\begin{itemize}
\item LEWG: Please look at constructor overloads (see Table \ref{tab:ctors}) and str() overloads that came from the mix of p0407 with p0408.
\item Both: Constructor overloads taking a string with a different allocator, esp. SFINAE. Is that OK?
\item LWG: Is \tcode{!is_same_v<SAlloc,Allocator>} the correct SFINAE predicate for foreign allocator overloads?
\item LEWG: \tcode{noexcept} for \tcode{view()} member function of stringbuf (note streams have a precondition on this call and can not be noexcept)(suggested by LWG).
\item LWG: Does an Allocator template parameter that is mapped to \tcode{basic_string}'s Allocator template parameter need to conform to \oldconcept{Allocator} requirements or is that given implicit by its usage?
\item LWG: recheck wording.
\end{itemize}


\chapter{Technical Specifications}
The following is relative to n4820.

Remove section on \tcode{char*} streams [depr.str.strstreams] and all its subsections from appendix D.

\section{28.8.2 Adjust synopsis of basic\_stringbuf [stringbuf]}
Add a new constructor overload.

\textit{Note that p0407 provides allocator support for \tcode{basic_stringbuf}, since now both papers have been forwarded to LWG, the changes proposed in p0407 are integrated here for ease of review and integration. The explanations of those changes are added in italics here. from r6 on some changes that need to be revisited by LEWG are made, since the overlap of the two papers' functionality.}

\begin{em}
Change each of the non-moving, non-deleted constructors to add a const-ref \tcode{Allocator} parameter as last parameter with a default constructed \tcode{Allocator} as default argument. Add an overload for the move constructor adding an \tcode{Allocator} parameter like with \tcode{basic_string}. Add an exposition-only member variable \tcode{buf} to allow referring to it for specifying allocator behaviour. May be: Add noexcept specification, depending on allocator behavior, like with \tcode{basic_string}?\
\\
This section also adopts the changes of p1163 by only marking the single argument constructors explicit and provide non-explicit overloads for zero, two or more argument versions. That paper p1163 was tentatively accepted in Batavia, August 2018.
\end{em}

\begin{codeblock}
    // \iref{stringbuf.cons}, constructors
    basic_stringbuf() : basic_stringbuf(ios_base::in | ios_base::out) {}
    explicit basic_stringbuf(ios_base::openmode which);
    explicit basic_stringbuf(
      const basic_string<charT, traits, Allocator>& str,
      ios_base::openmode which = ios_base::in | ios_base::out);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    explicit basic_stringbuf(const Allocator& a)
      : basic_stringbuf(ios_base::in | ios_base::out, a) { }
      
    basic_stringbuf(ios_base::openmode which, const Allocator& a);
    explicit basic_stringbuf(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which = ios_base::in | ios_base::out);
    template<class SAlloc>
    basic_stringbuf(
      const basic_string<charT, traits, SAlloc>& s, 
      const Allocator& a)
      : basic_stringbuf(s, ios_base::in | ios_base::out, a) { }
    template<class SAlloc>
    basic_stringbuf(
      const basic_string<charT, traits, SAlloc>& str,
      ios_base::openmode which,
      const Allocator& a);
    template<class SAlloc>
    basic_stringbuf(
      const basic_string<charT, traits, SAlloc>& str,
      const Allocator& a) : basic_stringbuf(str, ios_base::in | ios_base::out, a) {}
    template<class SAlloc>
    explicit basic_stringbuf(
      const basic_string<charT, traits, SAlloc>& str,
      ios_base::openmode which = ios_base::in | ios_base::out);

\end{codeblock}
\end{addedblock}
%% restrict the last ctor above to SAlloc != Allocator
\begin{codeblock}
    basic_stringbuf(const basic_stringbuf& rhs) = delete;
    basic_stringbuf(basic_stringbuf&& rhs);
    @\added{basic_stringbuf(basic_stringbuf\&\& rhs, const Allocator\& a);}@        


    // \iref{stringbuf.assign}, assign and swap
    basic_stringbuf& operator=(const basic_stringbuf& rhs) = delete;
    basic_stringbuf& operator=(basic_stringbuf&& rhs);
    void swap(basic_stringbuf& rhs) @\added{noexcept(\seebelow)};

\end{codeblock}



\begin{em}
{The following list summarizes the edits:}
\begin{itemize}
\item Add an rvalue-ref overload of \tcode{str()} that obtains the underlying string via moving from buf.
\item Add a \tcode{str(Allcator)} overload template member function to take an Allocator for the returned string and add a reference qualification the existing \tcode{str()} overload.\emph{NEW: was intermingled with existing str() member, now separate.} 
\item Add the \tcode{view()} member function obtaining a \tcode{string_view} to the underlying internal buffer.\emph{NEW: make that noexcept.}
\item Add a setter \tcode{str()} overload as a template member function copying into the string buffer to take an allocator template parameter that differs from the buffer's own \tcode{Allocator} 
\item Add a \tcode{str(string\&\&)} overload that moves from its string rvalue-reference argument into the internal buffer.
\item Provide an exposition-only member function \tcode{init_buf_ptrs()} to ensure streambuf pointers are initialized correctly by all \tcode{buf} setting operations.
\end{itemize}
\end{em}

\begin{codeblock}
    // \iref{stringbuf.members}, get\added{ters} and set\added{ters}:
    basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
    basic_string<charT, traits, Allocator> str() &&;
    basic_string_view<charT, traits> view() const noexcept;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    void str(const basic_string<charT, traits, Allocator>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    void str(const basic_string<charT, traits, SAlloc>& s);
    void str(basic_string<charT, traits, Allocator>&& s);
\end{codeblock}
\end{addedblock}

\textit{Add the following declaration to the public section of synopsis of the class template \tcode{basic_stringbuf}:}
\begin{addedblock}
\begin{codeblock}
    allocator_type get_allocator() const noexcept;
\end{codeblock}
\end{addedblock}

\textit{Add the following exposition only member to the private section of synopsis of the class template \tcode{basic_stringbuf}. This allows to delegate all details of allocator-related behaviour on what \tcode{basic_string} is doing, simplifying this specification a lot.}
\begin{codeblock}
  private:
    ios_base::openmode mode;  // \expos
    @\added{basic_string<charT, traits, Allocator> buf; // \expos }@
    @\added{void init_buf_ptrs(); // \expos }@
\end{codeblock}

\textit{Add a conditional noexcept specification to swap with see below:}
\begin{codeblock}
  template <class charT, class traits, class Allocator>
    void swap(basic_stringbuf<charT, traits, Allocator>& x,
              basic_stringbuf<charT, traits, Allocator>& y) @\added{noexcept(noexcept(x.swap(y)))}@;
\end{codeblock}

\emph{Adjust p2 of the section to include the additionbal exposition only members and add a note on the allocator properties of \tcode{basic_stringbuf}.}

\pnum
The class
\tcode{basic_stringbuf}
is derived from
\tcode{basic_streambuf}
to associate possibly the input sequence and possibly
the output sequence with a sequence of arbitrary
\term{characters}.
The sequence can be initialized from, or made available as, an object of class
\tcode{basic_string}.


\pnum
For the sake of exposition, the maintained data \added{and internal pointer initialization} is presented here as:
\begin{itemize}
\item
\tcode{ios_base::openmode mode},
has
\tcode{in}
set if the input sequence can be read, and
\tcode{out}
set if the output sequence can be written.
\begin{addedblock}
\item
\tcode{basic_string<charT, traits, Allocator> buf}
contains the underlying character sequence.
\item
\tcode{init_buf_ptrs()} 
sets the base class' 
get area (\iref{streambuf.get.area}) and 
put area (\iref{streambuf.put.area}) pointers 
after initializing, moving from, or assigning to 
\tcode{buf} 
accordingly.
\end{addedblock}
\end{itemize}

%% San Diego feedback suggested eliminate the design note:
%\begin{addedblock}
%\pnum
%\begin{note}
%The allocator used by \tcode{basic_stringbuf} is only relevant for \tcode{buf} or the member functions initializing, assigning or returning \tcode{buf}. All allocator (propagation) properties are thus given by \tcode{basic_stringbuf}'s allocator properties.
%\end{note}
%\end{addedblock}



\subsection{28.8.2.1 basic\_stringbuf constructors [stringbuf.cons]}
\begin{em}
Adjust the constructor specifications taking the additional Allocator parameter and an overload for the move-constructor taking an Allocator. Make the constructors' wording that actually construct a buf consistent.
\end{em}

\begin{itemdecl}
explicit basic_stringbuf(ios_base::openmode which);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_stringbuf},
initializing}\added{Initializes} the base class with
\tcode{basic_streambuf()}(\iref{streambuf.cons}), and\removed{ initializing}
\tcode{mode}
with \tcode{which}.
It is
\impldef{whether sequence pointers are initialized to null pointers}
whether the sequence pointers
(\tcode{eback()}, \tcode{gptr()}, \tcode{egptr()},
\tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()})
are initialized to null pointers.

\pnum
\ensures
\tcode{str()}\added{\tcode{.empty()} is \tcode{true}}\removed{\tcode{ == ""}}.
\end{itemdescr}

\begin{itemdecl}
explicit basic_stringbuf(
  const basic_string<charT, traits, Allocator>& s,
  ios_base::openmode which = ios_base::in | ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_stringbuf},
initializing}\added{Initializes} the base class with
\tcode{basic_streambuf()}(\iref{streambuf.cons}), \removed{and initializing}
\tcode{mode}
with \tcode{which} \added{, and \tcode{buf} with \tcode{s}. Then calls  \tcode{init_}\tcode{buf_}\tcode{ptrs()}}.
\removed{Then calls \tcode{str(s)}.}
\end{itemdescr}



\begin{addedblock}
\begin{itemdecl}
basic_stringbuf(
  ios_base::openmode which,
  const Allocator &a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_streambuf()}(\iref{streambuf.cons}), 
\tcode{mode}
with \tcode{which}, and \tcode{buf} with \tcode{a}. Then calls \tcode{init_buf_ptrs()}.

\pnum
\ensures
\tcode{str().empty()} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
explicit basic_stringbuf(
  basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which = ios_base::in | ios_base::out);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects \removed{Constructs an object of class \tcode{basic_stringbuf}, initializing}\added{Initializes} the base class with \tcode{basic_streambuf()} (\iref{streambuf.cons}),\removed{ initializing} \tcode{mode} with \tcode{which}, and  \tcode{buf} with \tcode{std::move(s)}. Then calls \tcode{init\_buf\_ptrs()}.
\end{itemdescr}

\begin{itemdecl}
template<class SAlloc>
basic_stringbuf(
  basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which,
  const Allocator &a);
\end{itemdecl}
\begin{itemdescr}

%\pnum
%\mandates 
%\tcode{SAlloc} shall satisfy the \oldconcept{Allocator} requirements
%(\tref{utilities.allocator.requirements}).
%% TODO

\pnum
\effects 
Initializes the base class with \tcode{basic_streambuf()} (\iref{streambuf.cons}), \tcode{mode} with \tcode{which}, and \tcode{buf} with \tcode{\{s,a\}}. Then calls \tcode{init\_buf\_ptrs()}.

\end{itemdescr}

\begin{itemdecl}
template<class SAlloc>
explicit basic_stringbuf(
  const basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which = ios_base::in | ios_base::out);
\end{itemdecl}
\begin{itemdescr}

\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.
%\tcode{SAlloc} shall satisfy the \oldconcept{Allocator} requirements
%(\tref{utilities.allocator.requirements}).
%% TODO

\pnum
\effects 
Initializes the base class with \tcode{basic_streambuf()} (\iref{streambuf.cons}),  \tcode{mode} with \tcode{which}, and \tcode{buf} with \tcode{s}. Then calls \tcode{init\_buf\_ptrs()}.
\end{itemdescr}


\end{addedblock}



\textit{Add the additional move constructor taking an allocator and adjust the description accordingly:}

\begin{itemdecl}
basic_stringbuf(basic_stringbuf&& rhs);
@\added{basic_stringbuf(basic_stringbuf\&\& rhs, const Allocator\& a);}@
\end{itemdecl}

\emph{Note to LWG reviewers: using std::move(rhs).str() ensures rhs.buf is in a consistent state before the move happens. Before the spec was wrong, because rhs.buf might have been shorter than the actual written characters. Also a drive by (IMHO editorial fix) better spelling out what happens since we now have the exposition only members.}

\begin{itemdescr}
\pnum
\effects \removed{Move constructs from the rvalue \tcode{rhs}. }
\added{Copy constructs the base class from \tcode{rhs} and initializes \tcode{mode} with \tcode{rhs.mode}. %% drive by clarification
In the first form \tcode{buf} is initialized from \tcode{std::move(rhs).str()}. In the second form \tcode{buf} is initialized from \tcode{\{std::move(rhs).str(), a\}}.}
It is
\impldef{whether sequence pointers are copied by \tcode{basic_stringbuf} move
constructor} whether the sequence pointers in \tcode{*this}
(\tcode{eback()}, \tcode{gptr()}, \tcode{egptr()},
\tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}) obtain
the values which \tcode{rhs} had. 
\removed{Whether they do or not, \tcode{*this}
and \tcode{rhs} reference separate buffers (if any at all) after the
construction. The openmode, locale and any other state of \tcode{rhs} is
also copied.}

\pnum
\ensures Let \tcode{rhs_p} refer to the state of
\tcode{rhs} just prior to this construction and let \tcode{rhs_a}
refer to the state of \tcode{rhs} just after this construction.

\begin{itemize}
\item \tcode{str() == rhs_p.str()}
\item \tcode{gptr() - eback() == rhs_p.gptr() - rhs_p.eback()}
\item \tcode{egptr() - eback() == rhs_p.egptr() - rhs_p.eback()}
\item \tcode{pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()}
\item \tcode{epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()}
\item \tcode{if (eback()) eback() != rhs_a.eback()}
\item \tcode{if (gptr()) gptr() != rhs_a.gptr()}
\item \tcode{if (egptr()) egptr() != rhs_a.egptr()}
\item \tcode{if (pbase()) pbase() != rhs_a.pbase()}
\item \tcode{if (pptr()) pptr() != rhs_a.pptr()}
\item \tcode{if (epptr()) epptr() != rhs_a.epptr()}
\begin{addedblock}
\item \tcode{getloc() == rhs_p.getloc()} %% was forgotten in original in postcondition
\item \tcode{rhs} is empty but usable, as if \tcode{std::move(rhs).str()} was called.
\end{addedblock}
\end{itemize}
\end{itemdescr}


%\rSec3[stringbuf.assign]{Assign and swap}
\section{28.8.2.2 Assign and swap [stringbuf.assign]}
\textit{Most of this section is included to allow for simpler adding of conditional noexcept.}

\indexlibrarymember{operator=}{basic_stringbuf}%
\begin{itemdecl}
basic_stringbuf& operator=(basic_stringbuf&& rhs);
\end{itemdecl}
%\added{noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||}\\
%      \added{allocator_traits<Allocator>::is_always_equal::value)}@;

\begin{itemdescr}
\pnum
\effects
%\added{Move assigns \tcode{buf} from \tcode{std::move(rhs).str()}.}
After that move assignment \tcode{*this} has the observable state it would
have had if it had been move constructed from \tcode{rhs} (see~\iref{stringbuf.cons}).

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{swap}{basic_stringbuf}%
\begin{itemdecl}
void swap(basic_stringbuf& rhs) @\added{noexcept(\seebelow)}@;
\end{itemdecl}
%% taken from basic_string::swap

\begin{itemdescr}
\begin{addedblock}
\pnum
\expects \tcode{allocator_traits<Allocator>::propagate_on_container_swap::value} is \tcode{true} or \tcode{get_allocator() == s.get_allocator()}.
\end{addedblock}

\pnum
\effects Exchanges the state of \tcode{*this}
and \tcode{rhs}. 

\begin{addedblock}
\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to: \\
\tcode{allocator_traits<Allocator>::propagate_on_container_swap::value ||}\\
\tcode{allocator_traits<Allocator>::is_always_equal::value}
%\added{Specifically, \tcode{buf.swap(rhs.buf)}.}
\end{addedblock}
\end{itemdescr}

\indexlibrarymember{swap}{basic_stringbuf}%
\begin{itemdecl}
template <class charT, class traits, class Allocator>
  void swap(basic_stringbuf<charT, traits, Allocator>& x,
            basic_stringbuf<charT, traits, Allocator>& y) @\added{noexcept(noexcept(x.swap(y)))}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{x.swap(y)}.
\end{itemdescr}


\subsection{28.8.2.3 Member functions [stringbuf.members]}

\textit{Provide a section introducing paragraph explaining the high-water-mark. The wording is taken directly from n4791 [stringbuf.members] p.1 with some grammar adjustment to adjust to the fact that we now have multiple setters. Introduce the exposition only private member functions \tcode{init_buf_ptrs()} to provide the correct intialization of streambuf pointer members and adjust the \tcode{str(s)} member functions with parameters accordingly. }

\begin{addedblock}
\pnum
The member functions getting the underlying character sequence all refer to a \tcode{high_mark} value, 
 where
\tcode{high_mark} represents the position one past the highest initialized character
in the buffer. Characters can be initialized by writing to the stream, by constructing
the \tcode{basic_stringbuf} passing a \tcode{basic_string} argument, or by calling one of 
the
\tcode{str()} member functions passing a \tcode{basic_string} as an argument. 
In the latter case, all characters initialized prior to
the call are now considered uninitialized (except for those characters re-initialized
by the new \tcode{basic_string}).  

\begin{itemdecl}
void init_buf_ptrs(); // \expos
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Initializes the input and output sequences from \tcode{buf} according to \tcode{mode}.
%% mode is an exposition-only member of basic_stringbuf

\pnum
\ensures
\begin{itemize}
\item If \tcode{ios_base::out} is set in \tcode{mode},\\ 
\tcode{pbase()} points to \tcode{buf.front()} and \\\tcode{epptr() >= pbase() + buf.size()} is \tcode{true}; 
\item in addition, 
\begin{itemize}
\item if \tcode{ios_base::ate} is set in \tcode{mode}, \\
\tcode{pptr() == pbase() + buf.size()} is \tcode{true}, 
\item otherwise \tcode{pptr() == pbase()} is \tcode{true}. 
\end{itemize}
\item If \tcode{ios_base::in} is set in \tcode{mode}, \\
\tcode{eback()} points to \tcode{buf.front()}, 
and \\\tcode{(gptr() == eback()} \tcode{\&\&} \tcode{egptr() == eback() + buf.size())} is \tcode{true}.
\end{itemize}

\pnum
\begin{note}
For efficiency reasons stream buffer operations might violate invariants of \tcode{buf} while it is held encapsulated in the \tcode{basic_stringbuf}, i.e., by writing to characters in the range [\tcode{buf.data()+buf.size(), buf.data()+buf.capacity()}). All operations retrieving a \tcode{basic_string} from \tcode{buf} ensure that the \tcode{basic_string} invariants hold on the returned value.
\end{note}
\end{itemdescr}
\end{addedblock}


\textit{Add the definition of the \tcode{get_allocator} function:}
\begin{addedblock}
%\indexlibrarymember{get_allocator}{basic_stringbuf}%
\begin{itemdecl}
allocator_type get_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{buf.get_allocator()}.

\end{itemdescr}
\end{addedblock}


\textit{Add a getter overload taking an allocator parameter for the copied from string to allow having a different allocator than the underlying stream and add a ref-qualifier to the existing getter overload to avoid ambiguities with the rvalue-ref qualified overload. Add a getter overload that is rref qualified and mention it. Simplify wording by delegating to the new view() member.}
\begin{itemdecl}
    basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{itemdecl}


\begin{itemdescr}
\pnum
\removed{
\returns
A
\tcode{basic_string}
object whose content is equal to the
\tcode{basic_stringbuf}
underlying character sequence.
If the \tcode{basic_stringbuf} was created only in input mode, the resultant
\tcode{basic_string} contains the character sequence in the range
\range{eback()}{egptr()}. If the \tcode{basic_stringbuf} was created with
\tcode{which \& ios_base::out} being nonzero then the resultant \tcode{basic_string}
contains the character sequence in the range \range{pbase()}{high_mark}, where
\tcode{high_mark} represents the position one past the highest initialized character
in the buffer. Characters can be initialized by writing to the stream, by constructing
the \tcode{basic_stringbuf} with a \tcode{basic_string}, or by calling the
\tcode{str(basic_string)} member function. In the case of calling the
\tcode{str(basic_string)} member function, all characters initialized prior to
the call are now considered uninitialized (except for those characters re-initialized
by the new \tcode{basic_string}). Otherwise the \tcode{basic_stringbuf} has been created
in neither input nor output mode and a zero length \tcode{basic_string} is returned.
}

\begin{addedblock} 
\effects Equivalent to: \tcode{return basic_string<charT, traits, Allocator>(view());}
\end{addedblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    template<class SAlloc>
    basic_string<charT, traits, SAlloc> str(const SAlloc& sa) const;
\end{itemdecl}

\begin{itemdescr}
\pnum 
\constraints \tcode{SAlloc} is a type that qualifies as an allocator ([container.requirements.general]).

\pnum
\effects Equivalent to: \tcode{return basic_string<charT, traits, SAlloc>(view());}
\end{itemdescr}
\end{addedblock}

\begin{em}
Add the following specifications for \tcode{str()\&\& and view() const} member function. :
\end{em}

\begin{insrt}
\begin{itemdecl}
basic_string<charT, traits, Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}

\pnum
\returns A \tcode{basic_string<charT, traits, Allocator>} object move constructed from 
the \tcode{basic_stringbuf}'s underlying character sequence
in \tcode{buf}. 
This can be achieved by first adjusting \tcode{buf} to have the same content as \tcode{view()}.

\pnum
\ensures The underlying character sequence \tcode{buf} is empty and \tcode{pbase()}, \tcode{pptr()}, \tcode{epptr()}, \tcode{eback()}, \tcode{gptr()}, \tcode{egptr()} are initialized as if calling \tcode{init_buf_ptrs()} with an empty \tcode{buf}.
\end{itemdescr}

\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns A \tcode{basic_string_view} object referring to the \tcode{basic_stringbuf}'s underlying character sequence
in \tcode{buf}. 
Let \tcode{sv} be \tcode{basic_string_view<charT, traits>}:
\begin{itemize}
\item If \tcode{ios_base::out} is set in \tcode{mode},
then \tcode{sv(pbase(), high_mark-pbase())} is returned.
\item Otherwise, if \tcode{ios_base::in} is set in \tcode{mode},
then \tcode{sv(eback(), egptr()-eback())} is returned.
\item Otherwise, a \tcode{basic_string_view} referring to an empty range is returned. 
\end{itemize}

\pnum
\begin{note}
Using the returned \tcode{basic_string_view} object after destruction or invalidation of the character sequence underlying \tcode{*this} is undefined behavior. 
\end{note}
\end{itemdescr}
\end{addedblock}

\textit{add setter overloads and simplify their specification trough relying on buf and init_buf_ptrs().}

\begin{addedblock}
\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
    buf = std::move(s); 
    init_buf_ptrs();
\end{codeblock}
\end{itemdescr}
\end{insrt}

\begin{itemdecl}
void str(const basic_string<charT, traits, Allocator>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \added{Equivalent to:}
\begin{addedblock}
\begin{codeblock}
    buf = s; 
    init_buf_ptrs();
\end{codeblock}
\end{addedblock}
\removed{
Copies the content of \tcode{s} into the \tcode{basic_stringbuf} underlying character
sequence and initializes the input and output sequences according to \tcode{mode}}.

\removed{
\pnum
\ensures 
If \tcode{mode \& ios_base::out} is nonzero, \tcode{pbase()} points to the
first underlying character and \tcode{epptr()} \tcode{>= pbase() + s.size()} holds; in
addition, if \tcode{mode \& ios_base::ate} is nonzero,
\tcode{pptr() == pbase() + s.size()}
holds, otherwise \tcode{pptr() == pbase()} is \tcode{true}. If \tcode{mode \& ios_base::in} is
nonzero, \tcode{eback()} points to the first underlying character, and both \tcode{gptr()
== eback()} and \tcode{egptr() == eback() + s.size()} hold.
}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.
\end{addedblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    buf = s; 
    init_buf_ptrs();
\end{codeblock}
\end{itemdescr}
\end{addedblock}


%% istream
\section{28.8.3 Adjust synopsis of basic\_istringstream [istringstream]}

\begin{em}
Provide constructor overloads taking an Allocator argument and also those that allow a string with a different allocator type.
\end{em}

\begin{codeblock}
    // \iref{istringstream.cons}, constructors:
    basic_istringstream() : basic_istringstream(ios_base::in) {}
    explicit basic_istringstream(ios_base::openmode which);
    explicit basic_istringstream(
      const basic_string<charT, traits, Allocator>& str,
      ios_base::openmode which = ios_base::in);
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_istringstream(
      ios_base::openmode which,
      const Allocator& a);
    explicit basic_istringstream(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which = ios_base::in);

    template <class SAlloc>
    basic_istringstream(
      const basic_string<charT, traits, SAlloc>& s,
      const Allocator& a) : basic_istringstream(s, ios_base::in, a) {}
    template <class SAlloc>
    basic_istringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which,
      const Allocator& a);
    template <class SAlloc>
    explicit basic_istringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which = ios_base::in);

\end{codeblock}\end{addedblock}
\begin{codeblock}      
    basic_istringstream(const basic_istringstream& rhs) = delete;
    basic_istringstream(basic_istringstream&& rhs);
\end{codeblock}

\textit{Adjust getter/setter members according to basic_stringbuf:}

\begin{codeblock}
    // \iref{istringstream.members}, members:
    basic_stringbuf<charT, traits, Allocator>* rdbuf() const;

    basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
    basic_string<charT, traits, Allocator> str() &&;
    basic_string_view<charT, traits> view() const;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    void str(const basic_string<charT, traits, Allocator>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    void str(const basic_string<charT, traits, SAlloc>& s);
    void str(basic_string<charT, traits, Allocator>&& s);
\end{codeblock}
\end{addedblock}

\subsection{28.8.3.1 basic\_istringstream constructors [istringstream.cons]}
\begin{em}
Adjust the constructor specifications analog to basic_stringbuf. deliberately do not provide the special move constructor taking an allocator. Drive-by editorial fix to include Allocator template argument.
\end{em}

\begin{itemdecl}
explicit basic_istringstream(ios_base::openmode which);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_istringstream<charT, traits>},
initializing}\added{Initializes} the base class with
\tcode{basic_istream<charT, traits>(addressof(sb))}(\iref{istream})
and \removed{initializing }\tcode{sb} with %\linebreak % avoid Overfull
\tcode{basic_stringbuf<charT, traits, Allocator>(which | ios_base::in)}~(\iref{stringbuf.cons}).
\end{itemdescr}

\indexlibrary{\idxcode{basic_istringstream}!constructor}%
\begin{itemdecl}
explicit basic_istringstream(
  const basic_string<charT, traits, Allocator>& str,
  ios_base::openmode which = ios_base::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_istringstream<charT, traits>},
initializing}\added{Initializes} the base class with
\tcode{basic_istream<charT, traits>(addressof(sb))}(\iref{istream})
and \removed{initializing }\tcode{sb} with %\linebreak % avoid Overfull
\tcode{basic_stringbuf<charT, traits, Allocator>(str, which | ios_base::in)}~(\iref{stringbuf.cons}).
\end{itemdescr}


\begin{addedblock}
\begin{itemdecl}
basic_istringstream(
  ios_base::openmode which,
  const Allocator& a);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_istream<charT, traits>(addressof(sb))}(\iref{istream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(which | ios_base::in, a)}~(\iref{stringbuf.cons}).
\end{itemdescr}

\begin{itemdecl}
explicit basic_istringstream(
  basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which = ios_base::in);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Initializes the base class with
\tcode{basic_istream<charT, traits>(addressof(sb))}(\iref{istream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(std::move(s), which | ios_base::in)}
(\iref{stringbuf.cons}).
\end{itemdescr}

\begin{itemdecl}
template<class SAlloc>
basic_istringstream(
  const basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which,
  const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Initializes the base class with
\tcode{basic_istream<charT, traits>(addressof(sb))}(\iref{istream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::in, a)}~(\iref{stringbuf.cons}).
\end{itemdescr}


\begin{itemdecl}
template<class SAlloc>
explicit basic_istringstream(
  const basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which = ios_base::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.

\pnum
\effects 
Initializes the base class with
\tcode{basic_istream<charT, traits>(addressof(sb))}(\iref{istream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::in)}~(\iref{stringbuf.cons}).
\end{itemdescr}
\end{addedblock}

\subsection{28.8.3.3 Member functions [istringstream.members]}
\textit{Extend \tcode{str()} overloads according to basic_stringbuf and add \tcode{view()}}:

\indexlibrarymember{str}{basic_istringstream}%
\begin{itemdecl}
basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns}
\added{\effects Equivalent to: \tcode{return} }
\tcode{rdbuf()->str()}\removed{.}\added{\tcode{;}}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return} 
\tcode{rdbuf()->str(sa)}.
\end{itemdescr}

\begin{itemdecl}
basic_string<charT,traits,Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return}  \tcode{std::move(*rdbuf()).str()}.

%\pnum
%\begin{note}
%Calling this member function leaves the stream object in a usable state with an emptied underlying \tcode{basic_stringbuf}.
%\end{note}
\end{itemdescr}

\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return}  \tcode{rdbuf()->view()}.
% can not be noexcept, because rdbuf() might return nullptr or even throw.
\end{itemdescr}

\end{addedblock}

\indexlibrarymember{str}{basic_istringstream}%
\begin{itemdecl}
void str(const basic_string<charT, traits, Allocator>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Calls}\added{Equivalent to:} 
\tcode{rdbuf()->str(s)}.
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.
%Marshall to decide

\pnum
\effects
Equivalent to: 
\tcode{rdbuf()->str(s)}.
\end{itemdescr}

\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Equivalent to: 
\tcode{rdbuf()->str(std::move(s))}.
\end{itemdescr}
\end{addedblock}

%%ostream

\section{28.8.4 Adjust synopsis of basic\_ostringstream [ostringstream]}
\begin{em}
Provide constructor overloads taking an Allocator argument and also those that allow a string with a different allocator type.
\end{em}

\begin{codeblock}
    // \iref{ostringstream.cons}, constructors:
    basic_ostringstream() : basic_ostringstream(ios_base::in) {}
    explicit basic_ostringstream(ios_base::openmode which);
    explicit basic_ostringstream(
      const basic_string<charT, traits, Allocator>& str,
      ios_base::openmode which = ios_base::out);
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_ostringstream(
      ios_base::openmode which,
      const Allocator& a);
    explicit basic_ostringstream(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which = ios_base::out);

    template <class SAlloc>
    basic_ostringstream(
      const basic_string<charT, traits, SAlloc>& s,
      const Allocator& a) : basic_ostringstream(s, ios_base::out, a) {}
    template <class SAlloc>
    basic_ostringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which,
      const Allocator& a);
    template <class SAlloc>
    explicit basic_ostringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which = ios_base::out);

\end{codeblock}\end{addedblock}
\begin{codeblock}      
    basic_ostringstream(const basic_ostringstream& rhs) = delete;
    basic_ostringstream(basic_ostringstream&& rhs);
\end{codeblock}

\textit{Adjust getter/setter members according to basic_stringbuf:}

\begin{codeblock}
    // \iref{ostringstream.members}, members:
    basic_stringbuf<charT, traits, Allocator>* rdbuf() const;

    basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
    basic_string<charT, traits, Allocator> str() &&;
    basic_string_view<charT, traits> view() const;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    void str(const basic_string<charT, traits, Allocator>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    void str(const basic_string<charT, traits, SAlloc>& s);
    void str(basic_string<charT, traits, Allocator>&& s);
\end{codeblock}
\end{addedblock}

\subsection{28.8.4.1 basic\_ostringstream constructors [ostringstream.cons]}

\begin{em}
Adjust the constructor specifications analog to basic_stringbuf. deliberately do not provide the special move constructor taking an allocator. Drive-by editorial fix to include Allocator template argument.
\end{em}

\begin{itemdecl}
explicit basic_ostringstream(ios_base::openmode which);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_ostringstream<charT, traits\added{, Allocator}>},
initializing}\added{Initializes} the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}(\iref{ostream})
and \removed{initializing }\tcode{sb} with %\linebreak % avoid Overfull
\tcode{basic_stringbuf<charT, traits, Allocator>(which | ios_base::out)}~(\iref{stringbuf.cons}).
\end{itemdescr}

\indexlibrary{\idxcode{basic_ostringstream}!constructor}%
\begin{itemdecl}
explicit basic_ostringstream(
  const basic_string<charT, traits, Allocator>& str,
  ios_base::openmode which = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_ostringstream<charT, traits\added{, Allocator}>},
initializing}\added{Initializes} the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}(\iref{ostream})
and \removed{initializing }\tcode{sb} with%\linebreak % avoid Overfull
\tcode{basic_stringbuf<charT, traits, Allocator>(str, which | ios_base::out)}~(\iref{stringbuf.cons}).
\end{itemdescr}


\begin{addedblock}
\begin{itemdecl}
basic_ostringstream(
  ios_base::openmode which,
  const Allocator& a);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}~(\iref{ostream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(which | ios_base::out, a)}~(\iref{stringbuf.cons}).
\end{itemdescr}

\begin{itemdecl}
explicit basic_ostringstream(
  basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which = ios_base::out);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Initializes the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}(\iref{ostream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(std::move(s), which | ios_base::out)}~(\iref{stringbuf.cons}).
\end{itemdescr}

\begin{itemdecl}
template<class SAlloc>
basic_ostringstream(
  const basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which,
  const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Initializes the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}(\iref{ostream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::out, a)}~(\iref{stringbuf.cons}).
\end{itemdescr}


\begin{itemdecl}
template<class SAlloc>
explicit basic_ostringstream(
  const basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which = ios_base::out);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.

\pnum
\effects 
Initializes the base class with
\tcode{basic_ostream<charT, traits>(addressof(sb))}(\iref{ostream})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(s, which | ios_base::out)}~(\iref{stringbuf.cons}).
\end{itemdescr}
\end{addedblock}

\subsection{28.8.4.3 Member functions [ostringstream.members]}
\textit{Extend \tcode{str()} overloads according to basic_stringbuf and add \tcode{view()}}:

\indexlibrarymember{str}{basic_ostringstream}%
\begin{itemdecl}
basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns}
\added{\effects Equivalent to: \tcode{return} }
\tcode{rdbuf()->str()}\removed{.}\added{\tcode{;}}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return} 
\tcode{rdbuf()->str(sa)}.
\end{itemdescr}

\begin{itemdecl}
basic_string<charT,traits,Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return}  \tcode{std::move(*rdbuf()).str()}.

%\pnum
%\begin{note}
%Calling this member function leaves the stream object in a usable state with an emptied underlying \tcode{basic_stringbuf}.
%\end{note}
\end{itemdescr}

\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return}  \tcode{rdbuf()->view()}.
% can not be noexcept, because rdbuf() might return nullptr or even throw.
\end{itemdescr}

\end{addedblock}

\indexlibrarymember{str}{basic_ostringstream}%
\begin{itemdecl}
void str(const basic_string<charT, traits, Allocator>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Calls}\added{Equivalent to:} 
\tcode{rdbuf()->str(s)}.
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.
%Marshall to decide

\pnum
\effects
Equivalent to: 
\tcode{rdbuf()->str(s)}.
\end{itemdescr}

\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Equivalent to: 
\tcode{rdbuf()->str(std::move(s))}.
\end{itemdescr}
\end{addedblock}

%%stringstream
\section{28.8.5 Adjust synopsis of basic\_stringstream [stringstream]}
\begin{em}
Provide constructor overloads taking an Allocator argument and also those that allow a string with a different allocator type.
\end{em}

\begin{codeblock}
    // \iref{stringstream.cons}, constructors:
    basic_stringstream() : basic_stringstream(ios_base::out | ios_base::in) {}
    explicit basic_stringstream(ios_base::openmode which);
    explicit basic_stringstream(
      const basic_string<charT, traits, Allocator>& str,
      ios_base::openmode which = ios_base::out | ios_base::in);
\end{codeblock}
\begin{addedblock}\begin{codeblock}
    basic_stringstream(
      ios_base::openmode which,
      const Allocator& a);
    explicit basic_stringstream(
      basic_string<charT, traits, Allocator>&& s,
      ios_base::openmode which = ios_base::out | ios_base::in);

    template <class SAlloc>
    basic_stringstream(
      const basic_string<charT, traits, SAlloc>& s,
      const Allocator& a) : basic_stringstream(s, ios_base::out | ios_base::in, a) {}
    template <class SAlloc>
    basic_stringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which,
      const Allocator& a);
    template <class SAlloc>
    explicit basic_stringstream(
      const basic_string<charT, traits, SAlloc>& s,
      ios_base::openmode which = ios_base::out | ios_base::in);

\end{codeblock}\end{addedblock}
\begin{codeblock}      
    basic_stringstream(const basic_stringstream& rhs) = delete;
    basic_stringstream(basic_stringstream&& rhs);
\end{codeblock}

\textit{Adjust getter/setter members according to basic_stringbuf:}

\begin{codeblock}
    // \iref{ostringstream.members}, members:
    basic_stringbuf<charT, traits, Allocator>* rdbuf() const;

    basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
    basic_string<charT, traits, Allocator> str() &&;
    basic_string_view<charT, traits> view() const;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    void str(const basic_string<charT, traits, Allocator>& s);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class SAlloc>
    void str(const basic_string<charT, traits, SAlloc>& s);
    void str(basic_string<charT, traits, Allocator>&& s);
\end{codeblock}
\end{addedblock}

\subsection{28.8.4.1 basic\_stringstream constructors [stringstream.cons]}
\begin{em}
Adjust the constructor specifications analog to basic_stringbuf. deliberately do not provide the special move constructor taking an allocator. Drive-by editorial fix to include Allocator template argument.
\end{em}

\begin{itemdecl}
explicit basic_stringstream(ios_base::openmode which);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_stringstream<charT, traits\added{, Allocator}>},
initializing}\added{Initializes} the base class with
\tcode{basic_iostream<charT, traits>(addressof(sb))}(\iref{iostream.cons})
and initializing \tcode{sb} with %\linebreak % avoid Overfull
\tcode{basic_stringbuf<charT, traits, Allocator>(which)}
(\iref{stringbuf.cons}).
\end{itemdescr}

\indexlibrary{\idxcode{basic_stringstream}!constructor}%
\begin{itemdecl}
explicit basic_stringstream(
  const basic_string<charT, traits, Allocator>& str,
  ios_base::openmode which = ios_base::out | ios_base::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Constructs an object of class
\tcode{basic_stringstream<charT, traits\added{, Allocator}>},
initializing}\added{Initializes} the base class with
\tcode{basic_iostream<charT, traits>(addressof(sb))}(\iref{iostream.cons})
and \removed{initializing }\tcode{sb} with%\linebreak % avoid Overfull
\tcode{basic_stringbuf<charT, traits, Allocator>(str, which)}~(\iref{stringbuf.cons}).
\end{itemdescr}


\begin{addedblock}
\begin{itemdecl}
basic_stringstream(
  ios_base::openmode which,
  const Allocator& a);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Initializes the base class with
\tcode{basic_iostream<charT, traits>(addressof(sb))}(\iref{iostream.cons})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(which, a)}~(\iref{stringbuf.cons}).
\end{itemdescr}

\begin{itemdecl}
explicit basic_stringstream(
  basic_string<charT, traits, Allocator>&& s,
  ios_base::openmode which = ios_base::out | ios_base::in);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Initializes the base class with
\tcode{basic_iostream<charT, traits>(addressof(sb))}(\iref{iostream.cons})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(std::move(s), which)}~(\iref{stringbuf.cons}).
\end{itemdescr}

\begin{itemdecl}
template<class SAlloc>
basic_stringstream(
  const basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which,
  const Allocator& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects 
Initializes the base class with
\tcode{basic_iostream<charT, traits>(addressof(sb))}(\iref{iostream.cons})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(s, which, a)}~(\iref{stringbuf.cons}).
\end{itemdescr}


\begin{itemdecl}
template<class SAlloc>
explicit basic_stringstream(
  const basic_string<charT, traits, SAlloc>& s,
  ios_base::openmode which = ios_base::out | ios_base::in);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.

\pnum
\effects 
Initializes the base class with
\tcode{basic_iostream<charT, traits>(addressof(sb))}(\iref{iostream.cons})
and \tcode{sb} with
\tcode{basic_stringbuf<charT, traits, Allocator>(s, which)}~(\iref{stringbuf.cons}).
\end{itemdescr}
\end{addedblock}


\subsection{28.8.4.3 Member functions [stringstream.members]}
\textit{Extend \tcode{str()} overloads according to basic_stringbuf and add \tcode{view()}}:

\indexlibrarymember{str}{basic_stringstream}%
\begin{itemdecl}
basic_string<charT, traits, Allocator> str() const @\added{\&}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns}
\added{\effects Equivalent to: \tcode{return} }
\tcode{rdbuf()->str()}\removed{.}\added{\tcode{;}}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template<class SAlloc>
basic_string<charT,traits,SAlloc> str(const SAlloc& sa) const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return} 
\tcode{rdbuf()->str(sa)}.
\end{itemdescr}

\begin{itemdecl}
basic_string<charT,traits,Allocator> str() &&;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return}  \tcode{std::move(*rdbuf()).str()}.

%\pnum
%\begin{note}
%Calling this member function leaves the stream object in a usable state with an emptied underlying \tcode{basic_stringbuf}.
%\end{note}
\end{itemdescr}

\begin{itemdecl}
basic_string_view<charT, traits> view() const;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return}  \tcode{rdbuf()->view()}.
% can not be noexcept, because rdbuf() might return nullptr or even throw.
\end{itemdescr}

\end{addedblock}

\indexlibrarymember{str}{basic_stringstream}%
\begin{itemdecl}
void str(const basic_string<charT, traits, Allocator>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\removed{Calls}
\added{Equivalent to:} 
\tcode{rdbuf()->str(s)}.
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template<class SAlloc>
void str(const basic_string<charT, traits, SAlloc>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints \tcode{is_same_v<SAlloc,Allocator>} is \tcode{false}.
%Marshall to decide

\pnum
\effects
Equivalent to: 
\tcode{rdbuf()->str(s)}.
\end{itemdescr}

\begin{itemdecl}
void str(basic_string<charT, traits, Allocator>&& s);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects 
Equivalent to: 
\tcode{rdbuf()->str(std::move(s))}.
\end{itemdescr}
\end{addedblock}


\chapter{Appendix: Example Implementations}

The given specification has been implemented within a recent version of the sstream header of gcc8. Modified version of the headers and some tests are available at
\url{https://github.com/PeterSommerlad/SC22WG21_Papers/tree/master/workspace/Test_basic_stringbuf_efficient/src}.

A corresponding implementation for clang 7 is available in the vicinity of the one above at:
\url{https://github.com/PeterSommerlad/SC22WG21_Papers/tree/master/workspace/Test_clang_p0407_p0408}
\end{document}

